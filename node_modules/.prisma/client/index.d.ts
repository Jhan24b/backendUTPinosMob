
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Malla
 * 
 */
export type Malla = $Result.DefaultSelection<Prisma.$MallaPayload>
/**
 * Model CursosMalla
 * 
 */
export type CursosMalla = $Result.DefaultSelection<Prisma.$CursosMallaPayload>
/**
 * Model Curso
 * 
 */
export type Curso = $Result.DefaultSelection<Prisma.$CursoPayload>
/**
 * Model CursoMatriculado
 * 
 */
export type CursoMatriculado = $Result.DefaultSelection<Prisma.$CursoMatriculadoPayload>
/**
 * Model Nota
 * 
 */
export type Nota = $Result.DefaultSelection<Prisma.$NotaPayload>
/**
 * Model Pagos
 * 
 */
export type Pagos = $Result.DefaultSelection<Prisma.$PagosPayload>
/**
 * Model Servicios
 * 
 */
export type Servicios = $Result.DefaultSelection<Prisma.$ServiciosPayload>
/**
 * Model Tramites
 * 
 */
export type Tramites = $Result.DefaultSelection<Prisma.$TramitesPayload>
/**
 * Model PeriodoMatriculado
 * 
 */
export type PeriodoMatriculado = $Result.DefaultSelection<Prisma.$PeriodoMatriculadoPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model TramitesRealizados
 * 
 */
export type TramitesRealizados = $Result.DefaultSelection<Prisma.$TramitesRealizadosPayload>
/**
 * Model ServiciosUtilizados
 * 
 */
export type ServiciosUtilizados = $Result.DefaultSelection<Prisma.$ServiciosUtilizadosPayload>
/**
 * Model confirmacionPago
 * 
 */
export type confirmacionPago = $Result.DefaultSelection<Prisma.$confirmacionPagoPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Mallas
 * const mallas = await prisma.malla.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Mallas
   * const mallas = await prisma.malla.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.malla`: Exposes CRUD operations for the **Malla** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mallas
    * const mallas = await prisma.malla.findMany()
    * ```
    */
  get malla(): Prisma.MallaDelegate<ExtArgs>;

  /**
   * `prisma.cursosMalla`: Exposes CRUD operations for the **CursosMalla** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CursosMallas
    * const cursosMallas = await prisma.cursosMalla.findMany()
    * ```
    */
  get cursosMalla(): Prisma.CursosMallaDelegate<ExtArgs>;

  /**
   * `prisma.curso`: Exposes CRUD operations for the **Curso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cursos
    * const cursos = await prisma.curso.findMany()
    * ```
    */
  get curso(): Prisma.CursoDelegate<ExtArgs>;

  /**
   * `prisma.cursoMatriculado`: Exposes CRUD operations for the **CursoMatriculado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CursoMatriculados
    * const cursoMatriculados = await prisma.cursoMatriculado.findMany()
    * ```
    */
  get cursoMatriculado(): Prisma.CursoMatriculadoDelegate<ExtArgs>;

  /**
   * `prisma.nota`: Exposes CRUD operations for the **Nota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notas
    * const notas = await prisma.nota.findMany()
    * ```
    */
  get nota(): Prisma.NotaDelegate<ExtArgs>;

  /**
   * `prisma.pagos`: Exposes CRUD operations for the **Pagos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pagos.findMany()
    * ```
    */
  get pagos(): Prisma.PagosDelegate<ExtArgs>;

  /**
   * `prisma.servicios`: Exposes CRUD operations for the **Servicios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicios.findMany()
    * ```
    */
  get servicios(): Prisma.ServiciosDelegate<ExtArgs>;

  /**
   * `prisma.tramites`: Exposes CRUD operations for the **Tramites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tramites
    * const tramites = await prisma.tramites.findMany()
    * ```
    */
  get tramites(): Prisma.TramitesDelegate<ExtArgs>;

  /**
   * `prisma.periodoMatriculado`: Exposes CRUD operations for the **PeriodoMatriculado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PeriodoMatriculados
    * const periodoMatriculados = await prisma.periodoMatriculado.findMany()
    * ```
    */
  get periodoMatriculado(): Prisma.PeriodoMatriculadoDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.tramitesRealizados`: Exposes CRUD operations for the **TramitesRealizados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TramitesRealizados
    * const tramitesRealizados = await prisma.tramitesRealizados.findMany()
    * ```
    */
  get tramitesRealizados(): Prisma.TramitesRealizadosDelegate<ExtArgs>;

  /**
   * `prisma.serviciosUtilizados`: Exposes CRUD operations for the **ServiciosUtilizados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiciosUtilizados
    * const serviciosUtilizados = await prisma.serviciosUtilizados.findMany()
    * ```
    */
  get serviciosUtilizados(): Prisma.ServiciosUtilizadosDelegate<ExtArgs>;

  /**
   * `prisma.confirmacionPago`: Exposes CRUD operations for the **confirmacionPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfirmacionPagos
    * const confirmacionPagos = await prisma.confirmacionPago.findMany()
    * ```
    */
  get confirmacionPago(): Prisma.confirmacionPagoDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Malla: 'Malla',
    CursosMalla: 'CursosMalla',
    Curso: 'Curso',
    CursoMatriculado: 'CursoMatriculado',
    Nota: 'Nota',
    Pagos: 'Pagos',
    Servicios: 'Servicios',
    Tramites: 'Tramites',
    PeriodoMatriculado: 'PeriodoMatriculado',
    Usuario: 'Usuario',
    Account: 'Account',
    Session: 'Session',
    TramitesRealizados: 'TramitesRealizados',
    ServiciosUtilizados: 'ServiciosUtilizados',
    confirmacionPago: 'confirmacionPago',
    Event: 'Event',
    Task: 'Task'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "malla" | "cursosMalla" | "curso" | "cursoMatriculado" | "nota" | "pagos" | "servicios" | "tramites" | "periodoMatriculado" | "usuario" | "account" | "session" | "tramitesRealizados" | "serviciosUtilizados" | "confirmacionPago" | "event" | "task"
      txIsolationLevel: never
    }
    model: {
      Malla: {
        payload: Prisma.$MallaPayload<ExtArgs>
        fields: Prisma.MallaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MallaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MallaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          findFirst: {
            args: Prisma.MallaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MallaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          findMany: {
            args: Prisma.MallaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>[]
          }
          create: {
            args: Prisma.MallaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          createMany: {
            args: Prisma.MallaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MallaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          update: {
            args: Prisma.MallaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          deleteMany: {
            args: Prisma.MallaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MallaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MallaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MallaPayload>
          }
          aggregate: {
            args: Prisma.MallaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMalla>
          }
          groupBy: {
            args: Prisma.MallaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MallaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MallaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MallaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MallaCountArgs<ExtArgs>
            result: $Utils.Optional<MallaCountAggregateOutputType> | number
          }
        }
      }
      CursosMalla: {
        payload: Prisma.$CursosMallaPayload<ExtArgs>
        fields: Prisma.CursosMallaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursosMallaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursosMallaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          findFirst: {
            args: Prisma.CursosMallaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursosMallaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          findMany: {
            args: Prisma.CursosMallaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>[]
          }
          create: {
            args: Prisma.CursosMallaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          createMany: {
            args: Prisma.CursosMallaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CursosMallaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          update: {
            args: Prisma.CursosMallaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          deleteMany: {
            args: Prisma.CursosMallaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursosMallaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursosMallaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursosMallaPayload>
          }
          aggregate: {
            args: Prisma.CursosMallaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCursosMalla>
          }
          groupBy: {
            args: Prisma.CursosMallaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursosMallaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CursosMallaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CursosMallaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CursosMallaCountArgs<ExtArgs>
            result: $Utils.Optional<CursosMallaCountAggregateOutputType> | number
          }
        }
      }
      Curso: {
        payload: Prisma.$CursoPayload<ExtArgs>
        fields: Prisma.CursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findFirst: {
            args: Prisma.CursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          findMany: {
            args: Prisma.CursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>[]
          }
          create: {
            args: Prisma.CursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          createMany: {
            args: Prisma.CursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          update: {
            args: Prisma.CursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          deleteMany: {
            args: Prisma.CursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoPayload>
          }
          aggregate: {
            args: Prisma.CursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurso>
          }
          groupBy: {
            args: Prisma.CursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CursoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CursoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CursoCountArgs<ExtArgs>
            result: $Utils.Optional<CursoCountAggregateOutputType> | number
          }
        }
      }
      CursoMatriculado: {
        payload: Prisma.$CursoMatriculadoPayload<ExtArgs>
        fields: Prisma.CursoMatriculadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CursoMatriculadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CursoMatriculadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          findFirst: {
            args: Prisma.CursoMatriculadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CursoMatriculadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          findMany: {
            args: Prisma.CursoMatriculadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>[]
          }
          create: {
            args: Prisma.CursoMatriculadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          createMany: {
            args: Prisma.CursoMatriculadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CursoMatriculadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          update: {
            args: Prisma.CursoMatriculadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          deleteMany: {
            args: Prisma.CursoMatriculadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CursoMatriculadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CursoMatriculadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CursoMatriculadoPayload>
          }
          aggregate: {
            args: Prisma.CursoMatriculadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCursoMatriculado>
          }
          groupBy: {
            args: Prisma.CursoMatriculadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CursoMatriculadoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CursoMatriculadoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CursoMatriculadoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CursoMatriculadoCountArgs<ExtArgs>
            result: $Utils.Optional<CursoMatriculadoCountAggregateOutputType> | number
          }
        }
      }
      Nota: {
        payload: Prisma.$NotaPayload<ExtArgs>
        fields: Prisma.NotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          findFirst: {
            args: Prisma.NotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          findMany: {
            args: Prisma.NotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>[]
          }
          create: {
            args: Prisma.NotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          createMany: {
            args: Prisma.NotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          update: {
            args: Prisma.NotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          deleteMany: {
            args: Prisma.NotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotaPayload>
          }
          aggregate: {
            args: Prisma.NotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNota>
          }
          groupBy: {
            args: Prisma.NotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotaCountArgs<ExtArgs>
            result: $Utils.Optional<NotaCountAggregateOutputType> | number
          }
        }
      }
      Pagos: {
        payload: Prisma.$PagosPayload<ExtArgs>
        fields: Prisma.PagosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          findFirst: {
            args: Prisma.PagosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          findMany: {
            args: Prisma.PagosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>[]
          }
          create: {
            args: Prisma.PagosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          createMany: {
            args: Prisma.PagosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PagosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          update: {
            args: Prisma.PagosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          deleteMany: {
            args: Prisma.PagosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagosPayload>
          }
          aggregate: {
            args: Prisma.PagosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagos>
          }
          groupBy: {
            args: Prisma.PagosGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagosGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PagosFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PagosAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PagosCountArgs<ExtArgs>
            result: $Utils.Optional<PagosCountAggregateOutputType> | number
          }
        }
      }
      Servicios: {
        payload: Prisma.$ServiciosPayload<ExtArgs>
        fields: Prisma.ServiciosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiciosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiciosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          findFirst: {
            args: Prisma.ServiciosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiciosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          findMany: {
            args: Prisma.ServiciosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>[]
          }
          create: {
            args: Prisma.ServiciosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          createMany: {
            args: Prisma.ServiciosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiciosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          update: {
            args: Prisma.ServiciosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          deleteMany: {
            args: Prisma.ServiciosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiciosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiciosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosPayload>
          }
          aggregate: {
            args: Prisma.ServiciosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicios>
          }
          groupBy: {
            args: Prisma.ServiciosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiciosGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiciosFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiciosAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiciosCountArgs<ExtArgs>
            result: $Utils.Optional<ServiciosCountAggregateOutputType> | number
          }
        }
      }
      Tramites: {
        payload: Prisma.$TramitesPayload<ExtArgs>
        fields: Prisma.TramitesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TramitesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TramitesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          findFirst: {
            args: Prisma.TramitesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TramitesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          findMany: {
            args: Prisma.TramitesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>[]
          }
          create: {
            args: Prisma.TramitesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          createMany: {
            args: Prisma.TramitesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TramitesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          update: {
            args: Prisma.TramitesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          deleteMany: {
            args: Prisma.TramitesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TramitesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TramitesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesPayload>
          }
          aggregate: {
            args: Prisma.TramitesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTramites>
          }
          groupBy: {
            args: Prisma.TramitesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TramitesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TramitesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TramitesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TramitesCountArgs<ExtArgs>
            result: $Utils.Optional<TramitesCountAggregateOutputType> | number
          }
        }
      }
      PeriodoMatriculado: {
        payload: Prisma.$PeriodoMatriculadoPayload<ExtArgs>
        fields: Prisma.PeriodoMatriculadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeriodoMatriculadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeriodoMatriculadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          findFirst: {
            args: Prisma.PeriodoMatriculadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeriodoMatriculadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          findMany: {
            args: Prisma.PeriodoMatriculadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>[]
          }
          create: {
            args: Prisma.PeriodoMatriculadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          createMany: {
            args: Prisma.PeriodoMatriculadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PeriodoMatriculadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          update: {
            args: Prisma.PeriodoMatriculadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          deleteMany: {
            args: Prisma.PeriodoMatriculadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeriodoMatriculadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PeriodoMatriculadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodoMatriculadoPayload>
          }
          aggregate: {
            args: Prisma.PeriodoMatriculadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriodoMatriculado>
          }
          groupBy: {
            args: Prisma.PeriodoMatriculadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodoMatriculadoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PeriodoMatriculadoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PeriodoMatriculadoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PeriodoMatriculadoCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodoMatriculadoCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UsuarioFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UsuarioAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      TramitesRealizados: {
        payload: Prisma.$TramitesRealizadosPayload<ExtArgs>
        fields: Prisma.TramitesRealizadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TramitesRealizadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TramitesRealizadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          findFirst: {
            args: Prisma.TramitesRealizadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TramitesRealizadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          findMany: {
            args: Prisma.TramitesRealizadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>[]
          }
          create: {
            args: Prisma.TramitesRealizadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          createMany: {
            args: Prisma.TramitesRealizadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TramitesRealizadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          update: {
            args: Prisma.TramitesRealizadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          deleteMany: {
            args: Prisma.TramitesRealizadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TramitesRealizadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TramitesRealizadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TramitesRealizadosPayload>
          }
          aggregate: {
            args: Prisma.TramitesRealizadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTramitesRealizados>
          }
          groupBy: {
            args: Prisma.TramitesRealizadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<TramitesRealizadosGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TramitesRealizadosFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TramitesRealizadosAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TramitesRealizadosCountArgs<ExtArgs>
            result: $Utils.Optional<TramitesRealizadosCountAggregateOutputType> | number
          }
        }
      }
      ServiciosUtilizados: {
        payload: Prisma.$ServiciosUtilizadosPayload<ExtArgs>
        fields: Prisma.ServiciosUtilizadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiciosUtilizadosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiciosUtilizadosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          findFirst: {
            args: Prisma.ServiciosUtilizadosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiciosUtilizadosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          findMany: {
            args: Prisma.ServiciosUtilizadosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>[]
          }
          create: {
            args: Prisma.ServiciosUtilizadosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          createMany: {
            args: Prisma.ServiciosUtilizadosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiciosUtilizadosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          update: {
            args: Prisma.ServiciosUtilizadosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          deleteMany: {
            args: Prisma.ServiciosUtilizadosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiciosUtilizadosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiciosUtilizadosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiciosUtilizadosPayload>
          }
          aggregate: {
            args: Prisma.ServiciosUtilizadosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiciosUtilizados>
          }
          groupBy: {
            args: Prisma.ServiciosUtilizadosGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiciosUtilizadosGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiciosUtilizadosFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiciosUtilizadosAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiciosUtilizadosCountArgs<ExtArgs>
            result: $Utils.Optional<ServiciosUtilizadosCountAggregateOutputType> | number
          }
        }
      }
      confirmacionPago: {
        payload: Prisma.$confirmacionPagoPayload<ExtArgs>
        fields: Prisma.confirmacionPagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.confirmacionPagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.confirmacionPagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          findFirst: {
            args: Prisma.confirmacionPagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.confirmacionPagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          findMany: {
            args: Prisma.confirmacionPagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>[]
          }
          create: {
            args: Prisma.confirmacionPagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          createMany: {
            args: Prisma.confirmacionPagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.confirmacionPagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          update: {
            args: Prisma.confirmacionPagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          deleteMany: {
            args: Prisma.confirmacionPagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.confirmacionPagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.confirmacionPagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confirmacionPagoPayload>
          }
          aggregate: {
            args: Prisma.ConfirmacionPagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfirmacionPago>
          }
          groupBy: {
            args: Prisma.confirmacionPagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfirmacionPagoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.confirmacionPagoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.confirmacionPagoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.confirmacionPagoCountArgs<ExtArgs>
            result: $Utils.Optional<ConfirmacionPagoCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TaskFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TaskAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MallaCountOutputType
   */

  export type MallaCountOutputType = {
    CursosMalla: number
  }

  export type MallaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CursosMalla?: boolean | MallaCountOutputTypeCountCursosMallaArgs
  }

  // Custom InputTypes
  /**
   * MallaCountOutputType without action
   */
  export type MallaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MallaCountOutputType
     */
    select?: MallaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MallaCountOutputType without action
   */
  export type MallaCountOutputTypeCountCursosMallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursosMallaWhereInput
  }


  /**
   * Count Type CursosMallaCountOutputType
   */

  export type CursosMallaCountOutputType = {
    cursos: number
  }

  export type CursosMallaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursos?: boolean | CursosMallaCountOutputTypeCountCursosArgs
  }

  // Custom InputTypes
  /**
   * CursosMallaCountOutputType without action
   */
  export type CursosMallaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMallaCountOutputType
     */
    select?: CursosMallaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursosMallaCountOutputType without action
   */
  export type CursosMallaCountOutputTypeCountCursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
  }


  /**
   * Count Type CursoCountOutputType
   */

  export type CursoCountOutputType = {
    CursoMatriculado: number
  }

  export type CursoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CursoMatriculado?: boolean | CursoCountOutputTypeCountCursoMatriculadoArgs
  }

  // Custom InputTypes
  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoCountOutputType
     */
    select?: CursoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursoCountOutputType without action
   */
  export type CursoCountOutputTypeCountCursoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoMatriculadoWhereInput
  }


  /**
   * Count Type CursoMatriculadoCountOutputType
   */

  export type CursoMatriculadoCountOutputType = {
    notas: number
  }

  export type CursoMatriculadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notas?: boolean | CursoMatriculadoCountOutputTypeCountNotasArgs
  }

  // Custom InputTypes
  /**
   * CursoMatriculadoCountOutputType without action
   */
  export type CursoMatriculadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculadoCountOutputType
     */
    select?: CursoMatriculadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CursoMatriculadoCountOutputType without action
   */
  export type CursoMatriculadoCountOutputTypeCountNotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaWhereInput
  }


  /**
   * Count Type ServiciosCountOutputType
   */

  export type ServiciosCountOutputType = {
    ServiciosUtilizados: number
  }

  export type ServiciosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServiciosUtilizados?: boolean | ServiciosCountOutputTypeCountServiciosUtilizadosArgs
  }

  // Custom InputTypes
  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosCountOutputType
     */
    select?: ServiciosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiciosCountOutputType without action
   */
  export type ServiciosCountOutputTypeCountServiciosUtilizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiciosUtilizadosWhereInput
  }


  /**
   * Count Type TramitesCountOutputType
   */

  export type TramitesCountOutputType = {
    TramitesRealizados: number
  }

  export type TramitesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TramitesRealizados?: boolean | TramitesCountOutputTypeCountTramitesRealizadosArgs
  }

  // Custom InputTypes
  /**
   * TramitesCountOutputType without action
   */
  export type TramitesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesCountOutputType
     */
    select?: TramitesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TramitesCountOutputType without action
   */
  export type TramitesCountOutputTypeCountTramitesRealizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TramitesRealizadosWhereInput
  }


  /**
   * Count Type PeriodoMatriculadoCountOutputType
   */

  export type PeriodoMatriculadoCountOutputType = {
    Pagos: number
    cursosMatriculados: number
  }

  export type PeriodoMatriculadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pagos?: boolean | PeriodoMatriculadoCountOutputTypeCountPagosArgs
    cursosMatriculados?: boolean | PeriodoMatriculadoCountOutputTypeCountCursosMatriculadosArgs
  }

  // Custom InputTypes
  /**
   * PeriodoMatriculadoCountOutputType without action
   */
  export type PeriodoMatriculadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculadoCountOutputType
     */
    select?: PeriodoMatriculadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeriodoMatriculadoCountOutputType without action
   */
  export type PeriodoMatriculadoCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagosWhereInput
  }

  /**
   * PeriodoMatriculadoCountOutputType without action
   */
  export type PeriodoMatriculadoCountOutputTypeCountCursosMatriculadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoMatriculadoWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    TramitesRealizados: number
    ServiciosUtilizados: number
    Pagos: number
    PeriodoMatriculado: number
    accounts: number
    sessions: number
    events: number
    tasks: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TramitesRealizados?: boolean | UsuarioCountOutputTypeCountTramitesRealizadosArgs
    ServiciosUtilizados?: boolean | UsuarioCountOutputTypeCountServiciosUtilizadosArgs
    Pagos?: boolean | UsuarioCountOutputTypeCountPagosArgs
    PeriodoMatriculado?: boolean | UsuarioCountOutputTypeCountPeriodoMatriculadoArgs
    accounts?: boolean | UsuarioCountOutputTypeCountAccountsArgs
    sessions?: boolean | UsuarioCountOutputTypeCountSessionsArgs
    events?: boolean | UsuarioCountOutputTypeCountEventsArgs
    tasks?: boolean | UsuarioCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTramitesRealizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TramitesRealizadosWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountServiciosUtilizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiciosUtilizadosWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagosWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPeriodoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodoMatriculadoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Malla
   */

  export type AggregateMalla = {
    _count: MallaCountAggregateOutputType | null
    _avg: MallaAvgAggregateOutputType | null
    _sum: MallaSumAggregateOutputType | null
    _min: MallaMinAggregateOutputType | null
    _max: MallaMaxAggregateOutputType | null
  }

  export type MallaAvgAggregateOutputType = {
    year: number | null
  }

  export type MallaSumAggregateOutputType = {
    year: number | null
  }

  export type MallaMinAggregateOutputType = {
    id: string | null
    cod: string | null
    carrera: string | null
    year: number | null
  }

  export type MallaMaxAggregateOutputType = {
    id: string | null
    cod: string | null
    carrera: string | null
    year: number | null
  }

  export type MallaCountAggregateOutputType = {
    id: number
    cod: number
    carrera: number
    year: number
    _all: number
  }


  export type MallaAvgAggregateInputType = {
    year?: true
  }

  export type MallaSumAggregateInputType = {
    year?: true
  }

  export type MallaMinAggregateInputType = {
    id?: true
    cod?: true
    carrera?: true
    year?: true
  }

  export type MallaMaxAggregateInputType = {
    id?: true
    cod?: true
    carrera?: true
    year?: true
  }

  export type MallaCountAggregateInputType = {
    id?: true
    cod?: true
    carrera?: true
    year?: true
    _all?: true
  }

  export type MallaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Malla to aggregate.
     */
    where?: MallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mallas to fetch.
     */
    orderBy?: MallaOrderByWithRelationInput | MallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mallas
    **/
    _count?: true | MallaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MallaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MallaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MallaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MallaMaxAggregateInputType
  }

  export type GetMallaAggregateType<T extends MallaAggregateArgs> = {
        [P in keyof T & keyof AggregateMalla]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMalla[P]>
      : GetScalarType<T[P], AggregateMalla[P]>
  }




  export type MallaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MallaWhereInput
    orderBy?: MallaOrderByWithAggregationInput | MallaOrderByWithAggregationInput[]
    by: MallaScalarFieldEnum[] | MallaScalarFieldEnum
    having?: MallaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MallaCountAggregateInputType | true
    _avg?: MallaAvgAggregateInputType
    _sum?: MallaSumAggregateInputType
    _min?: MallaMinAggregateInputType
    _max?: MallaMaxAggregateInputType
  }

  export type MallaGroupByOutputType = {
    id: string
    cod: string
    carrera: string
    year: number
    _count: MallaCountAggregateOutputType | null
    _avg: MallaAvgAggregateOutputType | null
    _sum: MallaSumAggregateOutputType | null
    _min: MallaMinAggregateOutputType | null
    _max: MallaMaxAggregateOutputType | null
  }

  type GetMallaGroupByPayload<T extends MallaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MallaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MallaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MallaGroupByOutputType[P]>
            : GetScalarType<T[P], MallaGroupByOutputType[P]>
        }
      >
    >


  export type MallaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cod?: boolean
    carrera?: boolean
    year?: boolean
    CursosMalla?: boolean | Malla$CursosMallaArgs<ExtArgs>
    _count?: boolean | MallaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["malla"]>


  export type MallaSelectScalar = {
    id?: boolean
    cod?: boolean
    carrera?: boolean
    year?: boolean
  }

  export type MallaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CursosMalla?: boolean | Malla$CursosMallaArgs<ExtArgs>
    _count?: boolean | MallaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MallaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Malla"
    objects: {
      CursosMalla: Prisma.$CursosMallaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cod: string
      carrera: string
      year: number
    }, ExtArgs["result"]["malla"]>
    composites: {}
  }

  type MallaGetPayload<S extends boolean | null | undefined | MallaDefaultArgs> = $Result.GetResult<Prisma.$MallaPayload, S>

  type MallaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MallaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MallaCountAggregateInputType | true
    }

  export interface MallaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Malla'], meta: { name: 'Malla' } }
    /**
     * Find zero or one Malla that matches the filter.
     * @param {MallaFindUniqueArgs} args - Arguments to find a Malla
     * @example
     * // Get one Malla
     * const malla = await prisma.malla.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MallaFindUniqueArgs>(args: SelectSubset<T, MallaFindUniqueArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Malla that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MallaFindUniqueOrThrowArgs} args - Arguments to find a Malla
     * @example
     * // Get one Malla
     * const malla = await prisma.malla.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MallaFindUniqueOrThrowArgs>(args: SelectSubset<T, MallaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Malla that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaFindFirstArgs} args - Arguments to find a Malla
     * @example
     * // Get one Malla
     * const malla = await prisma.malla.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MallaFindFirstArgs>(args?: SelectSubset<T, MallaFindFirstArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Malla that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaFindFirstOrThrowArgs} args - Arguments to find a Malla
     * @example
     * // Get one Malla
     * const malla = await prisma.malla.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MallaFindFirstOrThrowArgs>(args?: SelectSubset<T, MallaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mallas
     * const mallas = await prisma.malla.findMany()
     * 
     * // Get first 10 Mallas
     * const mallas = await prisma.malla.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mallaWithIdOnly = await prisma.malla.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MallaFindManyArgs>(args?: SelectSubset<T, MallaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Malla.
     * @param {MallaCreateArgs} args - Arguments to create a Malla.
     * @example
     * // Create one Malla
     * const Malla = await prisma.malla.create({
     *   data: {
     *     // ... data to create a Malla
     *   }
     * })
     * 
     */
    create<T extends MallaCreateArgs>(args: SelectSubset<T, MallaCreateArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mallas.
     * @param {MallaCreateManyArgs} args - Arguments to create many Mallas.
     * @example
     * // Create many Mallas
     * const malla = await prisma.malla.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MallaCreateManyArgs>(args?: SelectSubset<T, MallaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Malla.
     * @param {MallaDeleteArgs} args - Arguments to delete one Malla.
     * @example
     * // Delete one Malla
     * const Malla = await prisma.malla.delete({
     *   where: {
     *     // ... filter to delete one Malla
     *   }
     * })
     * 
     */
    delete<T extends MallaDeleteArgs>(args: SelectSubset<T, MallaDeleteArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Malla.
     * @param {MallaUpdateArgs} args - Arguments to update one Malla.
     * @example
     * // Update one Malla
     * const malla = await prisma.malla.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MallaUpdateArgs>(args: SelectSubset<T, MallaUpdateArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mallas.
     * @param {MallaDeleteManyArgs} args - Arguments to filter Mallas to delete.
     * @example
     * // Delete a few Mallas
     * const { count } = await prisma.malla.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MallaDeleteManyArgs>(args?: SelectSubset<T, MallaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mallas
     * const malla = await prisma.malla.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MallaUpdateManyArgs>(args: SelectSubset<T, MallaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Malla.
     * @param {MallaUpsertArgs} args - Arguments to update or create a Malla.
     * @example
     * // Update or create a Malla
     * const malla = await prisma.malla.upsert({
     *   create: {
     *     // ... data to create a Malla
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Malla we want to update
     *   }
     * })
     */
    upsert<T extends MallaUpsertArgs>(args: SelectSubset<T, MallaUpsertArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Mallas that matches the filter.
     * @param {MallaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const malla = await prisma.malla.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: MallaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Malla.
     * @param {MallaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const malla = await prisma.malla.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MallaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Mallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaCountArgs} args - Arguments to filter Mallas to count.
     * @example
     * // Count the number of Mallas
     * const count = await prisma.malla.count({
     *   where: {
     *     // ... the filter for the Mallas we want to count
     *   }
     * })
    **/
    count<T extends MallaCountArgs>(
      args?: Subset<T, MallaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MallaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Malla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MallaAggregateArgs>(args: Subset<T, MallaAggregateArgs>): Prisma.PrismaPromise<GetMallaAggregateType<T>>

    /**
     * Group by Malla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MallaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MallaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MallaGroupByArgs['orderBy'] }
        : { orderBy?: MallaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MallaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMallaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Malla model
   */
  readonly fields: MallaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Malla.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MallaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CursosMalla<T extends Malla$CursosMallaArgs<ExtArgs> = {}>(args?: Subset<T, Malla$CursosMallaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Malla model
   */ 
  interface MallaFieldRefs {
    readonly id: FieldRef<"Malla", 'String'>
    readonly cod: FieldRef<"Malla", 'String'>
    readonly carrera: FieldRef<"Malla", 'String'>
    readonly year: FieldRef<"Malla", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Malla findUnique
   */
  export type MallaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter, which Malla to fetch.
     */
    where: MallaWhereUniqueInput
  }

  /**
   * Malla findUniqueOrThrow
   */
  export type MallaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter, which Malla to fetch.
     */
    where: MallaWhereUniqueInput
  }

  /**
   * Malla findFirst
   */
  export type MallaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter, which Malla to fetch.
     */
    where?: MallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mallas to fetch.
     */
    orderBy?: MallaOrderByWithRelationInput | MallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mallas.
     */
    cursor?: MallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mallas.
     */
    distinct?: MallaScalarFieldEnum | MallaScalarFieldEnum[]
  }

  /**
   * Malla findFirstOrThrow
   */
  export type MallaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter, which Malla to fetch.
     */
    where?: MallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mallas to fetch.
     */
    orderBy?: MallaOrderByWithRelationInput | MallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mallas.
     */
    cursor?: MallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mallas.
     */
    distinct?: MallaScalarFieldEnum | MallaScalarFieldEnum[]
  }

  /**
   * Malla findMany
   */
  export type MallaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter, which Mallas to fetch.
     */
    where?: MallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mallas to fetch.
     */
    orderBy?: MallaOrderByWithRelationInput | MallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mallas.
     */
    cursor?: MallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mallas.
     */
    skip?: number
    distinct?: MallaScalarFieldEnum | MallaScalarFieldEnum[]
  }

  /**
   * Malla create
   */
  export type MallaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * The data needed to create a Malla.
     */
    data: XOR<MallaCreateInput, MallaUncheckedCreateInput>
  }

  /**
   * Malla createMany
   */
  export type MallaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mallas.
     */
    data: MallaCreateManyInput | MallaCreateManyInput[]
  }

  /**
   * Malla update
   */
  export type MallaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * The data needed to update a Malla.
     */
    data: XOR<MallaUpdateInput, MallaUncheckedUpdateInput>
    /**
     * Choose, which Malla to update.
     */
    where: MallaWhereUniqueInput
  }

  /**
   * Malla updateMany
   */
  export type MallaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mallas.
     */
    data: XOR<MallaUpdateManyMutationInput, MallaUncheckedUpdateManyInput>
    /**
     * Filter which Mallas to update
     */
    where?: MallaWhereInput
  }

  /**
   * Malla upsert
   */
  export type MallaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * The filter to search for the Malla to update in case it exists.
     */
    where: MallaWhereUniqueInput
    /**
     * In case the Malla found by the `where` argument doesn't exist, create a new Malla with this data.
     */
    create: XOR<MallaCreateInput, MallaUncheckedCreateInput>
    /**
     * In case the Malla was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MallaUpdateInput, MallaUncheckedUpdateInput>
  }

  /**
   * Malla delete
   */
  export type MallaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
    /**
     * Filter which Malla to delete.
     */
    where: MallaWhereUniqueInput
  }

  /**
   * Malla deleteMany
   */
  export type MallaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mallas to delete
     */
    where?: MallaWhereInput
  }

  /**
   * Malla findRaw
   */
  export type MallaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Malla aggregateRaw
   */
  export type MallaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Malla.CursosMalla
   */
  export type Malla$CursosMallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    where?: CursosMallaWhereInput
    orderBy?: CursosMallaOrderByWithRelationInput | CursosMallaOrderByWithRelationInput[]
    cursor?: CursosMallaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursosMallaScalarFieldEnum | CursosMallaScalarFieldEnum[]
  }

  /**
   * Malla without action
   */
  export type MallaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Malla
     */
    select?: MallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MallaInclude<ExtArgs> | null
  }


  /**
   * Model CursosMalla
   */

  export type AggregateCursosMalla = {
    _count: CursosMallaCountAggregateOutputType | null
    _min: CursosMallaMinAggregateOutputType | null
    _max: CursosMallaMaxAggregateOutputType | null
  }

  export type CursosMallaMinAggregateOutputType = {
    id: string | null
    idMalla: string | null
  }

  export type CursosMallaMaxAggregateOutputType = {
    id: string | null
    idMalla: string | null
  }

  export type CursosMallaCountAggregateOutputType = {
    id: number
    idMalla: number
    _all: number
  }


  export type CursosMallaMinAggregateInputType = {
    id?: true
    idMalla?: true
  }

  export type CursosMallaMaxAggregateInputType = {
    id?: true
    idMalla?: true
  }

  export type CursosMallaCountAggregateInputType = {
    id?: true
    idMalla?: true
    _all?: true
  }

  export type CursosMallaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursosMalla to aggregate.
     */
    where?: CursosMallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosMallas to fetch.
     */
    orderBy?: CursosMallaOrderByWithRelationInput | CursosMallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursosMallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosMallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosMallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CursosMallas
    **/
    _count?: true | CursosMallaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursosMallaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursosMallaMaxAggregateInputType
  }

  export type GetCursosMallaAggregateType<T extends CursosMallaAggregateArgs> = {
        [P in keyof T & keyof AggregateCursosMalla]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursosMalla[P]>
      : GetScalarType<T[P], AggregateCursosMalla[P]>
  }




  export type CursosMallaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursosMallaWhereInput
    orderBy?: CursosMallaOrderByWithAggregationInput | CursosMallaOrderByWithAggregationInput[]
    by: CursosMallaScalarFieldEnum[] | CursosMallaScalarFieldEnum
    having?: CursosMallaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursosMallaCountAggregateInputType | true
    _min?: CursosMallaMinAggregateInputType
    _max?: CursosMallaMaxAggregateInputType
  }

  export type CursosMallaGroupByOutputType = {
    id: string
    idMalla: string
    _count: CursosMallaCountAggregateOutputType | null
    _min: CursosMallaMinAggregateOutputType | null
    _max: CursosMallaMaxAggregateOutputType | null
  }

  type GetCursosMallaGroupByPayload<T extends CursosMallaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursosMallaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursosMallaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursosMallaGroupByOutputType[P]>
            : GetScalarType<T[P], CursosMallaGroupByOutputType[P]>
        }
      >
    >


  export type CursosMallaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idMalla?: boolean
    Malla?: boolean | MallaDefaultArgs<ExtArgs>
    cursos?: boolean | CursosMalla$cursosArgs<ExtArgs>
    _count?: boolean | CursosMallaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursosMalla"]>


  export type CursosMallaSelectScalar = {
    id?: boolean
    idMalla?: boolean
  }

  export type CursosMallaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Malla?: boolean | MallaDefaultArgs<ExtArgs>
    cursos?: boolean | CursosMalla$cursosArgs<ExtArgs>
    _count?: boolean | CursosMallaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CursosMallaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CursosMalla"
    objects: {
      Malla: Prisma.$MallaPayload<ExtArgs>
      cursos: Prisma.$CursoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idMalla: string
    }, ExtArgs["result"]["cursosMalla"]>
    composites: {}
  }

  type CursosMallaGetPayload<S extends boolean | null | undefined | CursosMallaDefaultArgs> = $Result.GetResult<Prisma.$CursosMallaPayload, S>

  type CursosMallaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CursosMallaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CursosMallaCountAggregateInputType | true
    }

  export interface CursosMallaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CursosMalla'], meta: { name: 'CursosMalla' } }
    /**
     * Find zero or one CursosMalla that matches the filter.
     * @param {CursosMallaFindUniqueArgs} args - Arguments to find a CursosMalla
     * @example
     * // Get one CursosMalla
     * const cursosMalla = await prisma.cursosMalla.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursosMallaFindUniqueArgs>(args: SelectSubset<T, CursosMallaFindUniqueArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CursosMalla that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CursosMallaFindUniqueOrThrowArgs} args - Arguments to find a CursosMalla
     * @example
     * // Get one CursosMalla
     * const cursosMalla = await prisma.cursosMalla.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursosMallaFindUniqueOrThrowArgs>(args: SelectSubset<T, CursosMallaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CursosMalla that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaFindFirstArgs} args - Arguments to find a CursosMalla
     * @example
     * // Get one CursosMalla
     * const cursosMalla = await prisma.cursosMalla.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursosMallaFindFirstArgs>(args?: SelectSubset<T, CursosMallaFindFirstArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CursosMalla that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaFindFirstOrThrowArgs} args - Arguments to find a CursosMalla
     * @example
     * // Get one CursosMalla
     * const cursosMalla = await prisma.cursosMalla.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursosMallaFindFirstOrThrowArgs>(args?: SelectSubset<T, CursosMallaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CursosMallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CursosMallas
     * const cursosMallas = await prisma.cursosMalla.findMany()
     * 
     * // Get first 10 CursosMallas
     * const cursosMallas = await prisma.cursosMalla.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursosMallaWithIdOnly = await prisma.cursosMalla.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursosMallaFindManyArgs>(args?: SelectSubset<T, CursosMallaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CursosMalla.
     * @param {CursosMallaCreateArgs} args - Arguments to create a CursosMalla.
     * @example
     * // Create one CursosMalla
     * const CursosMalla = await prisma.cursosMalla.create({
     *   data: {
     *     // ... data to create a CursosMalla
     *   }
     * })
     * 
     */
    create<T extends CursosMallaCreateArgs>(args: SelectSubset<T, CursosMallaCreateArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CursosMallas.
     * @param {CursosMallaCreateManyArgs} args - Arguments to create many CursosMallas.
     * @example
     * // Create many CursosMallas
     * const cursosMalla = await prisma.cursosMalla.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursosMallaCreateManyArgs>(args?: SelectSubset<T, CursosMallaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CursosMalla.
     * @param {CursosMallaDeleteArgs} args - Arguments to delete one CursosMalla.
     * @example
     * // Delete one CursosMalla
     * const CursosMalla = await prisma.cursosMalla.delete({
     *   where: {
     *     // ... filter to delete one CursosMalla
     *   }
     * })
     * 
     */
    delete<T extends CursosMallaDeleteArgs>(args: SelectSubset<T, CursosMallaDeleteArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CursosMalla.
     * @param {CursosMallaUpdateArgs} args - Arguments to update one CursosMalla.
     * @example
     * // Update one CursosMalla
     * const cursosMalla = await prisma.cursosMalla.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursosMallaUpdateArgs>(args: SelectSubset<T, CursosMallaUpdateArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CursosMallas.
     * @param {CursosMallaDeleteManyArgs} args - Arguments to filter CursosMallas to delete.
     * @example
     * // Delete a few CursosMallas
     * const { count } = await prisma.cursosMalla.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursosMallaDeleteManyArgs>(args?: SelectSubset<T, CursosMallaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CursosMallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CursosMallas
     * const cursosMalla = await prisma.cursosMalla.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursosMallaUpdateManyArgs>(args: SelectSubset<T, CursosMallaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CursosMalla.
     * @param {CursosMallaUpsertArgs} args - Arguments to update or create a CursosMalla.
     * @example
     * // Update or create a CursosMalla
     * const cursosMalla = await prisma.cursosMalla.upsert({
     *   create: {
     *     // ... data to create a CursosMalla
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CursosMalla we want to update
     *   }
     * })
     */
    upsert<T extends CursosMallaUpsertArgs>(args: SelectSubset<T, CursosMallaUpsertArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more CursosMallas that matches the filter.
     * @param {CursosMallaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cursosMalla = await prisma.cursosMalla.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CursosMallaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CursosMalla.
     * @param {CursosMallaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cursosMalla = await prisma.cursosMalla.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CursosMallaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CursosMallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaCountArgs} args - Arguments to filter CursosMallas to count.
     * @example
     * // Count the number of CursosMallas
     * const count = await prisma.cursosMalla.count({
     *   where: {
     *     // ... the filter for the CursosMallas we want to count
     *   }
     * })
    **/
    count<T extends CursosMallaCountArgs>(
      args?: Subset<T, CursosMallaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursosMallaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CursosMalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursosMallaAggregateArgs>(args: Subset<T, CursosMallaAggregateArgs>): Prisma.PrismaPromise<GetCursosMallaAggregateType<T>>

    /**
     * Group by CursosMalla.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursosMallaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursosMallaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursosMallaGroupByArgs['orderBy'] }
        : { orderBy?: CursosMallaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursosMallaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursosMallaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CursosMalla model
   */
  readonly fields: CursosMallaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CursosMalla.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursosMallaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Malla<T extends MallaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MallaDefaultArgs<ExtArgs>>): Prisma__MallaClient<$Result.GetResult<Prisma.$MallaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cursos<T extends CursosMalla$cursosArgs<ExtArgs> = {}>(args?: Subset<T, CursosMalla$cursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CursosMalla model
   */ 
  interface CursosMallaFieldRefs {
    readonly id: FieldRef<"CursosMalla", 'String'>
    readonly idMalla: FieldRef<"CursosMalla", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CursosMalla findUnique
   */
  export type CursosMallaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter, which CursosMalla to fetch.
     */
    where: CursosMallaWhereUniqueInput
  }

  /**
   * CursosMalla findUniqueOrThrow
   */
  export type CursosMallaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter, which CursosMalla to fetch.
     */
    where: CursosMallaWhereUniqueInput
  }

  /**
   * CursosMalla findFirst
   */
  export type CursosMallaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter, which CursosMalla to fetch.
     */
    where?: CursosMallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosMallas to fetch.
     */
    orderBy?: CursosMallaOrderByWithRelationInput | CursosMallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursosMallas.
     */
    cursor?: CursosMallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosMallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosMallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursosMallas.
     */
    distinct?: CursosMallaScalarFieldEnum | CursosMallaScalarFieldEnum[]
  }

  /**
   * CursosMalla findFirstOrThrow
   */
  export type CursosMallaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter, which CursosMalla to fetch.
     */
    where?: CursosMallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosMallas to fetch.
     */
    orderBy?: CursosMallaOrderByWithRelationInput | CursosMallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursosMallas.
     */
    cursor?: CursosMallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosMallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosMallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursosMallas.
     */
    distinct?: CursosMallaScalarFieldEnum | CursosMallaScalarFieldEnum[]
  }

  /**
   * CursosMalla findMany
   */
  export type CursosMallaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter, which CursosMallas to fetch.
     */
    where?: CursosMallaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursosMallas to fetch.
     */
    orderBy?: CursosMallaOrderByWithRelationInput | CursosMallaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CursosMallas.
     */
    cursor?: CursosMallaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursosMallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursosMallas.
     */
    skip?: number
    distinct?: CursosMallaScalarFieldEnum | CursosMallaScalarFieldEnum[]
  }

  /**
   * CursosMalla create
   */
  export type CursosMallaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * The data needed to create a CursosMalla.
     */
    data: XOR<CursosMallaCreateInput, CursosMallaUncheckedCreateInput>
  }

  /**
   * CursosMalla createMany
   */
  export type CursosMallaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CursosMallas.
     */
    data: CursosMallaCreateManyInput | CursosMallaCreateManyInput[]
  }

  /**
   * CursosMalla update
   */
  export type CursosMallaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * The data needed to update a CursosMalla.
     */
    data: XOR<CursosMallaUpdateInput, CursosMallaUncheckedUpdateInput>
    /**
     * Choose, which CursosMalla to update.
     */
    where: CursosMallaWhereUniqueInput
  }

  /**
   * CursosMalla updateMany
   */
  export type CursosMallaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CursosMallas.
     */
    data: XOR<CursosMallaUpdateManyMutationInput, CursosMallaUncheckedUpdateManyInput>
    /**
     * Filter which CursosMallas to update
     */
    where?: CursosMallaWhereInput
  }

  /**
   * CursosMalla upsert
   */
  export type CursosMallaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * The filter to search for the CursosMalla to update in case it exists.
     */
    where: CursosMallaWhereUniqueInput
    /**
     * In case the CursosMalla found by the `where` argument doesn't exist, create a new CursosMalla with this data.
     */
    create: XOR<CursosMallaCreateInput, CursosMallaUncheckedCreateInput>
    /**
     * In case the CursosMalla was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursosMallaUpdateInput, CursosMallaUncheckedUpdateInput>
  }

  /**
   * CursosMalla delete
   */
  export type CursosMallaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    /**
     * Filter which CursosMalla to delete.
     */
    where: CursosMallaWhereUniqueInput
  }

  /**
   * CursosMalla deleteMany
   */
  export type CursosMallaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursosMallas to delete
     */
    where?: CursosMallaWhereInput
  }

  /**
   * CursosMalla findRaw
   */
  export type CursosMallaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CursosMalla aggregateRaw
   */
  export type CursosMallaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CursosMalla.cursos
   */
  export type CursosMalla$cursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    cursor?: CursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * CursosMalla without action
   */
  export type CursosMallaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
  }


  /**
   * Model Curso
   */

  export type AggregateCurso = {
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  export type CursoAvgAggregateOutputType = {
    creditos: number | null
    horas: number | null
    semestre: number | null
  }

  export type CursoSumAggregateOutputType = {
    creditos: number | null
    horas: number | null
    semestre: number | null
  }

  export type CursoMinAggregateOutputType = {
    id: string | null
    cod: string | null
    nombre: string | null
    creditos: number | null
    horas: number | null
    semestre: number | null
    cursosMallaId: string | null
  }

  export type CursoMaxAggregateOutputType = {
    id: string | null
    cod: string | null
    nombre: string | null
    creditos: number | null
    horas: number | null
    semestre: number | null
    cursosMallaId: string | null
  }

  export type CursoCountAggregateOutputType = {
    id: number
    cod: number
    nombre: number
    creditos: number
    horas: number
    semestre: number
    cursosMallaId: number
    _all: number
  }


  export type CursoAvgAggregateInputType = {
    creditos?: true
    horas?: true
    semestre?: true
  }

  export type CursoSumAggregateInputType = {
    creditos?: true
    horas?: true
    semestre?: true
  }

  export type CursoMinAggregateInputType = {
    id?: true
    cod?: true
    nombre?: true
    creditos?: true
    horas?: true
    semestre?: true
    cursosMallaId?: true
  }

  export type CursoMaxAggregateInputType = {
    id?: true
    cod?: true
    nombre?: true
    creditos?: true
    horas?: true
    semestre?: true
    cursosMallaId?: true
  }

  export type CursoCountAggregateInputType = {
    id?: true
    cod?: true
    nombre?: true
    creditos?: true
    horas?: true
    semestre?: true
    cursosMallaId?: true
    _all?: true
  }

  export type CursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Curso to aggregate.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cursos
    **/
    _count?: true | CursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMaxAggregateInputType
  }

  export type GetCursoAggregateType<T extends CursoAggregateArgs> = {
        [P in keyof T & keyof AggregateCurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurso[P]>
      : GetScalarType<T[P], AggregateCurso[P]>
  }




  export type CursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoWhereInput
    orderBy?: CursoOrderByWithAggregationInput | CursoOrderByWithAggregationInput[]
    by: CursoScalarFieldEnum[] | CursoScalarFieldEnum
    having?: CursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoCountAggregateInputType | true
    _avg?: CursoAvgAggregateInputType
    _sum?: CursoSumAggregateInputType
    _min?: CursoMinAggregateInputType
    _max?: CursoMaxAggregateInputType
  }

  export type CursoGroupByOutputType = {
    id: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    cursosMallaId: string | null
    _count: CursoCountAggregateOutputType | null
    _avg: CursoAvgAggregateOutputType | null
    _sum: CursoSumAggregateOutputType | null
    _min: CursoMinAggregateOutputType | null
    _max: CursoMaxAggregateOutputType | null
  }

  type GetCursoGroupByPayload<T extends CursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoGroupByOutputType[P]>
        }
      >
    >


  export type CursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cod?: boolean
    nombre?: boolean
    creditos?: boolean
    horas?: boolean
    semestre?: boolean
    cursosMallaId?: boolean
    CursosMalla?: boolean | Curso$CursosMallaArgs<ExtArgs>
    CursoMatriculado?: boolean | Curso$CursoMatriculadoArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["curso"]>


  export type CursoSelectScalar = {
    id?: boolean
    cod?: boolean
    nombre?: boolean
    creditos?: boolean
    horas?: boolean
    semestre?: boolean
    cursosMallaId?: boolean
  }

  export type CursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CursosMalla?: boolean | Curso$CursosMallaArgs<ExtArgs>
    CursoMatriculado?: boolean | Curso$CursoMatriculadoArgs<ExtArgs>
    _count?: boolean | CursoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Curso"
    objects: {
      CursosMalla: Prisma.$CursosMallaPayload<ExtArgs> | null
      CursoMatriculado: Prisma.$CursoMatriculadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cod: string
      nombre: string
      creditos: number
      horas: number
      semestre: number
      cursosMallaId: string | null
    }, ExtArgs["result"]["curso"]>
    composites: {}
  }

  type CursoGetPayload<S extends boolean | null | undefined | CursoDefaultArgs> = $Result.GetResult<Prisma.$CursoPayload, S>

  type CursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CursoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CursoCountAggregateInputType | true
    }

  export interface CursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Curso'], meta: { name: 'Curso' } }
    /**
     * Find zero or one Curso that matches the filter.
     * @param {CursoFindUniqueArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoFindUniqueArgs>(args: SelectSubset<T, CursoFindUniqueArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Curso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CursoFindUniqueOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Curso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoFindFirstArgs>(args?: SelectSubset<T, CursoFindFirstArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Curso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindFirstOrThrowArgs} args - Arguments to find a Curso
     * @example
     * // Get one Curso
     * const curso = await prisma.curso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cursos
     * const cursos = await prisma.curso.findMany()
     * 
     * // Get first 10 Cursos
     * const cursos = await prisma.curso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoWithIdOnly = await prisma.curso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursoFindManyArgs>(args?: SelectSubset<T, CursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Curso.
     * @param {CursoCreateArgs} args - Arguments to create a Curso.
     * @example
     * // Create one Curso
     * const Curso = await prisma.curso.create({
     *   data: {
     *     // ... data to create a Curso
     *   }
     * })
     * 
     */
    create<T extends CursoCreateArgs>(args: SelectSubset<T, CursoCreateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cursos.
     * @param {CursoCreateManyArgs} args - Arguments to create many Cursos.
     * @example
     * // Create many Cursos
     * const curso = await prisma.curso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoCreateManyArgs>(args?: SelectSubset<T, CursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Curso.
     * @param {CursoDeleteArgs} args - Arguments to delete one Curso.
     * @example
     * // Delete one Curso
     * const Curso = await prisma.curso.delete({
     *   where: {
     *     // ... filter to delete one Curso
     *   }
     * })
     * 
     */
    delete<T extends CursoDeleteArgs>(args: SelectSubset<T, CursoDeleteArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Curso.
     * @param {CursoUpdateArgs} args - Arguments to update one Curso.
     * @example
     * // Update one Curso
     * const curso = await prisma.curso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoUpdateArgs>(args: SelectSubset<T, CursoUpdateArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cursos.
     * @param {CursoDeleteManyArgs} args - Arguments to filter Cursos to delete.
     * @example
     * // Delete a few Cursos
     * const { count } = await prisma.curso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoDeleteManyArgs>(args?: SelectSubset<T, CursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cursos
     * const curso = await prisma.curso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoUpdateManyArgs>(args: SelectSubset<T, CursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Curso.
     * @param {CursoUpsertArgs} args - Arguments to update or create a Curso.
     * @example
     * // Update or create a Curso
     * const curso = await prisma.curso.upsert({
     *   create: {
     *     // ... data to create a Curso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Curso we want to update
     *   }
     * })
     */
    upsert<T extends CursoUpsertArgs>(args: SelectSubset<T, CursoUpsertArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Cursos that matches the filter.
     * @param {CursoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const curso = await prisma.curso.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CursoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Curso.
     * @param {CursoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const curso = await prisma.curso.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CursoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoCountArgs} args - Arguments to filter Cursos to count.
     * @example
     * // Count the number of Cursos
     * const count = await prisma.curso.count({
     *   where: {
     *     // ... the filter for the Cursos we want to count
     *   }
     * })
    **/
    count<T extends CursoCountArgs>(
      args?: Subset<T, CursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoAggregateArgs>(args: Subset<T, CursoAggregateArgs>): Prisma.PrismaPromise<GetCursoAggregateType<T>>

    /**
     * Group by Curso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoGroupByArgs['orderBy'] }
        : { orderBy?: CursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Curso model
   */
  readonly fields: CursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Curso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CursosMalla<T extends Curso$CursosMallaArgs<ExtArgs> = {}>(args?: Subset<T, Curso$CursosMallaArgs<ExtArgs>>): Prisma__CursosMallaClient<$Result.GetResult<Prisma.$CursosMallaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    CursoMatriculado<T extends Curso$CursoMatriculadoArgs<ExtArgs> = {}>(args?: Subset<T, Curso$CursoMatriculadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Curso model
   */ 
  interface CursoFieldRefs {
    readonly id: FieldRef<"Curso", 'String'>
    readonly cod: FieldRef<"Curso", 'String'>
    readonly nombre: FieldRef<"Curso", 'String'>
    readonly creditos: FieldRef<"Curso", 'Int'>
    readonly horas: FieldRef<"Curso", 'Int'>
    readonly semestre: FieldRef<"Curso", 'Int'>
    readonly cursosMallaId: FieldRef<"Curso", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Curso findUnique
   */
  export type CursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findUniqueOrThrow
   */
  export type CursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso findFirst
   */
  export type CursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findFirstOrThrow
   */
  export type CursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Curso to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cursos.
     */
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso findMany
   */
  export type CursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter, which Cursos to fetch.
     */
    where?: CursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cursos to fetch.
     */
    orderBy?: CursoOrderByWithRelationInput | CursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cursos.
     */
    cursor?: CursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cursos.
     */
    skip?: number
    distinct?: CursoScalarFieldEnum | CursoScalarFieldEnum[]
  }

  /**
   * Curso create
   */
  export type CursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to create a Curso.
     */
    data: XOR<CursoCreateInput, CursoUncheckedCreateInput>
  }

  /**
   * Curso createMany
   */
  export type CursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cursos.
     */
    data: CursoCreateManyInput | CursoCreateManyInput[]
  }

  /**
   * Curso update
   */
  export type CursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The data needed to update a Curso.
     */
    data: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
    /**
     * Choose, which Curso to update.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso updateMany
   */
  export type CursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cursos.
     */
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyInput>
    /**
     * Filter which Cursos to update
     */
    where?: CursoWhereInput
  }

  /**
   * Curso upsert
   */
  export type CursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * The filter to search for the Curso to update in case it exists.
     */
    where: CursoWhereUniqueInput
    /**
     * In case the Curso found by the `where` argument doesn't exist, create a new Curso with this data.
     */
    create: XOR<CursoCreateInput, CursoUncheckedCreateInput>
    /**
     * In case the Curso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoUpdateInput, CursoUncheckedUpdateInput>
  }

  /**
   * Curso delete
   */
  export type CursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
    /**
     * Filter which Curso to delete.
     */
    where: CursoWhereUniqueInput
  }

  /**
   * Curso deleteMany
   */
  export type CursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cursos to delete
     */
    where?: CursoWhereInput
  }

  /**
   * Curso findRaw
   */
  export type CursoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Curso aggregateRaw
   */
  export type CursoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Curso.CursosMalla
   */
  export type Curso$CursosMallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursosMalla
     */
    select?: CursosMallaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursosMallaInclude<ExtArgs> | null
    where?: CursosMallaWhereInput
  }

  /**
   * Curso.CursoMatriculado
   */
  export type Curso$CursoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    where?: CursoMatriculadoWhereInput
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    cursor?: CursoMatriculadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoMatriculadoScalarFieldEnum | CursoMatriculadoScalarFieldEnum[]
  }

  /**
   * Curso without action
   */
  export type CursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Curso
     */
    select?: CursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoInclude<ExtArgs> | null
  }


  /**
   * Model CursoMatriculado
   */

  export type AggregateCursoMatriculado = {
    _count: CursoMatriculadoCountAggregateOutputType | null
    _avg: CursoMatriculadoAvgAggregateOutputType | null
    _sum: CursoMatriculadoSumAggregateOutputType | null
    _min: CursoMatriculadoMinAggregateOutputType | null
    _max: CursoMatriculadoMaxAggregateOutputType | null
  }

  export type CursoMatriculadoAvgAggregateOutputType = {
    averageGrade: number | null
    vez: number | null
    diasClase: number | null
  }

  export type CursoMatriculadoSumAggregateOutputType = {
    averageGrade: number | null
    vez: number | null
    diasClase: number[]
  }

  export type CursoMatriculadoMinAggregateOutputType = {
    id: string | null
    averageGrade: number | null
    salon: string | null
    profesor: string | null
    idCurso: string | null
    vez: number | null
    status: string | null
    periodoMatriculadoId: string | null
    horaInicio: Date | null
  }

  export type CursoMatriculadoMaxAggregateOutputType = {
    id: string | null
    averageGrade: number | null
    salon: string | null
    profesor: string | null
    idCurso: string | null
    vez: number | null
    status: string | null
    periodoMatriculadoId: string | null
    horaInicio: Date | null
  }

  export type CursoMatriculadoCountAggregateOutputType = {
    id: number
    averageGrade: number
    salon: number
    profesor: number
    idCurso: number
    vez: number
    status: number
    periodoMatriculadoId: number
    diasClase: number
    horaInicio: number
    _all: number
  }


  export type CursoMatriculadoAvgAggregateInputType = {
    averageGrade?: true
    vez?: true
    diasClase?: true
  }

  export type CursoMatriculadoSumAggregateInputType = {
    averageGrade?: true
    vez?: true
    diasClase?: true
  }

  export type CursoMatriculadoMinAggregateInputType = {
    id?: true
    averageGrade?: true
    salon?: true
    profesor?: true
    idCurso?: true
    vez?: true
    status?: true
    periodoMatriculadoId?: true
    horaInicio?: true
  }

  export type CursoMatriculadoMaxAggregateInputType = {
    id?: true
    averageGrade?: true
    salon?: true
    profesor?: true
    idCurso?: true
    vez?: true
    status?: true
    periodoMatriculadoId?: true
    horaInicio?: true
  }

  export type CursoMatriculadoCountAggregateInputType = {
    id?: true
    averageGrade?: true
    salon?: true
    profesor?: true
    idCurso?: true
    vez?: true
    status?: true
    periodoMatriculadoId?: true
    diasClase?: true
    horaInicio?: true
    _all?: true
  }

  export type CursoMatriculadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursoMatriculado to aggregate.
     */
    where?: CursoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoMatriculados to fetch.
     */
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CursoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CursoMatriculados
    **/
    _count?: true | CursoMatriculadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CursoMatriculadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CursoMatriculadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CursoMatriculadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CursoMatriculadoMaxAggregateInputType
  }

  export type GetCursoMatriculadoAggregateType<T extends CursoMatriculadoAggregateArgs> = {
        [P in keyof T & keyof AggregateCursoMatriculado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCursoMatriculado[P]>
      : GetScalarType<T[P], AggregateCursoMatriculado[P]>
  }




  export type CursoMatriculadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CursoMatriculadoWhereInput
    orderBy?: CursoMatriculadoOrderByWithAggregationInput | CursoMatriculadoOrderByWithAggregationInput[]
    by: CursoMatriculadoScalarFieldEnum[] | CursoMatriculadoScalarFieldEnum
    having?: CursoMatriculadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CursoMatriculadoCountAggregateInputType | true
    _avg?: CursoMatriculadoAvgAggregateInputType
    _sum?: CursoMatriculadoSumAggregateInputType
    _min?: CursoMatriculadoMinAggregateInputType
    _max?: CursoMatriculadoMaxAggregateInputType
  }

  export type CursoMatriculadoGroupByOutputType = {
    id: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    periodoMatriculadoId: string | null
    diasClase: number[]
    horaInicio: Date
    _count: CursoMatriculadoCountAggregateOutputType | null
    _avg: CursoMatriculadoAvgAggregateOutputType | null
    _sum: CursoMatriculadoSumAggregateOutputType | null
    _min: CursoMatriculadoMinAggregateOutputType | null
    _max: CursoMatriculadoMaxAggregateOutputType | null
  }

  type GetCursoMatriculadoGroupByPayload<T extends CursoMatriculadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CursoMatriculadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CursoMatriculadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CursoMatriculadoGroupByOutputType[P]>
            : GetScalarType<T[P], CursoMatriculadoGroupByOutputType[P]>
        }
      >
    >


  export type CursoMatriculadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    averageGrade?: boolean
    salon?: boolean
    profesor?: boolean
    idCurso?: boolean
    vez?: boolean
    status?: boolean
    periodoMatriculadoId?: boolean
    diasClase?: boolean
    horaInicio?: boolean
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    PeriodoMatriculado?: boolean | CursoMatriculado$PeriodoMatriculadoArgs<ExtArgs>
    notas?: boolean | CursoMatriculado$notasArgs<ExtArgs>
    _count?: boolean | CursoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cursoMatriculado"]>


  export type CursoMatriculadoSelectScalar = {
    id?: boolean
    averageGrade?: boolean
    salon?: boolean
    profesor?: boolean
    idCurso?: boolean
    vez?: boolean
    status?: boolean
    periodoMatriculadoId?: boolean
    diasClase?: boolean
    horaInicio?: boolean
  }

  export type CursoMatriculadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    curso?: boolean | CursoDefaultArgs<ExtArgs>
    PeriodoMatriculado?: boolean | CursoMatriculado$PeriodoMatriculadoArgs<ExtArgs>
    notas?: boolean | CursoMatriculado$notasArgs<ExtArgs>
    _count?: boolean | CursoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CursoMatriculadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CursoMatriculado"
    objects: {
      curso: Prisma.$CursoPayload<ExtArgs>
      PeriodoMatriculado: Prisma.$PeriodoMatriculadoPayload<ExtArgs> | null
      notas: Prisma.$NotaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      averageGrade: number
      salon: string
      profesor: string
      idCurso: string
      vez: number
      status: string
      periodoMatriculadoId: string | null
      diasClase: number[]
      horaInicio: Date
    }, ExtArgs["result"]["cursoMatriculado"]>
    composites: {}
  }

  type CursoMatriculadoGetPayload<S extends boolean | null | undefined | CursoMatriculadoDefaultArgs> = $Result.GetResult<Prisma.$CursoMatriculadoPayload, S>

  type CursoMatriculadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CursoMatriculadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CursoMatriculadoCountAggregateInputType | true
    }

  export interface CursoMatriculadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CursoMatriculado'], meta: { name: 'CursoMatriculado' } }
    /**
     * Find zero or one CursoMatriculado that matches the filter.
     * @param {CursoMatriculadoFindUniqueArgs} args - Arguments to find a CursoMatriculado
     * @example
     * // Get one CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CursoMatriculadoFindUniqueArgs>(args: SelectSubset<T, CursoMatriculadoFindUniqueArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CursoMatriculado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CursoMatriculadoFindUniqueOrThrowArgs} args - Arguments to find a CursoMatriculado
     * @example
     * // Get one CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CursoMatriculadoFindUniqueOrThrowArgs>(args: SelectSubset<T, CursoMatriculadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CursoMatriculado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoFindFirstArgs} args - Arguments to find a CursoMatriculado
     * @example
     * // Get one CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CursoMatriculadoFindFirstArgs>(args?: SelectSubset<T, CursoMatriculadoFindFirstArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CursoMatriculado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoFindFirstOrThrowArgs} args - Arguments to find a CursoMatriculado
     * @example
     * // Get one CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CursoMatriculadoFindFirstOrThrowArgs>(args?: SelectSubset<T, CursoMatriculadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CursoMatriculados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CursoMatriculados
     * const cursoMatriculados = await prisma.cursoMatriculado.findMany()
     * 
     * // Get first 10 CursoMatriculados
     * const cursoMatriculados = await prisma.cursoMatriculado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cursoMatriculadoWithIdOnly = await prisma.cursoMatriculado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CursoMatriculadoFindManyArgs>(args?: SelectSubset<T, CursoMatriculadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CursoMatriculado.
     * @param {CursoMatriculadoCreateArgs} args - Arguments to create a CursoMatriculado.
     * @example
     * // Create one CursoMatriculado
     * const CursoMatriculado = await prisma.cursoMatriculado.create({
     *   data: {
     *     // ... data to create a CursoMatriculado
     *   }
     * })
     * 
     */
    create<T extends CursoMatriculadoCreateArgs>(args: SelectSubset<T, CursoMatriculadoCreateArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CursoMatriculados.
     * @param {CursoMatriculadoCreateManyArgs} args - Arguments to create many CursoMatriculados.
     * @example
     * // Create many CursoMatriculados
     * const cursoMatriculado = await prisma.cursoMatriculado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CursoMatriculadoCreateManyArgs>(args?: SelectSubset<T, CursoMatriculadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CursoMatriculado.
     * @param {CursoMatriculadoDeleteArgs} args - Arguments to delete one CursoMatriculado.
     * @example
     * // Delete one CursoMatriculado
     * const CursoMatriculado = await prisma.cursoMatriculado.delete({
     *   where: {
     *     // ... filter to delete one CursoMatriculado
     *   }
     * })
     * 
     */
    delete<T extends CursoMatriculadoDeleteArgs>(args: SelectSubset<T, CursoMatriculadoDeleteArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CursoMatriculado.
     * @param {CursoMatriculadoUpdateArgs} args - Arguments to update one CursoMatriculado.
     * @example
     * // Update one CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CursoMatriculadoUpdateArgs>(args: SelectSubset<T, CursoMatriculadoUpdateArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CursoMatriculados.
     * @param {CursoMatriculadoDeleteManyArgs} args - Arguments to filter CursoMatriculados to delete.
     * @example
     * // Delete a few CursoMatriculados
     * const { count } = await prisma.cursoMatriculado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CursoMatriculadoDeleteManyArgs>(args?: SelectSubset<T, CursoMatriculadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CursoMatriculados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CursoMatriculados
     * const cursoMatriculado = await prisma.cursoMatriculado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CursoMatriculadoUpdateManyArgs>(args: SelectSubset<T, CursoMatriculadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CursoMatriculado.
     * @param {CursoMatriculadoUpsertArgs} args - Arguments to update or create a CursoMatriculado.
     * @example
     * // Update or create a CursoMatriculado
     * const cursoMatriculado = await prisma.cursoMatriculado.upsert({
     *   create: {
     *     // ... data to create a CursoMatriculado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CursoMatriculado we want to update
     *   }
     * })
     */
    upsert<T extends CursoMatriculadoUpsertArgs>(args: SelectSubset<T, CursoMatriculadoUpsertArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more CursoMatriculados that matches the filter.
     * @param {CursoMatriculadoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cursoMatriculado = await prisma.cursoMatriculado.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: CursoMatriculadoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CursoMatriculado.
     * @param {CursoMatriculadoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cursoMatriculado = await prisma.cursoMatriculado.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CursoMatriculadoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CursoMatriculados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoCountArgs} args - Arguments to filter CursoMatriculados to count.
     * @example
     * // Count the number of CursoMatriculados
     * const count = await prisma.cursoMatriculado.count({
     *   where: {
     *     // ... the filter for the CursoMatriculados we want to count
     *   }
     * })
    **/
    count<T extends CursoMatriculadoCountArgs>(
      args?: Subset<T, CursoMatriculadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CursoMatriculadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CursoMatriculado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CursoMatriculadoAggregateArgs>(args: Subset<T, CursoMatriculadoAggregateArgs>): Prisma.PrismaPromise<GetCursoMatriculadoAggregateType<T>>

    /**
     * Group by CursoMatriculado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CursoMatriculadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CursoMatriculadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CursoMatriculadoGroupByArgs['orderBy'] }
        : { orderBy?: CursoMatriculadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CursoMatriculadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCursoMatriculadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CursoMatriculado model
   */
  readonly fields: CursoMatriculadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CursoMatriculado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CursoMatriculadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    curso<T extends CursoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoDefaultArgs<ExtArgs>>): Prisma__CursoClient<$Result.GetResult<Prisma.$CursoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PeriodoMatriculado<T extends CursoMatriculado$PeriodoMatriculadoArgs<ExtArgs> = {}>(args?: Subset<T, CursoMatriculado$PeriodoMatriculadoArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    notas<T extends CursoMatriculado$notasArgs<ExtArgs> = {}>(args?: Subset<T, CursoMatriculado$notasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CursoMatriculado model
   */ 
  interface CursoMatriculadoFieldRefs {
    readonly id: FieldRef<"CursoMatriculado", 'String'>
    readonly averageGrade: FieldRef<"CursoMatriculado", 'Float'>
    readonly salon: FieldRef<"CursoMatriculado", 'String'>
    readonly profesor: FieldRef<"CursoMatriculado", 'String'>
    readonly idCurso: FieldRef<"CursoMatriculado", 'String'>
    readonly vez: FieldRef<"CursoMatriculado", 'Int'>
    readonly status: FieldRef<"CursoMatriculado", 'String'>
    readonly periodoMatriculadoId: FieldRef<"CursoMatriculado", 'String'>
    readonly diasClase: FieldRef<"CursoMatriculado", 'Int[]'>
    readonly horaInicio: FieldRef<"CursoMatriculado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CursoMatriculado findUnique
   */
  export type CursoMatriculadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which CursoMatriculado to fetch.
     */
    where: CursoMatriculadoWhereUniqueInput
  }

  /**
   * CursoMatriculado findUniqueOrThrow
   */
  export type CursoMatriculadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which CursoMatriculado to fetch.
     */
    where: CursoMatriculadoWhereUniqueInput
  }

  /**
   * CursoMatriculado findFirst
   */
  export type CursoMatriculadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which CursoMatriculado to fetch.
     */
    where?: CursoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoMatriculados to fetch.
     */
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursoMatriculados.
     */
    cursor?: CursoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursoMatriculados.
     */
    distinct?: CursoMatriculadoScalarFieldEnum | CursoMatriculadoScalarFieldEnum[]
  }

  /**
   * CursoMatriculado findFirstOrThrow
   */
  export type CursoMatriculadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which CursoMatriculado to fetch.
     */
    where?: CursoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoMatriculados to fetch.
     */
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CursoMatriculados.
     */
    cursor?: CursoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CursoMatriculados.
     */
    distinct?: CursoMatriculadoScalarFieldEnum | CursoMatriculadoScalarFieldEnum[]
  }

  /**
   * CursoMatriculado findMany
   */
  export type CursoMatriculadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which CursoMatriculados to fetch.
     */
    where?: CursoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CursoMatriculados to fetch.
     */
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CursoMatriculados.
     */
    cursor?: CursoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CursoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CursoMatriculados.
     */
    skip?: number
    distinct?: CursoMatriculadoScalarFieldEnum | CursoMatriculadoScalarFieldEnum[]
  }

  /**
   * CursoMatriculado create
   */
  export type CursoMatriculadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * The data needed to create a CursoMatriculado.
     */
    data: XOR<CursoMatriculadoCreateInput, CursoMatriculadoUncheckedCreateInput>
  }

  /**
   * CursoMatriculado createMany
   */
  export type CursoMatriculadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CursoMatriculados.
     */
    data: CursoMatriculadoCreateManyInput | CursoMatriculadoCreateManyInput[]
  }

  /**
   * CursoMatriculado update
   */
  export type CursoMatriculadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * The data needed to update a CursoMatriculado.
     */
    data: XOR<CursoMatriculadoUpdateInput, CursoMatriculadoUncheckedUpdateInput>
    /**
     * Choose, which CursoMatriculado to update.
     */
    where: CursoMatriculadoWhereUniqueInput
  }

  /**
   * CursoMatriculado updateMany
   */
  export type CursoMatriculadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CursoMatriculados.
     */
    data: XOR<CursoMatriculadoUpdateManyMutationInput, CursoMatriculadoUncheckedUpdateManyInput>
    /**
     * Filter which CursoMatriculados to update
     */
    where?: CursoMatriculadoWhereInput
  }

  /**
   * CursoMatriculado upsert
   */
  export type CursoMatriculadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * The filter to search for the CursoMatriculado to update in case it exists.
     */
    where: CursoMatriculadoWhereUniqueInput
    /**
     * In case the CursoMatriculado found by the `where` argument doesn't exist, create a new CursoMatriculado with this data.
     */
    create: XOR<CursoMatriculadoCreateInput, CursoMatriculadoUncheckedCreateInput>
    /**
     * In case the CursoMatriculado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CursoMatriculadoUpdateInput, CursoMatriculadoUncheckedUpdateInput>
  }

  /**
   * CursoMatriculado delete
   */
  export type CursoMatriculadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter which CursoMatriculado to delete.
     */
    where: CursoMatriculadoWhereUniqueInput
  }

  /**
   * CursoMatriculado deleteMany
   */
  export type CursoMatriculadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CursoMatriculados to delete
     */
    where?: CursoMatriculadoWhereInput
  }

  /**
   * CursoMatriculado findRaw
   */
  export type CursoMatriculadoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CursoMatriculado aggregateRaw
   */
  export type CursoMatriculadoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CursoMatriculado.PeriodoMatriculado
   */
  export type CursoMatriculado$PeriodoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    where?: PeriodoMatriculadoWhereInput
  }

  /**
   * CursoMatriculado.notas
   */
  export type CursoMatriculado$notasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    where?: NotaWhereInput
    orderBy?: NotaOrderByWithRelationInput | NotaOrderByWithRelationInput[]
    cursor?: NotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotaScalarFieldEnum | NotaScalarFieldEnum[]
  }

  /**
   * CursoMatriculado without action
   */
  export type CursoMatriculadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
  }


  /**
   * Model Nota
   */

  export type AggregateNota = {
    _count: NotaCountAggregateOutputType | null
    _avg: NotaAvgAggregateOutputType | null
    _sum: NotaSumAggregateOutputType | null
    _min: NotaMinAggregateOutputType | null
    _max: NotaMaxAggregateOutputType | null
  }

  export type NotaAvgAggregateOutputType = {
    calificacion: number | null
    peso: number | null
  }

  export type NotaSumAggregateOutputType = {
    calificacion: number | null
    peso: number | null
  }

  export type NotaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    calificacion: number | null
    peso: number | null
    cursoMatriculadoId: string | null
  }

  export type NotaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    calificacion: number | null
    peso: number | null
    cursoMatriculadoId: string | null
  }

  export type NotaCountAggregateOutputType = {
    id: number
    nombre: number
    calificacion: number
    peso: number
    cursoMatriculadoId: number
    _all: number
  }


  export type NotaAvgAggregateInputType = {
    calificacion?: true
    peso?: true
  }

  export type NotaSumAggregateInputType = {
    calificacion?: true
    peso?: true
  }

  export type NotaMinAggregateInputType = {
    id?: true
    nombre?: true
    calificacion?: true
    peso?: true
    cursoMatriculadoId?: true
  }

  export type NotaMaxAggregateInputType = {
    id?: true
    nombre?: true
    calificacion?: true
    peso?: true
    cursoMatriculadoId?: true
  }

  export type NotaCountAggregateInputType = {
    id?: true
    nombre?: true
    calificacion?: true
    peso?: true
    cursoMatriculadoId?: true
    _all?: true
  }

  export type NotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nota to aggregate.
     */
    where?: NotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notas to fetch.
     */
    orderBy?: NotaOrderByWithRelationInput | NotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notas
    **/
    _count?: true | NotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotaMaxAggregateInputType
  }

  export type GetNotaAggregateType<T extends NotaAggregateArgs> = {
        [P in keyof T & keyof AggregateNota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNota[P]>
      : GetScalarType<T[P], AggregateNota[P]>
  }




  export type NotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotaWhereInput
    orderBy?: NotaOrderByWithAggregationInput | NotaOrderByWithAggregationInput[]
    by: NotaScalarFieldEnum[] | NotaScalarFieldEnum
    having?: NotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotaCountAggregateInputType | true
    _avg?: NotaAvgAggregateInputType
    _sum?: NotaSumAggregateInputType
    _min?: NotaMinAggregateInputType
    _max?: NotaMaxAggregateInputType
  }

  export type NotaGroupByOutputType = {
    id: string
    nombre: string
    calificacion: number
    peso: number
    cursoMatriculadoId: string
    _count: NotaCountAggregateOutputType | null
    _avg: NotaAvgAggregateOutputType | null
    _sum: NotaSumAggregateOutputType | null
    _min: NotaMinAggregateOutputType | null
    _max: NotaMaxAggregateOutputType | null
  }

  type GetNotaGroupByPayload<T extends NotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotaGroupByOutputType[P]>
            : GetScalarType<T[P], NotaGroupByOutputType[P]>
        }
      >
    >


  export type NotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    calificacion?: boolean
    peso?: boolean
    cursoMatriculadoId?: boolean
    cursoMatriculado?: boolean | CursoMatriculadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nota"]>


  export type NotaSelectScalar = {
    id?: boolean
    nombre?: boolean
    calificacion?: boolean
    peso?: boolean
    cursoMatriculadoId?: boolean
  }

  export type NotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cursoMatriculado?: boolean | CursoMatriculadoDefaultArgs<ExtArgs>
  }

  export type $NotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nota"
    objects: {
      cursoMatriculado: Prisma.$CursoMatriculadoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      calificacion: number
      peso: number
      cursoMatriculadoId: string
    }, ExtArgs["result"]["nota"]>
    composites: {}
  }

  type NotaGetPayload<S extends boolean | null | undefined | NotaDefaultArgs> = $Result.GetResult<Prisma.$NotaPayload, S>

  type NotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotaCountAggregateInputType | true
    }

  export interface NotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nota'], meta: { name: 'Nota' } }
    /**
     * Find zero or one Nota that matches the filter.
     * @param {NotaFindUniqueArgs} args - Arguments to find a Nota
     * @example
     * // Get one Nota
     * const nota = await prisma.nota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotaFindUniqueArgs>(args: SelectSubset<T, NotaFindUniqueArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Nota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotaFindUniqueOrThrowArgs} args - Arguments to find a Nota
     * @example
     * // Get one Nota
     * const nota = await prisma.nota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotaFindUniqueOrThrowArgs>(args: SelectSubset<T, NotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Nota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFindFirstArgs} args - Arguments to find a Nota
     * @example
     * // Get one Nota
     * const nota = await prisma.nota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotaFindFirstArgs>(args?: SelectSubset<T, NotaFindFirstArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Nota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFindFirstOrThrowArgs} args - Arguments to find a Nota
     * @example
     * // Get one Nota
     * const nota = await prisma.nota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotaFindFirstOrThrowArgs>(args?: SelectSubset<T, NotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notas
     * const notas = await prisma.nota.findMany()
     * 
     * // Get first 10 Notas
     * const notas = await prisma.nota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notaWithIdOnly = await prisma.nota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotaFindManyArgs>(args?: SelectSubset<T, NotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Nota.
     * @param {NotaCreateArgs} args - Arguments to create a Nota.
     * @example
     * // Create one Nota
     * const Nota = await prisma.nota.create({
     *   data: {
     *     // ... data to create a Nota
     *   }
     * })
     * 
     */
    create<T extends NotaCreateArgs>(args: SelectSubset<T, NotaCreateArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notas.
     * @param {NotaCreateManyArgs} args - Arguments to create many Notas.
     * @example
     * // Create many Notas
     * const nota = await prisma.nota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotaCreateManyArgs>(args?: SelectSubset<T, NotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Nota.
     * @param {NotaDeleteArgs} args - Arguments to delete one Nota.
     * @example
     * // Delete one Nota
     * const Nota = await prisma.nota.delete({
     *   where: {
     *     // ... filter to delete one Nota
     *   }
     * })
     * 
     */
    delete<T extends NotaDeleteArgs>(args: SelectSubset<T, NotaDeleteArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Nota.
     * @param {NotaUpdateArgs} args - Arguments to update one Nota.
     * @example
     * // Update one Nota
     * const nota = await prisma.nota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotaUpdateArgs>(args: SelectSubset<T, NotaUpdateArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notas.
     * @param {NotaDeleteManyArgs} args - Arguments to filter Notas to delete.
     * @example
     * // Delete a few Notas
     * const { count } = await prisma.nota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotaDeleteManyArgs>(args?: SelectSubset<T, NotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notas
     * const nota = await prisma.nota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotaUpdateManyArgs>(args: SelectSubset<T, NotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nota.
     * @param {NotaUpsertArgs} args - Arguments to update or create a Nota.
     * @example
     * // Update or create a Nota
     * const nota = await prisma.nota.upsert({
     *   create: {
     *     // ... data to create a Nota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nota we want to update
     *   }
     * })
     */
    upsert<T extends NotaUpsertArgs>(args: SelectSubset<T, NotaUpsertArgs<ExtArgs>>): Prisma__NotaClient<$Result.GetResult<Prisma.$NotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Notas that matches the filter.
     * @param {NotaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const nota = await prisma.nota.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: NotaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Nota.
     * @param {NotaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const nota = await prisma.nota.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaCountArgs} args - Arguments to filter Notas to count.
     * @example
     * // Count the number of Notas
     * const count = await prisma.nota.count({
     *   where: {
     *     // ... the filter for the Notas we want to count
     *   }
     * })
    **/
    count<T extends NotaCountArgs>(
      args?: Subset<T, NotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotaAggregateArgs>(args: Subset<T, NotaAggregateArgs>): Prisma.PrismaPromise<GetNotaAggregateType<T>>

    /**
     * Group by Nota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotaGroupByArgs['orderBy'] }
        : { orderBy?: NotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nota model
   */
  readonly fields: NotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cursoMatriculado<T extends CursoMatriculadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CursoMatriculadoDefaultArgs<ExtArgs>>): Prisma__CursoMatriculadoClient<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nota model
   */ 
  interface NotaFieldRefs {
    readonly id: FieldRef<"Nota", 'String'>
    readonly nombre: FieldRef<"Nota", 'String'>
    readonly calificacion: FieldRef<"Nota", 'Float'>
    readonly peso: FieldRef<"Nota", 'Float'>
    readonly cursoMatriculadoId: FieldRef<"Nota", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Nota findUnique
   */
  export type NotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter, which Nota to fetch.
     */
    where: NotaWhereUniqueInput
  }

  /**
   * Nota findUniqueOrThrow
   */
  export type NotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter, which Nota to fetch.
     */
    where: NotaWhereUniqueInput
  }

  /**
   * Nota findFirst
   */
  export type NotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter, which Nota to fetch.
     */
    where?: NotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notas to fetch.
     */
    orderBy?: NotaOrderByWithRelationInput | NotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notas.
     */
    cursor?: NotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notas.
     */
    distinct?: NotaScalarFieldEnum | NotaScalarFieldEnum[]
  }

  /**
   * Nota findFirstOrThrow
   */
  export type NotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter, which Nota to fetch.
     */
    where?: NotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notas to fetch.
     */
    orderBy?: NotaOrderByWithRelationInput | NotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notas.
     */
    cursor?: NotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notas.
     */
    distinct?: NotaScalarFieldEnum | NotaScalarFieldEnum[]
  }

  /**
   * Nota findMany
   */
  export type NotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter, which Notas to fetch.
     */
    where?: NotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notas to fetch.
     */
    orderBy?: NotaOrderByWithRelationInput | NotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notas.
     */
    cursor?: NotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notas.
     */
    skip?: number
    distinct?: NotaScalarFieldEnum | NotaScalarFieldEnum[]
  }

  /**
   * Nota create
   */
  export type NotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * The data needed to create a Nota.
     */
    data: XOR<NotaCreateInput, NotaUncheckedCreateInput>
  }

  /**
   * Nota createMany
   */
  export type NotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notas.
     */
    data: NotaCreateManyInput | NotaCreateManyInput[]
  }

  /**
   * Nota update
   */
  export type NotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * The data needed to update a Nota.
     */
    data: XOR<NotaUpdateInput, NotaUncheckedUpdateInput>
    /**
     * Choose, which Nota to update.
     */
    where: NotaWhereUniqueInput
  }

  /**
   * Nota updateMany
   */
  export type NotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notas.
     */
    data: XOR<NotaUpdateManyMutationInput, NotaUncheckedUpdateManyInput>
    /**
     * Filter which Notas to update
     */
    where?: NotaWhereInput
  }

  /**
   * Nota upsert
   */
  export type NotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * The filter to search for the Nota to update in case it exists.
     */
    where: NotaWhereUniqueInput
    /**
     * In case the Nota found by the `where` argument doesn't exist, create a new Nota with this data.
     */
    create: XOR<NotaCreateInput, NotaUncheckedCreateInput>
    /**
     * In case the Nota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotaUpdateInput, NotaUncheckedUpdateInput>
  }

  /**
   * Nota delete
   */
  export type NotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
    /**
     * Filter which Nota to delete.
     */
    where: NotaWhereUniqueInput
  }

  /**
   * Nota deleteMany
   */
  export type NotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notas to delete
     */
    where?: NotaWhereInput
  }

  /**
   * Nota findRaw
   */
  export type NotaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Nota aggregateRaw
   */
  export type NotaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Nota without action
   */
  export type NotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nota
     */
    select?: NotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotaInclude<ExtArgs> | null
  }


  /**
   * Model Pagos
   */

  export type AggregatePagos = {
    _count: PagosCountAggregateOutputType | null
    _avg: PagosAvgAggregateOutputType | null
    _sum: PagosSumAggregateOutputType | null
    _min: PagosMinAggregateOutputType | null
    _max: PagosMaxAggregateOutputType | null
  }

  export type PagosAvgAggregateOutputType = {
    monto: number | null
  }

  export type PagosSumAggregateOutputType = {
    monto: number | null
  }

  export type PagosMinAggregateOutputType = {
    id: string | null
    cod: string | null
    descripcion: string | null
    monto: number | null
    fechaVencimiento: Date | null
    estado: string | null
    urlRecibo: string | null
    tipo: string | null
    usuarioId: string | null
    periodoMatriculadoId: string | null
  }

  export type PagosMaxAggregateOutputType = {
    id: string | null
    cod: string | null
    descripcion: string | null
    monto: number | null
    fechaVencimiento: Date | null
    estado: string | null
    urlRecibo: string | null
    tipo: string | null
    usuarioId: string | null
    periodoMatriculadoId: string | null
  }

  export type PagosCountAggregateOutputType = {
    id: number
    cod: number
    descripcion: number
    monto: number
    fechaVencimiento: number
    estado: number
    urlRecibo: number
    tipo: number
    usuarioId: number
    periodoMatriculadoId: number
    _all: number
  }


  export type PagosAvgAggregateInputType = {
    monto?: true
  }

  export type PagosSumAggregateInputType = {
    monto?: true
  }

  export type PagosMinAggregateInputType = {
    id?: true
    cod?: true
    descripcion?: true
    monto?: true
    fechaVencimiento?: true
    estado?: true
    urlRecibo?: true
    tipo?: true
    usuarioId?: true
    periodoMatriculadoId?: true
  }

  export type PagosMaxAggregateInputType = {
    id?: true
    cod?: true
    descripcion?: true
    monto?: true
    fechaVencimiento?: true
    estado?: true
    urlRecibo?: true
    tipo?: true
    usuarioId?: true
    periodoMatriculadoId?: true
  }

  export type PagosCountAggregateInputType = {
    id?: true
    cod?: true
    descripcion?: true
    monto?: true
    fechaVencimiento?: true
    estado?: true
    urlRecibo?: true
    tipo?: true
    usuarioId?: true
    periodoMatriculadoId?: true
    _all?: true
  }

  export type PagosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to aggregate.
     */
    where?: PagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagos
    **/
    _count?: true | PagosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagosMaxAggregateInputType
  }

  export type GetPagosAggregateType<T extends PagosAggregateArgs> = {
        [P in keyof T & keyof AggregatePagos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagos[P]>
      : GetScalarType<T[P], AggregatePagos[P]>
  }




  export type PagosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagosWhereInput
    orderBy?: PagosOrderByWithAggregationInput | PagosOrderByWithAggregationInput[]
    by: PagosScalarFieldEnum[] | PagosScalarFieldEnum
    having?: PagosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagosCountAggregateInputType | true
    _avg?: PagosAvgAggregateInputType
    _sum?: PagosSumAggregateInputType
    _min?: PagosMinAggregateInputType
    _max?: PagosMaxAggregateInputType
  }

  export type PagosGroupByOutputType = {
    id: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date
    estado: string
    urlRecibo: string | null
    tipo: string
    usuarioId: string | null
    periodoMatriculadoId: string | null
    _count: PagosCountAggregateOutputType | null
    _avg: PagosAvgAggregateOutputType | null
    _sum: PagosSumAggregateOutputType | null
    _min: PagosMinAggregateOutputType | null
    _max: PagosMaxAggregateOutputType | null
  }

  type GetPagosGroupByPayload<T extends PagosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagosGroupByOutputType[P]>
            : GetScalarType<T[P], PagosGroupByOutputType[P]>
        }
      >
    >


  export type PagosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cod?: boolean
    descripcion?: boolean
    monto?: boolean
    fechaVencimiento?: boolean
    estado?: boolean
    urlRecibo?: boolean
    tipo?: boolean
    usuarioId?: boolean
    periodoMatriculadoId?: boolean
    Usuario?: boolean | Pagos$UsuarioArgs<ExtArgs>
    PeriodoMatriculado?: boolean | Pagos$PeriodoMatriculadoArgs<ExtArgs>
  }, ExtArgs["result"]["pagos"]>


  export type PagosSelectScalar = {
    id?: boolean
    cod?: boolean
    descripcion?: boolean
    monto?: boolean
    fechaVencimiento?: boolean
    estado?: boolean
    urlRecibo?: boolean
    tipo?: boolean
    usuarioId?: boolean
    periodoMatriculadoId?: boolean
  }

  export type PagosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | Pagos$UsuarioArgs<ExtArgs>
    PeriodoMatriculado?: boolean | Pagos$PeriodoMatriculadoArgs<ExtArgs>
  }

  export type $PagosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagos"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
      PeriodoMatriculado: Prisma.$PeriodoMatriculadoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cod: string
      descripcion: string
      monto: number
      fechaVencimiento: Date
      estado: string
      urlRecibo: string | null
      tipo: string
      usuarioId: string | null
      periodoMatriculadoId: string | null
    }, ExtArgs["result"]["pagos"]>
    composites: {}
  }

  type PagosGetPayload<S extends boolean | null | undefined | PagosDefaultArgs> = $Result.GetResult<Prisma.$PagosPayload, S>

  type PagosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagosCountAggregateInputType | true
    }

  export interface PagosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagos'], meta: { name: 'Pagos' } }
    /**
     * Find zero or one Pagos that matches the filter.
     * @param {PagosFindUniqueArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagosFindUniqueArgs>(args: SelectSubset<T, PagosFindUniqueArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagos that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagosFindUniqueOrThrowArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagosFindUniqueOrThrowArgs>(args: SelectSubset<T, PagosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosFindFirstArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagosFindFirstArgs>(args?: SelectSubset<T, PagosFindFirstArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosFindFirstOrThrowArgs} args - Arguments to find a Pagos
     * @example
     * // Get one Pagos
     * const pagos = await prisma.pagos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagosFindFirstOrThrowArgs>(args?: SelectSubset<T, PagosFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pagos.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pagos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagosWithIdOnly = await prisma.pagos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagosFindManyArgs>(args?: SelectSubset<T, PagosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagos.
     * @param {PagosCreateArgs} args - Arguments to create a Pagos.
     * @example
     * // Create one Pagos
     * const Pagos = await prisma.pagos.create({
     *   data: {
     *     // ... data to create a Pagos
     *   }
     * })
     * 
     */
    create<T extends PagosCreateArgs>(args: SelectSubset<T, PagosCreateArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagos.
     * @param {PagosCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pagos = await prisma.pagos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagosCreateManyArgs>(args?: SelectSubset<T, PagosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pagos.
     * @param {PagosDeleteArgs} args - Arguments to delete one Pagos.
     * @example
     * // Delete one Pagos
     * const Pagos = await prisma.pagos.delete({
     *   where: {
     *     // ... filter to delete one Pagos
     *   }
     * })
     * 
     */
    delete<T extends PagosDeleteArgs>(args: SelectSubset<T, PagosDeleteArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagos.
     * @param {PagosUpdateArgs} args - Arguments to update one Pagos.
     * @example
     * // Update one Pagos
     * const pagos = await prisma.pagos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagosUpdateArgs>(args: SelectSubset<T, PagosUpdateArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagos.
     * @param {PagosDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pagos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagosDeleteManyArgs>(args?: SelectSubset<T, PagosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pagos = await prisma.pagos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagosUpdateManyArgs>(args: SelectSubset<T, PagosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagos.
     * @param {PagosUpsertArgs} args - Arguments to update or create a Pagos.
     * @example
     * // Update or create a Pagos
     * const pagos = await prisma.pagos.upsert({
     *   create: {
     *     // ... data to create a Pagos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagos we want to update
     *   }
     * })
     */
    upsert<T extends PagosUpsertArgs>(args: SelectSubset<T, PagosUpsertArgs<ExtArgs>>): Prisma__PagosClient<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Pagos that matches the filter.
     * @param {PagosFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pagos = await prisma.pagos.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PagosFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Pagos.
     * @param {PagosAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pagos = await prisma.pagos.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PagosAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pagos.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends PagosCountArgs>(
      args?: Subset<T, PagosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagosAggregateArgs>(args: Subset<T, PagosAggregateArgs>): Prisma.PrismaPromise<GetPagosAggregateType<T>>

    /**
     * Group by Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagosGroupByArgs['orderBy'] }
        : { orderBy?: PagosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagos model
   */
  readonly fields: PagosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends Pagos$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Pagos$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    PeriodoMatriculado<T extends Pagos$PeriodoMatriculadoArgs<ExtArgs> = {}>(args?: Subset<T, Pagos$PeriodoMatriculadoArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagos model
   */ 
  interface PagosFieldRefs {
    readonly id: FieldRef<"Pagos", 'String'>
    readonly cod: FieldRef<"Pagos", 'String'>
    readonly descripcion: FieldRef<"Pagos", 'String'>
    readonly monto: FieldRef<"Pagos", 'Float'>
    readonly fechaVencimiento: FieldRef<"Pagos", 'DateTime'>
    readonly estado: FieldRef<"Pagos", 'String'>
    readonly urlRecibo: FieldRef<"Pagos", 'String'>
    readonly tipo: FieldRef<"Pagos", 'String'>
    readonly usuarioId: FieldRef<"Pagos", 'String'>
    readonly periodoMatriculadoId: FieldRef<"Pagos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pagos findUnique
   */
  export type PagosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where: PagosWhereUniqueInput
  }

  /**
   * Pagos findUniqueOrThrow
   */
  export type PagosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where: PagosWhereUniqueInput
  }

  /**
   * Pagos findFirst
   */
  export type PagosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagosScalarFieldEnum | PagosScalarFieldEnum[]
  }

  /**
   * Pagos findFirstOrThrow
   */
  export type PagosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagosScalarFieldEnum | PagosScalarFieldEnum[]
  }

  /**
   * Pagos findMany
   */
  export type PagosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagos.
     */
    cursor?: PagosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    distinct?: PagosScalarFieldEnum | PagosScalarFieldEnum[]
  }

  /**
   * Pagos create
   */
  export type PagosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagos.
     */
    data: XOR<PagosCreateInput, PagosUncheckedCreateInput>
  }

  /**
   * Pagos createMany
   */
  export type PagosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagos.
     */
    data: PagosCreateManyInput | PagosCreateManyInput[]
  }

  /**
   * Pagos update
   */
  export type PagosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagos.
     */
    data: XOR<PagosUpdateInput, PagosUncheckedUpdateInput>
    /**
     * Choose, which Pagos to update.
     */
    where: PagosWhereUniqueInput
  }

  /**
   * Pagos updateMany
   */
  export type PagosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagosUpdateManyMutationInput, PagosUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagosWhereInput
  }

  /**
   * Pagos upsert
   */
  export type PagosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagos to update in case it exists.
     */
    where: PagosWhereUniqueInput
    /**
     * In case the Pagos found by the `where` argument doesn't exist, create a new Pagos with this data.
     */
    create: XOR<PagosCreateInput, PagosUncheckedCreateInput>
    /**
     * In case the Pagos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagosUpdateInput, PagosUncheckedUpdateInput>
  }

  /**
   * Pagos delete
   */
  export type PagosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    /**
     * Filter which Pagos to delete.
     */
    where: PagosWhereUniqueInput
  }

  /**
   * Pagos deleteMany
   */
  export type PagosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to delete
     */
    where?: PagosWhereInput
  }

  /**
   * Pagos findRaw
   */
  export type PagosFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Pagos aggregateRaw
   */
  export type PagosAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Pagos.Usuario
   */
  export type Pagos$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Pagos.PeriodoMatriculado
   */
  export type Pagos$PeriodoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    where?: PeriodoMatriculadoWhereInput
  }

  /**
   * Pagos without action
   */
  export type PagosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
  }


  /**
   * Model Servicios
   */

  export type AggregateServicios = {
    _count: ServiciosCountAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  export type ServiciosMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
  }

  export type ServiciosMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
  }

  export type ServiciosCountAggregateOutputType = {
    id: number
    nombre: number
    tipo: number
    fechas: number
    _all: number
  }


  export type ServiciosMinAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
  }

  export type ServiciosMaxAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
  }

  export type ServiciosCountAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    fechas?: true
    _all?: true
  }

  export type ServiciosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to aggregate.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServiciosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosMaxAggregateInputType
  }

  export type GetServiciosAggregateType<T extends ServiciosAggregateArgs> = {
        [P in keyof T & keyof AggregateServicios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicios[P]>
      : GetScalarType<T[P], AggregateServicios[P]>
  }




  export type ServiciosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiciosWhereInput
    orderBy?: ServiciosOrderByWithAggregationInput | ServiciosOrderByWithAggregationInput[]
    by: ServiciosScalarFieldEnum[] | ServiciosScalarFieldEnum
    having?: ServiciosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosCountAggregateInputType | true
    _min?: ServiciosMinAggregateInputType
    _max?: ServiciosMaxAggregateInputType
  }

  export type ServiciosGroupByOutputType = {
    id: string
    nombre: string
    tipo: string
    fechas: Date[]
    _count: ServiciosCountAggregateOutputType | null
    _min: ServiciosMinAggregateOutputType | null
    _max: ServiciosMaxAggregateOutputType | null
  }

  type GetServiciosGroupByPayload<T extends ServiciosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosGroupByOutputType[P]>
        }
      >
    >


  export type ServiciosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    fechas?: boolean
    ServiciosUtilizados?: boolean | Servicios$ServiciosUtilizadosArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicios"]>


  export type ServiciosSelectScalar = {
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    fechas?: boolean
  }

  export type ServiciosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServiciosUtilizados?: boolean | Servicios$ServiciosUtilizadosArgs<ExtArgs>
    _count?: boolean | ServiciosCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiciosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicios"
    objects: {
      ServiciosUtilizados: Prisma.$ServiciosUtilizadosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      tipo: string
      fechas: Date[]
    }, ExtArgs["result"]["servicios"]>
    composites: {}
  }

  type ServiciosGetPayload<S extends boolean | null | undefined | ServiciosDefaultArgs> = $Result.GetResult<Prisma.$ServiciosPayload, S>

  type ServiciosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiciosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiciosCountAggregateInputType | true
    }

  export interface ServiciosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicios'], meta: { name: 'Servicios' } }
    /**
     * Find zero or one Servicios that matches the filter.
     * @param {ServiciosFindUniqueArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiciosFindUniqueArgs>(args: SelectSubset<T, ServiciosFindUniqueArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Servicios that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiciosFindUniqueOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiciosFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiciosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindFirstArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiciosFindFirstArgs>(args?: SelectSubset<T, ServiciosFindFirstArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Servicios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindFirstOrThrowArgs} args - Arguments to find a Servicios
     * @example
     * // Get one Servicios
     * const servicios = await prisma.servicios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiciosFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiciosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicios.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviciosWithIdOnly = await prisma.servicios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiciosFindManyArgs>(args?: SelectSubset<T, ServiciosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Servicios.
     * @param {ServiciosCreateArgs} args - Arguments to create a Servicios.
     * @example
     * // Create one Servicios
     * const Servicios = await prisma.servicios.create({
     *   data: {
     *     // ... data to create a Servicios
     *   }
     * })
     * 
     */
    create<T extends ServiciosCreateArgs>(args: SelectSubset<T, ServiciosCreateArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Servicios.
     * @param {ServiciosCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicios = await prisma.servicios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiciosCreateManyArgs>(args?: SelectSubset<T, ServiciosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Servicios.
     * @param {ServiciosDeleteArgs} args - Arguments to delete one Servicios.
     * @example
     * // Delete one Servicios
     * const Servicios = await prisma.servicios.delete({
     *   where: {
     *     // ... filter to delete one Servicios
     *   }
     * })
     * 
     */
    delete<T extends ServiciosDeleteArgs>(args: SelectSubset<T, ServiciosDeleteArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Servicios.
     * @param {ServiciosUpdateArgs} args - Arguments to update one Servicios.
     * @example
     * // Update one Servicios
     * const servicios = await prisma.servicios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiciosUpdateArgs>(args: SelectSubset<T, ServiciosUpdateArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Servicios.
     * @param {ServiciosDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiciosDeleteManyArgs>(args?: SelectSubset<T, ServiciosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicios = await prisma.servicios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiciosUpdateManyArgs>(args: SelectSubset<T, ServiciosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Servicios.
     * @param {ServiciosUpsertArgs} args - Arguments to update or create a Servicios.
     * @example
     * // Update or create a Servicios
     * const servicios = await prisma.servicios.upsert({
     *   create: {
     *     // ... data to create a Servicios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicios we want to update
     *   }
     * })
     */
    upsert<T extends ServiciosUpsertArgs>(args: SelectSubset<T, ServiciosUpsertArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Servicios that matches the filter.
     * @param {ServiciosFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const servicios = await prisma.servicios.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ServiciosFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Servicios.
     * @param {ServiciosAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const servicios = await prisma.servicios.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiciosAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicios.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServiciosCountArgs>(
      args?: Subset<T, ServiciosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosAggregateArgs>(args: Subset<T, ServiciosAggregateArgs>): Prisma.PrismaPromise<GetServiciosAggregateType<T>>

    /**
     * Group by Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiciosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiciosGroupByArgs['orderBy'] }
        : { orderBy?: ServiciosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiciosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicios model
   */
  readonly fields: ServiciosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiciosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ServiciosUtilizados<T extends Servicios$ServiciosUtilizadosArgs<ExtArgs> = {}>(args?: Subset<T, Servicios$ServiciosUtilizadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servicios model
   */ 
  interface ServiciosFieldRefs {
    readonly id: FieldRef<"Servicios", 'String'>
    readonly nombre: FieldRef<"Servicios", 'String'>
    readonly tipo: FieldRef<"Servicios", 'String'>
    readonly fechas: FieldRef<"Servicios", 'DateTime[]'>
  }
    

  // Custom InputTypes
  /**
   * Servicios findUnique
   */
  export type ServiciosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where: ServiciosWhereUniqueInput
  }

  /**
   * Servicios findUniqueOrThrow
   */
  export type ServiciosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where: ServiciosWhereUniqueInput
  }

  /**
   * Servicios findFirst
   */
  export type ServiciosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * Servicios findFirstOrThrow
   */
  export type ServiciosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * Servicios findMany
   */
  export type ServiciosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServiciosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServiciosOrderByWithRelationInput | ServiciosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServiciosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServiciosScalarFieldEnum | ServiciosScalarFieldEnum[]
  }

  /**
   * Servicios create
   */
  export type ServiciosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicios.
     */
    data: XOR<ServiciosCreateInput, ServiciosUncheckedCreateInput>
  }

  /**
   * Servicios createMany
   */
  export type ServiciosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServiciosCreateManyInput | ServiciosCreateManyInput[]
  }

  /**
   * Servicios update
   */
  export type ServiciosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicios.
     */
    data: XOR<ServiciosUpdateInput, ServiciosUncheckedUpdateInput>
    /**
     * Choose, which Servicios to update.
     */
    where: ServiciosWhereUniqueInput
  }

  /**
   * Servicios updateMany
   */
  export type ServiciosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServiciosUpdateManyMutationInput, ServiciosUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServiciosWhereInput
  }

  /**
   * Servicios upsert
   */
  export type ServiciosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicios to update in case it exists.
     */
    where: ServiciosWhereUniqueInput
    /**
     * In case the Servicios found by the `where` argument doesn't exist, create a new Servicios with this data.
     */
    create: XOR<ServiciosCreateInput, ServiciosUncheckedCreateInput>
    /**
     * In case the Servicios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiciosUpdateInput, ServiciosUncheckedUpdateInput>
  }

  /**
   * Servicios delete
   */
  export type ServiciosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    /**
     * Filter which Servicios to delete.
     */
    where: ServiciosWhereUniqueInput
  }

  /**
   * Servicios deleteMany
   */
  export type ServiciosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServiciosWhereInput
  }

  /**
   * Servicios findRaw
   */
  export type ServiciosFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Servicios aggregateRaw
   */
  export type ServiciosAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Servicios.ServiciosUtilizados
   */
  export type Servicios$ServiciosUtilizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    where?: ServiciosUtilizadosWhereInput
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    cursor?: ServiciosUtilizadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiciosUtilizadosScalarFieldEnum | ServiciosUtilizadosScalarFieldEnum[]
  }

  /**
   * Servicios without action
   */
  export type ServiciosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
  }


  /**
   * Model Tramites
   */

  export type AggregateTramites = {
    _count: TramitesCountAggregateOutputType | null
    _avg: TramitesAvgAggregateOutputType | null
    _sum: TramitesSumAggregateOutputType | null
    _min: TramitesMinAggregateOutputType | null
    _max: TramitesMaxAggregateOutputType | null
  }

  export type TramitesAvgAggregateOutputType = {
    costo: number | null
  }

  export type TramitesSumAggregateOutputType = {
    costo: number | null
  }

  export type TramitesMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
    costo: number | null
    descripcion: string | null
  }

  export type TramitesMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    tipo: string | null
    costo: number | null
    descripcion: string | null
  }

  export type TramitesCountAggregateOutputType = {
    id: number
    nombre: number
    tipo: number
    costo: number
    requisitos: number
    descripcion: number
    _all: number
  }


  export type TramitesAvgAggregateInputType = {
    costo?: true
  }

  export type TramitesSumAggregateInputType = {
    costo?: true
  }

  export type TramitesMinAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    costo?: true
    descripcion?: true
  }

  export type TramitesMaxAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    costo?: true
    descripcion?: true
  }

  export type TramitesCountAggregateInputType = {
    id?: true
    nombre?: true
    tipo?: true
    costo?: true
    requisitos?: true
    descripcion?: true
    _all?: true
  }

  export type TramitesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tramites to aggregate.
     */
    where?: TramitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tramites to fetch.
     */
    orderBy?: TramitesOrderByWithRelationInput | TramitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TramitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tramites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tramites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tramites
    **/
    _count?: true | TramitesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TramitesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TramitesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TramitesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TramitesMaxAggregateInputType
  }

  export type GetTramitesAggregateType<T extends TramitesAggregateArgs> = {
        [P in keyof T & keyof AggregateTramites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTramites[P]>
      : GetScalarType<T[P], AggregateTramites[P]>
  }




  export type TramitesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TramitesWhereInput
    orderBy?: TramitesOrderByWithAggregationInput | TramitesOrderByWithAggregationInput[]
    by: TramitesScalarFieldEnum[] | TramitesScalarFieldEnum
    having?: TramitesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TramitesCountAggregateInputType | true
    _avg?: TramitesAvgAggregateInputType
    _sum?: TramitesSumAggregateInputType
    _min?: TramitesMinAggregateInputType
    _max?: TramitesMaxAggregateInputType
  }

  export type TramitesGroupByOutputType = {
    id: string
    nombre: string
    tipo: string
    costo: number | null
    requisitos: string[]
    descripcion: string
    _count: TramitesCountAggregateOutputType | null
    _avg: TramitesAvgAggregateOutputType | null
    _sum: TramitesSumAggregateOutputType | null
    _min: TramitesMinAggregateOutputType | null
    _max: TramitesMaxAggregateOutputType | null
  }

  type GetTramitesGroupByPayload<T extends TramitesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TramitesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TramitesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TramitesGroupByOutputType[P]>
            : GetScalarType<T[P], TramitesGroupByOutputType[P]>
        }
      >
    >


  export type TramitesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    costo?: boolean
    requisitos?: boolean
    descripcion?: boolean
    TramitesRealizados?: boolean | Tramites$TramitesRealizadosArgs<ExtArgs>
    _count?: boolean | TramitesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tramites"]>


  export type TramitesSelectScalar = {
    id?: boolean
    nombre?: boolean
    tipo?: boolean
    costo?: boolean
    requisitos?: boolean
    descripcion?: boolean
  }

  export type TramitesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TramitesRealizados?: boolean | Tramites$TramitesRealizadosArgs<ExtArgs>
    _count?: boolean | TramitesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TramitesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tramites"
    objects: {
      TramitesRealizados: Prisma.$TramitesRealizadosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      tipo: string
      costo: number | null
      requisitos: string[]
      descripcion: string
    }, ExtArgs["result"]["tramites"]>
    composites: {}
  }

  type TramitesGetPayload<S extends boolean | null | undefined | TramitesDefaultArgs> = $Result.GetResult<Prisma.$TramitesPayload, S>

  type TramitesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TramitesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TramitesCountAggregateInputType | true
    }

  export interface TramitesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tramites'], meta: { name: 'Tramites' } }
    /**
     * Find zero or one Tramites that matches the filter.
     * @param {TramitesFindUniqueArgs} args - Arguments to find a Tramites
     * @example
     * // Get one Tramites
     * const tramites = await prisma.tramites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TramitesFindUniqueArgs>(args: SelectSubset<T, TramitesFindUniqueArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tramites that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TramitesFindUniqueOrThrowArgs} args - Arguments to find a Tramites
     * @example
     * // Get one Tramites
     * const tramites = await prisma.tramites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TramitesFindUniqueOrThrowArgs>(args: SelectSubset<T, TramitesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tramites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesFindFirstArgs} args - Arguments to find a Tramites
     * @example
     * // Get one Tramites
     * const tramites = await prisma.tramites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TramitesFindFirstArgs>(args?: SelectSubset<T, TramitesFindFirstArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tramites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesFindFirstOrThrowArgs} args - Arguments to find a Tramites
     * @example
     * // Get one Tramites
     * const tramites = await prisma.tramites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TramitesFindFirstOrThrowArgs>(args?: SelectSubset<T, TramitesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tramites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tramites
     * const tramites = await prisma.tramites.findMany()
     * 
     * // Get first 10 Tramites
     * const tramites = await prisma.tramites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tramitesWithIdOnly = await prisma.tramites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TramitesFindManyArgs>(args?: SelectSubset<T, TramitesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tramites.
     * @param {TramitesCreateArgs} args - Arguments to create a Tramites.
     * @example
     * // Create one Tramites
     * const Tramites = await prisma.tramites.create({
     *   data: {
     *     // ... data to create a Tramites
     *   }
     * })
     * 
     */
    create<T extends TramitesCreateArgs>(args: SelectSubset<T, TramitesCreateArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tramites.
     * @param {TramitesCreateManyArgs} args - Arguments to create many Tramites.
     * @example
     * // Create many Tramites
     * const tramites = await prisma.tramites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TramitesCreateManyArgs>(args?: SelectSubset<T, TramitesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tramites.
     * @param {TramitesDeleteArgs} args - Arguments to delete one Tramites.
     * @example
     * // Delete one Tramites
     * const Tramites = await prisma.tramites.delete({
     *   where: {
     *     // ... filter to delete one Tramites
     *   }
     * })
     * 
     */
    delete<T extends TramitesDeleteArgs>(args: SelectSubset<T, TramitesDeleteArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tramites.
     * @param {TramitesUpdateArgs} args - Arguments to update one Tramites.
     * @example
     * // Update one Tramites
     * const tramites = await prisma.tramites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TramitesUpdateArgs>(args: SelectSubset<T, TramitesUpdateArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tramites.
     * @param {TramitesDeleteManyArgs} args - Arguments to filter Tramites to delete.
     * @example
     * // Delete a few Tramites
     * const { count } = await prisma.tramites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TramitesDeleteManyArgs>(args?: SelectSubset<T, TramitesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tramites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tramites
     * const tramites = await prisma.tramites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TramitesUpdateManyArgs>(args: SelectSubset<T, TramitesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tramites.
     * @param {TramitesUpsertArgs} args - Arguments to update or create a Tramites.
     * @example
     * // Update or create a Tramites
     * const tramites = await prisma.tramites.upsert({
     *   create: {
     *     // ... data to create a Tramites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tramites we want to update
     *   }
     * })
     */
    upsert<T extends TramitesUpsertArgs>(args: SelectSubset<T, TramitesUpsertArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tramites that matches the filter.
     * @param {TramitesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tramites = await prisma.tramites.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TramitesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tramites.
     * @param {TramitesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tramites = await prisma.tramites.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TramitesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tramites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesCountArgs} args - Arguments to filter Tramites to count.
     * @example
     * // Count the number of Tramites
     * const count = await prisma.tramites.count({
     *   where: {
     *     // ... the filter for the Tramites we want to count
     *   }
     * })
    **/
    count<T extends TramitesCountArgs>(
      args?: Subset<T, TramitesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TramitesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tramites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TramitesAggregateArgs>(args: Subset<T, TramitesAggregateArgs>): Prisma.PrismaPromise<GetTramitesAggregateType<T>>

    /**
     * Group by Tramites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TramitesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TramitesGroupByArgs['orderBy'] }
        : { orderBy?: TramitesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TramitesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTramitesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tramites model
   */
  readonly fields: TramitesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tramites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TramitesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TramitesRealizados<T extends Tramites$TramitesRealizadosArgs<ExtArgs> = {}>(args?: Subset<T, Tramites$TramitesRealizadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tramites model
   */ 
  interface TramitesFieldRefs {
    readonly id: FieldRef<"Tramites", 'String'>
    readonly nombre: FieldRef<"Tramites", 'String'>
    readonly tipo: FieldRef<"Tramites", 'String'>
    readonly costo: FieldRef<"Tramites", 'Float'>
    readonly requisitos: FieldRef<"Tramites", 'String[]'>
    readonly descripcion: FieldRef<"Tramites", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tramites findUnique
   */
  export type TramitesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter, which Tramites to fetch.
     */
    where: TramitesWhereUniqueInput
  }

  /**
   * Tramites findUniqueOrThrow
   */
  export type TramitesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter, which Tramites to fetch.
     */
    where: TramitesWhereUniqueInput
  }

  /**
   * Tramites findFirst
   */
  export type TramitesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter, which Tramites to fetch.
     */
    where?: TramitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tramites to fetch.
     */
    orderBy?: TramitesOrderByWithRelationInput | TramitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tramites.
     */
    cursor?: TramitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tramites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tramites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tramites.
     */
    distinct?: TramitesScalarFieldEnum | TramitesScalarFieldEnum[]
  }

  /**
   * Tramites findFirstOrThrow
   */
  export type TramitesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter, which Tramites to fetch.
     */
    where?: TramitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tramites to fetch.
     */
    orderBy?: TramitesOrderByWithRelationInput | TramitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tramites.
     */
    cursor?: TramitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tramites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tramites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tramites.
     */
    distinct?: TramitesScalarFieldEnum | TramitesScalarFieldEnum[]
  }

  /**
   * Tramites findMany
   */
  export type TramitesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter, which Tramites to fetch.
     */
    where?: TramitesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tramites to fetch.
     */
    orderBy?: TramitesOrderByWithRelationInput | TramitesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tramites.
     */
    cursor?: TramitesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tramites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tramites.
     */
    skip?: number
    distinct?: TramitesScalarFieldEnum | TramitesScalarFieldEnum[]
  }

  /**
   * Tramites create
   */
  export type TramitesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * The data needed to create a Tramites.
     */
    data: XOR<TramitesCreateInput, TramitesUncheckedCreateInput>
  }

  /**
   * Tramites createMany
   */
  export type TramitesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tramites.
     */
    data: TramitesCreateManyInput | TramitesCreateManyInput[]
  }

  /**
   * Tramites update
   */
  export type TramitesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * The data needed to update a Tramites.
     */
    data: XOR<TramitesUpdateInput, TramitesUncheckedUpdateInput>
    /**
     * Choose, which Tramites to update.
     */
    where: TramitesWhereUniqueInput
  }

  /**
   * Tramites updateMany
   */
  export type TramitesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tramites.
     */
    data: XOR<TramitesUpdateManyMutationInput, TramitesUncheckedUpdateManyInput>
    /**
     * Filter which Tramites to update
     */
    where?: TramitesWhereInput
  }

  /**
   * Tramites upsert
   */
  export type TramitesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * The filter to search for the Tramites to update in case it exists.
     */
    where: TramitesWhereUniqueInput
    /**
     * In case the Tramites found by the `where` argument doesn't exist, create a new Tramites with this data.
     */
    create: XOR<TramitesCreateInput, TramitesUncheckedCreateInput>
    /**
     * In case the Tramites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TramitesUpdateInput, TramitesUncheckedUpdateInput>
  }

  /**
   * Tramites delete
   */
  export type TramitesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    /**
     * Filter which Tramites to delete.
     */
    where: TramitesWhereUniqueInput
  }

  /**
   * Tramites deleteMany
   */
  export type TramitesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tramites to delete
     */
    where?: TramitesWhereInput
  }

  /**
   * Tramites findRaw
   */
  export type TramitesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tramites aggregateRaw
   */
  export type TramitesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tramites.TramitesRealizados
   */
  export type Tramites$TramitesRealizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    where?: TramitesRealizadosWhereInput
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    cursor?: TramitesRealizadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TramitesRealizadosScalarFieldEnum | TramitesRealizadosScalarFieldEnum[]
  }

  /**
   * Tramites without action
   */
  export type TramitesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
  }


  /**
   * Model PeriodoMatriculado
   */

  export type AggregatePeriodoMatriculado = {
    _count: PeriodoMatriculadoCountAggregateOutputType | null
    _avg: PeriodoMatriculadoAvgAggregateOutputType | null
    _sum: PeriodoMatriculadoSumAggregateOutputType | null
    _min: PeriodoMatriculadoMinAggregateOutputType | null
    _max: PeriodoMatriculadoMaxAggregateOutputType | null
  }

  export type PeriodoMatriculadoAvgAggregateOutputType = {
    semestre: number | null
  }

  export type PeriodoMatriculadoSumAggregateOutputType = {
    semestre: number | null
  }

  export type PeriodoMatriculadoMinAggregateOutputType = {
    id: string | null
    semestre: number | null
    periodo: string | null
    idUsuario: string | null
  }

  export type PeriodoMatriculadoMaxAggregateOutputType = {
    id: string | null
    semestre: number | null
    periodo: string | null
    idUsuario: string | null
  }

  export type PeriodoMatriculadoCountAggregateOutputType = {
    id: number
    semestre: number
    periodo: number
    idUsuario: number
    _all: number
  }


  export type PeriodoMatriculadoAvgAggregateInputType = {
    semestre?: true
  }

  export type PeriodoMatriculadoSumAggregateInputType = {
    semestre?: true
  }

  export type PeriodoMatriculadoMinAggregateInputType = {
    id?: true
    semestre?: true
    periodo?: true
    idUsuario?: true
  }

  export type PeriodoMatriculadoMaxAggregateInputType = {
    id?: true
    semestre?: true
    periodo?: true
    idUsuario?: true
  }

  export type PeriodoMatriculadoCountAggregateInputType = {
    id?: true
    semestre?: true
    periodo?: true
    idUsuario?: true
    _all?: true
  }

  export type PeriodoMatriculadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodoMatriculado to aggregate.
     */
    where?: PeriodoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodoMatriculados to fetch.
     */
    orderBy?: PeriodoMatriculadoOrderByWithRelationInput | PeriodoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeriodoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PeriodoMatriculados
    **/
    _count?: true | PeriodoMatriculadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeriodoMatriculadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeriodoMatriculadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodoMatriculadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodoMatriculadoMaxAggregateInputType
  }

  export type GetPeriodoMatriculadoAggregateType<T extends PeriodoMatriculadoAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriodoMatriculado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriodoMatriculado[P]>
      : GetScalarType<T[P], AggregatePeriodoMatriculado[P]>
  }




  export type PeriodoMatriculadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodoMatriculadoWhereInput
    orderBy?: PeriodoMatriculadoOrderByWithAggregationInput | PeriodoMatriculadoOrderByWithAggregationInput[]
    by: PeriodoMatriculadoScalarFieldEnum[] | PeriodoMatriculadoScalarFieldEnum
    having?: PeriodoMatriculadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodoMatriculadoCountAggregateInputType | true
    _avg?: PeriodoMatriculadoAvgAggregateInputType
    _sum?: PeriodoMatriculadoSumAggregateInputType
    _min?: PeriodoMatriculadoMinAggregateInputType
    _max?: PeriodoMatriculadoMaxAggregateInputType
  }

  export type PeriodoMatriculadoGroupByOutputType = {
    id: string
    semestre: number
    periodo: string
    idUsuario: string | null
    _count: PeriodoMatriculadoCountAggregateOutputType | null
    _avg: PeriodoMatriculadoAvgAggregateOutputType | null
    _sum: PeriodoMatriculadoSumAggregateOutputType | null
    _min: PeriodoMatriculadoMinAggregateOutputType | null
    _max: PeriodoMatriculadoMaxAggregateOutputType | null
  }

  type GetPeriodoMatriculadoGroupByPayload<T extends PeriodoMatriculadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodoMatriculadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodoMatriculadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodoMatriculadoGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodoMatriculadoGroupByOutputType[P]>
        }
      >
    >


  export type PeriodoMatriculadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    semestre?: boolean
    periodo?: boolean
    idUsuario?: boolean
    Usuario?: boolean | PeriodoMatriculado$UsuarioArgs<ExtArgs>
    Pagos?: boolean | PeriodoMatriculado$PagosArgs<ExtArgs>
    cursosMatriculados?: boolean | PeriodoMatriculado$cursosMatriculadosArgs<ExtArgs>
    _count?: boolean | PeriodoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["periodoMatriculado"]>


  export type PeriodoMatriculadoSelectScalar = {
    id?: boolean
    semestre?: boolean
    periodo?: boolean
    idUsuario?: boolean
  }

  export type PeriodoMatriculadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | PeriodoMatriculado$UsuarioArgs<ExtArgs>
    Pagos?: boolean | PeriodoMatriculado$PagosArgs<ExtArgs>
    cursosMatriculados?: boolean | PeriodoMatriculado$cursosMatriculadosArgs<ExtArgs>
    _count?: boolean | PeriodoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PeriodoMatriculadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PeriodoMatriculado"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
      Pagos: Prisma.$PagosPayload<ExtArgs>[]
      cursosMatriculados: Prisma.$CursoMatriculadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      semestre: number
      periodo: string
      idUsuario: string | null
    }, ExtArgs["result"]["periodoMatriculado"]>
    composites: {}
  }

  type PeriodoMatriculadoGetPayload<S extends boolean | null | undefined | PeriodoMatriculadoDefaultArgs> = $Result.GetResult<Prisma.$PeriodoMatriculadoPayload, S>

  type PeriodoMatriculadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PeriodoMatriculadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PeriodoMatriculadoCountAggregateInputType | true
    }

  export interface PeriodoMatriculadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PeriodoMatriculado'], meta: { name: 'PeriodoMatriculado' } }
    /**
     * Find zero or one PeriodoMatriculado that matches the filter.
     * @param {PeriodoMatriculadoFindUniqueArgs} args - Arguments to find a PeriodoMatriculado
     * @example
     * // Get one PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeriodoMatriculadoFindUniqueArgs>(args: SelectSubset<T, PeriodoMatriculadoFindUniqueArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PeriodoMatriculado that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PeriodoMatriculadoFindUniqueOrThrowArgs} args - Arguments to find a PeriodoMatriculado
     * @example
     * // Get one PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeriodoMatriculadoFindUniqueOrThrowArgs>(args: SelectSubset<T, PeriodoMatriculadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PeriodoMatriculado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoFindFirstArgs} args - Arguments to find a PeriodoMatriculado
     * @example
     * // Get one PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeriodoMatriculadoFindFirstArgs>(args?: SelectSubset<T, PeriodoMatriculadoFindFirstArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PeriodoMatriculado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoFindFirstOrThrowArgs} args - Arguments to find a PeriodoMatriculado
     * @example
     * // Get one PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeriodoMatriculadoFindFirstOrThrowArgs>(args?: SelectSubset<T, PeriodoMatriculadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PeriodoMatriculados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PeriodoMatriculados
     * const periodoMatriculados = await prisma.periodoMatriculado.findMany()
     * 
     * // Get first 10 PeriodoMatriculados
     * const periodoMatriculados = await prisma.periodoMatriculado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodoMatriculadoWithIdOnly = await prisma.periodoMatriculado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PeriodoMatriculadoFindManyArgs>(args?: SelectSubset<T, PeriodoMatriculadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PeriodoMatriculado.
     * @param {PeriodoMatriculadoCreateArgs} args - Arguments to create a PeriodoMatriculado.
     * @example
     * // Create one PeriodoMatriculado
     * const PeriodoMatriculado = await prisma.periodoMatriculado.create({
     *   data: {
     *     // ... data to create a PeriodoMatriculado
     *   }
     * })
     * 
     */
    create<T extends PeriodoMatriculadoCreateArgs>(args: SelectSubset<T, PeriodoMatriculadoCreateArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PeriodoMatriculados.
     * @param {PeriodoMatriculadoCreateManyArgs} args - Arguments to create many PeriodoMatriculados.
     * @example
     * // Create many PeriodoMatriculados
     * const periodoMatriculado = await prisma.periodoMatriculado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeriodoMatriculadoCreateManyArgs>(args?: SelectSubset<T, PeriodoMatriculadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PeriodoMatriculado.
     * @param {PeriodoMatriculadoDeleteArgs} args - Arguments to delete one PeriodoMatriculado.
     * @example
     * // Delete one PeriodoMatriculado
     * const PeriodoMatriculado = await prisma.periodoMatriculado.delete({
     *   where: {
     *     // ... filter to delete one PeriodoMatriculado
     *   }
     * })
     * 
     */
    delete<T extends PeriodoMatriculadoDeleteArgs>(args: SelectSubset<T, PeriodoMatriculadoDeleteArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PeriodoMatriculado.
     * @param {PeriodoMatriculadoUpdateArgs} args - Arguments to update one PeriodoMatriculado.
     * @example
     * // Update one PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeriodoMatriculadoUpdateArgs>(args: SelectSubset<T, PeriodoMatriculadoUpdateArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PeriodoMatriculados.
     * @param {PeriodoMatriculadoDeleteManyArgs} args - Arguments to filter PeriodoMatriculados to delete.
     * @example
     * // Delete a few PeriodoMatriculados
     * const { count } = await prisma.periodoMatriculado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeriodoMatriculadoDeleteManyArgs>(args?: SelectSubset<T, PeriodoMatriculadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PeriodoMatriculados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PeriodoMatriculados
     * const periodoMatriculado = await prisma.periodoMatriculado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeriodoMatriculadoUpdateManyArgs>(args: SelectSubset<T, PeriodoMatriculadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PeriodoMatriculado.
     * @param {PeriodoMatriculadoUpsertArgs} args - Arguments to update or create a PeriodoMatriculado.
     * @example
     * // Update or create a PeriodoMatriculado
     * const periodoMatriculado = await prisma.periodoMatriculado.upsert({
     *   create: {
     *     // ... data to create a PeriodoMatriculado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PeriodoMatriculado we want to update
     *   }
     * })
     */
    upsert<T extends PeriodoMatriculadoUpsertArgs>(args: SelectSubset<T, PeriodoMatriculadoUpsertArgs<ExtArgs>>): Prisma__PeriodoMatriculadoClient<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more PeriodoMatriculados that matches the filter.
     * @param {PeriodoMatriculadoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const periodoMatriculado = await prisma.periodoMatriculado.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PeriodoMatriculadoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PeriodoMatriculado.
     * @param {PeriodoMatriculadoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const periodoMatriculado = await prisma.periodoMatriculado.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PeriodoMatriculadoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PeriodoMatriculados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoCountArgs} args - Arguments to filter PeriodoMatriculados to count.
     * @example
     * // Count the number of PeriodoMatriculados
     * const count = await prisma.periodoMatriculado.count({
     *   where: {
     *     // ... the filter for the PeriodoMatriculados we want to count
     *   }
     * })
    **/
    count<T extends PeriodoMatriculadoCountArgs>(
      args?: Subset<T, PeriodoMatriculadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodoMatriculadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PeriodoMatriculado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodoMatriculadoAggregateArgs>(args: Subset<T, PeriodoMatriculadoAggregateArgs>): Prisma.PrismaPromise<GetPeriodoMatriculadoAggregateType<T>>

    /**
     * Group by PeriodoMatriculado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodoMatriculadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodoMatriculadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodoMatriculadoGroupByArgs['orderBy'] }
        : { orderBy?: PeriodoMatriculadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodoMatriculadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodoMatriculadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PeriodoMatriculado model
   */
  readonly fields: PeriodoMatriculadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PeriodoMatriculado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeriodoMatriculadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends PeriodoMatriculado$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, PeriodoMatriculado$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Pagos<T extends PeriodoMatriculado$PagosArgs<ExtArgs> = {}>(args?: Subset<T, PeriodoMatriculado$PagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findMany"> | Null>
    cursosMatriculados<T extends PeriodoMatriculado$cursosMatriculadosArgs<ExtArgs> = {}>(args?: Subset<T, PeriodoMatriculado$cursosMatriculadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CursoMatriculadoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PeriodoMatriculado model
   */ 
  interface PeriodoMatriculadoFieldRefs {
    readonly id: FieldRef<"PeriodoMatriculado", 'String'>
    readonly semestre: FieldRef<"PeriodoMatriculado", 'Int'>
    readonly periodo: FieldRef<"PeriodoMatriculado", 'String'>
    readonly idUsuario: FieldRef<"PeriodoMatriculado", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PeriodoMatriculado findUnique
   */
  export type PeriodoMatriculadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which PeriodoMatriculado to fetch.
     */
    where: PeriodoMatriculadoWhereUniqueInput
  }

  /**
   * PeriodoMatriculado findUniqueOrThrow
   */
  export type PeriodoMatriculadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which PeriodoMatriculado to fetch.
     */
    where: PeriodoMatriculadoWhereUniqueInput
  }

  /**
   * PeriodoMatriculado findFirst
   */
  export type PeriodoMatriculadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which PeriodoMatriculado to fetch.
     */
    where?: PeriodoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodoMatriculados to fetch.
     */
    orderBy?: PeriodoMatriculadoOrderByWithRelationInput | PeriodoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodoMatriculados.
     */
    cursor?: PeriodoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodoMatriculados.
     */
    distinct?: PeriodoMatriculadoScalarFieldEnum | PeriodoMatriculadoScalarFieldEnum[]
  }

  /**
   * PeriodoMatriculado findFirstOrThrow
   */
  export type PeriodoMatriculadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which PeriodoMatriculado to fetch.
     */
    where?: PeriodoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodoMatriculados to fetch.
     */
    orderBy?: PeriodoMatriculadoOrderByWithRelationInput | PeriodoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodoMatriculados.
     */
    cursor?: PeriodoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodoMatriculados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodoMatriculados.
     */
    distinct?: PeriodoMatriculadoScalarFieldEnum | PeriodoMatriculadoScalarFieldEnum[]
  }

  /**
   * PeriodoMatriculado findMany
   */
  export type PeriodoMatriculadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter, which PeriodoMatriculados to fetch.
     */
    where?: PeriodoMatriculadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodoMatriculados to fetch.
     */
    orderBy?: PeriodoMatriculadoOrderByWithRelationInput | PeriodoMatriculadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PeriodoMatriculados.
     */
    cursor?: PeriodoMatriculadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodoMatriculados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodoMatriculados.
     */
    skip?: number
    distinct?: PeriodoMatriculadoScalarFieldEnum | PeriodoMatriculadoScalarFieldEnum[]
  }

  /**
   * PeriodoMatriculado create
   */
  export type PeriodoMatriculadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * The data needed to create a PeriodoMatriculado.
     */
    data: XOR<PeriodoMatriculadoCreateInput, PeriodoMatriculadoUncheckedCreateInput>
  }

  /**
   * PeriodoMatriculado createMany
   */
  export type PeriodoMatriculadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PeriodoMatriculados.
     */
    data: PeriodoMatriculadoCreateManyInput | PeriodoMatriculadoCreateManyInput[]
  }

  /**
   * PeriodoMatriculado update
   */
  export type PeriodoMatriculadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * The data needed to update a PeriodoMatriculado.
     */
    data: XOR<PeriodoMatriculadoUpdateInput, PeriodoMatriculadoUncheckedUpdateInput>
    /**
     * Choose, which PeriodoMatriculado to update.
     */
    where: PeriodoMatriculadoWhereUniqueInput
  }

  /**
   * PeriodoMatriculado updateMany
   */
  export type PeriodoMatriculadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PeriodoMatriculados.
     */
    data: XOR<PeriodoMatriculadoUpdateManyMutationInput, PeriodoMatriculadoUncheckedUpdateManyInput>
    /**
     * Filter which PeriodoMatriculados to update
     */
    where?: PeriodoMatriculadoWhereInput
  }

  /**
   * PeriodoMatriculado upsert
   */
  export type PeriodoMatriculadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * The filter to search for the PeriodoMatriculado to update in case it exists.
     */
    where: PeriodoMatriculadoWhereUniqueInput
    /**
     * In case the PeriodoMatriculado found by the `where` argument doesn't exist, create a new PeriodoMatriculado with this data.
     */
    create: XOR<PeriodoMatriculadoCreateInput, PeriodoMatriculadoUncheckedCreateInput>
    /**
     * In case the PeriodoMatriculado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeriodoMatriculadoUpdateInput, PeriodoMatriculadoUncheckedUpdateInput>
  }

  /**
   * PeriodoMatriculado delete
   */
  export type PeriodoMatriculadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    /**
     * Filter which PeriodoMatriculado to delete.
     */
    where: PeriodoMatriculadoWhereUniqueInput
  }

  /**
   * PeriodoMatriculado deleteMany
   */
  export type PeriodoMatriculadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodoMatriculados to delete
     */
    where?: PeriodoMatriculadoWhereInput
  }

  /**
   * PeriodoMatriculado findRaw
   */
  export type PeriodoMatriculadoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PeriodoMatriculado aggregateRaw
   */
  export type PeriodoMatriculadoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PeriodoMatriculado.Usuario
   */
  export type PeriodoMatriculado$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * PeriodoMatriculado.Pagos
   */
  export type PeriodoMatriculado$PagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    where?: PagosWhereInput
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    cursor?: PagosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagosScalarFieldEnum | PagosScalarFieldEnum[]
  }

  /**
   * PeriodoMatriculado.cursosMatriculados
   */
  export type PeriodoMatriculado$cursosMatriculadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CursoMatriculado
     */
    select?: CursoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CursoMatriculadoInclude<ExtArgs> | null
    where?: CursoMatriculadoWhereInput
    orderBy?: CursoMatriculadoOrderByWithRelationInput | CursoMatriculadoOrderByWithRelationInput[]
    cursor?: CursoMatriculadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CursoMatriculadoScalarFieldEnum | CursoMatriculadoScalarFieldEnum[]
  }

  /**
   * PeriodoMatriculado without action
   */
  export type PeriodoMatriculadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    email: string | null
    carrera: string | null
    password: string | null
    image: string | null
    emailVerified: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    email: string | null
    carrera: string | null
    password: string | null
    image: string | null
    emailVerified: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    email: number
    carrera: number
    password: number
    image: number
    emailVerified: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    carrera?: true
    password?: true
    image?: true
    emailVerified?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    carrera?: true
    password?: true
    image?: true
    emailVerified?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    carrera?: true
    password?: true
    image?: true
    emailVerified?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    nombre: string
    email: string
    carrera: string
    password: string | null
    image: string | null
    emailVerified: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    email?: boolean
    carrera?: boolean
    password?: boolean
    image?: boolean
    emailVerified?: boolean
    TramitesRealizados?: boolean | Usuario$TramitesRealizadosArgs<ExtArgs>
    ServiciosUtilizados?: boolean | Usuario$ServiciosUtilizadosArgs<ExtArgs>
    Pagos?: boolean | Usuario$PagosArgs<ExtArgs>
    PeriodoMatriculado?: boolean | Usuario$PeriodoMatriculadoArgs<ExtArgs>
    accounts?: boolean | Usuario$accountsArgs<ExtArgs>
    sessions?: boolean | Usuario$sessionsArgs<ExtArgs>
    events?: boolean | Usuario$eventsArgs<ExtArgs>
    tasks?: boolean | Usuario$tasksArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    email?: boolean
    carrera?: boolean
    password?: boolean
    image?: boolean
    emailVerified?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TramitesRealizados?: boolean | Usuario$TramitesRealizadosArgs<ExtArgs>
    ServiciosUtilizados?: boolean | Usuario$ServiciosUtilizadosArgs<ExtArgs>
    Pagos?: boolean | Usuario$PagosArgs<ExtArgs>
    PeriodoMatriculado?: boolean | Usuario$PeriodoMatriculadoArgs<ExtArgs>
    accounts?: boolean | Usuario$accountsArgs<ExtArgs>
    sessions?: boolean | Usuario$sessionsArgs<ExtArgs>
    events?: boolean | Usuario$eventsArgs<ExtArgs>
    tasks?: boolean | Usuario$tasksArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      TramitesRealizados: Prisma.$TramitesRealizadosPayload<ExtArgs>[]
      ServiciosUtilizados: Prisma.$ServiciosUtilizadosPayload<ExtArgs>[]
      Pagos: Prisma.$PagosPayload<ExtArgs>[]
      PeriodoMatriculado: Prisma.$PeriodoMatriculadoPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      email: string
      carrera: string
      password: string | null
      image: string | null
      emailVerified: Date | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * @param {UsuarioFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const usuario = await prisma.usuario.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UsuarioFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Usuario.
     * @param {UsuarioAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const usuario = await prisma.usuario.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UsuarioAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TramitesRealizados<T extends Usuario$TramitesRealizadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$TramitesRealizadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findMany"> | Null>
    ServiciosUtilizados<T extends Usuario$ServiciosUtilizadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$ServiciosUtilizadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findMany"> | Null>
    Pagos<T extends Usuario$PagosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$PagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagosPayload<ExtArgs>, T, "findMany"> | Null>
    PeriodoMatriculado<T extends Usuario$PeriodoMatriculadoArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$PeriodoMatriculadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodoMatriculadoPayload<ExtArgs>, T, "findMany"> | Null>
    accounts<T extends Usuario$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends Usuario$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Usuario$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Usuario$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly carrera: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly image: FieldRef<"Usuario", 'String'>
    readonly emailVerified: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario findRaw
   */
  export type UsuarioFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Usuario aggregateRaw
   */
  export type UsuarioAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Usuario.TramitesRealizados
   */
  export type Usuario$TramitesRealizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    where?: TramitesRealizadosWhereInput
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    cursor?: TramitesRealizadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TramitesRealizadosScalarFieldEnum | TramitesRealizadosScalarFieldEnum[]
  }

  /**
   * Usuario.ServiciosUtilizados
   */
  export type Usuario$ServiciosUtilizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    where?: ServiciosUtilizadosWhereInput
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    cursor?: ServiciosUtilizadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiciosUtilizadosScalarFieldEnum | ServiciosUtilizadosScalarFieldEnum[]
  }

  /**
   * Usuario.Pagos
   */
  export type Usuario$PagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagos
     */
    select?: PagosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagosInclude<ExtArgs> | null
    where?: PagosWhereInput
    orderBy?: PagosOrderByWithRelationInput | PagosOrderByWithRelationInput[]
    cursor?: PagosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagosScalarFieldEnum | PagosScalarFieldEnum[]
  }

  /**
   * Usuario.PeriodoMatriculado
   */
  export type Usuario$PeriodoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodoMatriculado
     */
    select?: PeriodoMatriculadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodoMatriculadoInclude<ExtArgs> | null
    where?: PeriodoMatriculadoWhereInput
    orderBy?: PeriodoMatriculadoOrderByWithRelationInput | PeriodoMatriculadoOrderByWithRelationInput[]
    cursor?: PeriodoMatriculadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PeriodoMatriculadoScalarFieldEnum | PeriodoMatriculadoScalarFieldEnum[]
  }

  /**
   * Usuario.accounts
   */
  export type Usuario$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Usuario.sessions
   */
  export type Usuario$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Usuario.events
   */
  export type Usuario$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Usuario.tasks
   */
  export type Usuario$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    type: string | null
    access_token: string | null
    refresh_token: string | null
    expires_at: number | null
    scope: string | null
    id_token: string | null
    token_type: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    providerAccountId: string | null
    type: string | null
    access_token: string | null
    refresh_token: string | null
    expires_at: number | null
    scope: string | null
    id_token: string | null
    token_type: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    providerAccountId: number
    type: number
    access_token: number
    refresh_token: number
    expires_at: number
    scope: number
    id_token: number
    token_type: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    type?: true
    access_token?: true
    refresh_token?: true
    expires_at?: true
    scope?: true
    id_token?: true
    token_type?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    type?: true
    access_token?: true
    refresh_token?: true
    expires_at?: true
    scope?: true
    id_token?: true
    token_type?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    providerAccountId?: true
    type?: true
    access_token?: true
    refresh_token?: true
    expires_at?: true
    scope?: true
    id_token?: true
    token_type?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    provider: string
    providerAccountId: string
    type: string
    access_token: string | null
    refresh_token: string | null
    expires_at: number | null
    scope: string | null
    id_token: string | null
    token_type: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    type?: boolean
    access_token?: boolean
    refresh_token?: boolean
    expires_at?: boolean
    scope?: boolean
    id_token?: boolean
    token_type?: boolean
    user?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>


  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    providerAccountId?: boolean
    type?: boolean
    access_token?: boolean
    refresh_token?: boolean
    expires_at?: boolean
    scope?: boolean
    id_token?: boolean
    token_type?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      providerAccountId: string
      type: string
      access_token: string | null
      refresh_token: string | null
      expires_at: number | null
      scope: string | null
      id_token: string | null
      token_type: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AccountFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AccountAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly token_type: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model TramitesRealizados
   */

  export type AggregateTramitesRealizados = {
    _count: TramitesRealizadosCountAggregateOutputType | null
    _min: TramitesRealizadosMinAggregateOutputType | null
    _max: TramitesRealizadosMaxAggregateOutputType | null
  }

  export type TramitesRealizadosMinAggregateOutputType = {
    id: string | null
    idTramite: string | null
    idUsuario: string | null
    fechas: Date | null
    estado: string | null
    adicional: string | null
  }

  export type TramitesRealizadosMaxAggregateOutputType = {
    id: string | null
    idTramite: string | null
    idUsuario: string | null
    fechas: Date | null
    estado: string | null
    adicional: string | null
  }

  export type TramitesRealizadosCountAggregateOutputType = {
    id: number
    idTramite: number
    idUsuario: number
    fechas: number
    documentos: number
    estado: number
    adicional: number
    _all: number
  }


  export type TramitesRealizadosMinAggregateInputType = {
    id?: true
    idTramite?: true
    idUsuario?: true
    fechas?: true
    estado?: true
    adicional?: true
  }

  export type TramitesRealizadosMaxAggregateInputType = {
    id?: true
    idTramite?: true
    idUsuario?: true
    fechas?: true
    estado?: true
    adicional?: true
  }

  export type TramitesRealizadosCountAggregateInputType = {
    id?: true
    idTramite?: true
    idUsuario?: true
    fechas?: true
    documentos?: true
    estado?: true
    adicional?: true
    _all?: true
  }

  export type TramitesRealizadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TramitesRealizados to aggregate.
     */
    where?: TramitesRealizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TramitesRealizados to fetch.
     */
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TramitesRealizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TramitesRealizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TramitesRealizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TramitesRealizados
    **/
    _count?: true | TramitesRealizadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TramitesRealizadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TramitesRealizadosMaxAggregateInputType
  }

  export type GetTramitesRealizadosAggregateType<T extends TramitesRealizadosAggregateArgs> = {
        [P in keyof T & keyof AggregateTramitesRealizados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTramitesRealizados[P]>
      : GetScalarType<T[P], AggregateTramitesRealizados[P]>
  }




  export type TramitesRealizadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TramitesRealizadosWhereInput
    orderBy?: TramitesRealizadosOrderByWithAggregationInput | TramitesRealizadosOrderByWithAggregationInput[]
    by: TramitesRealizadosScalarFieldEnum[] | TramitesRealizadosScalarFieldEnum
    having?: TramitesRealizadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TramitesRealizadosCountAggregateInputType | true
    _min?: TramitesRealizadosMinAggregateInputType
    _max?: TramitesRealizadosMaxAggregateInputType
  }

  export type TramitesRealizadosGroupByOutputType = {
    id: string
    idTramite: string | null
    idUsuario: string | null
    fechas: Date | null
    documentos: string[]
    estado: string | null
    adicional: string | null
    _count: TramitesRealizadosCountAggregateOutputType | null
    _min: TramitesRealizadosMinAggregateOutputType | null
    _max: TramitesRealizadosMaxAggregateOutputType | null
  }

  type GetTramitesRealizadosGroupByPayload<T extends TramitesRealizadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TramitesRealizadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TramitesRealizadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TramitesRealizadosGroupByOutputType[P]>
            : GetScalarType<T[P], TramitesRealizadosGroupByOutputType[P]>
        }
      >
    >


  export type TramitesRealizadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idTramite?: boolean
    idUsuario?: boolean
    fechas?: boolean
    documentos?: boolean
    estado?: boolean
    adicional?: boolean
    tramite?: boolean | TramitesRealizados$tramiteArgs<ExtArgs>
    Usuario?: boolean | TramitesRealizados$UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["tramitesRealizados"]>


  export type TramitesRealizadosSelectScalar = {
    id?: boolean
    idTramite?: boolean
    idUsuario?: boolean
    fechas?: boolean
    documentos?: boolean
    estado?: boolean
    adicional?: boolean
  }

  export type TramitesRealizadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tramite?: boolean | TramitesRealizados$tramiteArgs<ExtArgs>
    Usuario?: boolean | TramitesRealizados$UsuarioArgs<ExtArgs>
  }

  export type $TramitesRealizadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TramitesRealizados"
    objects: {
      tramite: Prisma.$TramitesPayload<ExtArgs> | null
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idTramite: string | null
      idUsuario: string | null
      fechas: Date | null
      documentos: string[]
      estado: string | null
      adicional: string | null
    }, ExtArgs["result"]["tramitesRealizados"]>
    composites: {}
  }

  type TramitesRealizadosGetPayload<S extends boolean | null | undefined | TramitesRealizadosDefaultArgs> = $Result.GetResult<Prisma.$TramitesRealizadosPayload, S>

  type TramitesRealizadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TramitesRealizadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TramitesRealizadosCountAggregateInputType | true
    }

  export interface TramitesRealizadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TramitesRealizados'], meta: { name: 'TramitesRealizados' } }
    /**
     * Find zero or one TramitesRealizados that matches the filter.
     * @param {TramitesRealizadosFindUniqueArgs} args - Arguments to find a TramitesRealizados
     * @example
     * // Get one TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TramitesRealizadosFindUniqueArgs>(args: SelectSubset<T, TramitesRealizadosFindUniqueArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TramitesRealizados that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TramitesRealizadosFindUniqueOrThrowArgs} args - Arguments to find a TramitesRealizados
     * @example
     * // Get one TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TramitesRealizadosFindUniqueOrThrowArgs>(args: SelectSubset<T, TramitesRealizadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TramitesRealizados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosFindFirstArgs} args - Arguments to find a TramitesRealizados
     * @example
     * // Get one TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TramitesRealizadosFindFirstArgs>(args?: SelectSubset<T, TramitesRealizadosFindFirstArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TramitesRealizados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosFindFirstOrThrowArgs} args - Arguments to find a TramitesRealizados
     * @example
     * // Get one TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TramitesRealizadosFindFirstOrThrowArgs>(args?: SelectSubset<T, TramitesRealizadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TramitesRealizados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findMany()
     * 
     * // Get first 10 TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tramitesRealizadosWithIdOnly = await prisma.tramitesRealizados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TramitesRealizadosFindManyArgs>(args?: SelectSubset<T, TramitesRealizadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TramitesRealizados.
     * @param {TramitesRealizadosCreateArgs} args - Arguments to create a TramitesRealizados.
     * @example
     * // Create one TramitesRealizados
     * const TramitesRealizados = await prisma.tramitesRealizados.create({
     *   data: {
     *     // ... data to create a TramitesRealizados
     *   }
     * })
     * 
     */
    create<T extends TramitesRealizadosCreateArgs>(args: SelectSubset<T, TramitesRealizadosCreateArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TramitesRealizados.
     * @param {TramitesRealizadosCreateManyArgs} args - Arguments to create many TramitesRealizados.
     * @example
     * // Create many TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TramitesRealizadosCreateManyArgs>(args?: SelectSubset<T, TramitesRealizadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TramitesRealizados.
     * @param {TramitesRealizadosDeleteArgs} args - Arguments to delete one TramitesRealizados.
     * @example
     * // Delete one TramitesRealizados
     * const TramitesRealizados = await prisma.tramitesRealizados.delete({
     *   where: {
     *     // ... filter to delete one TramitesRealizados
     *   }
     * })
     * 
     */
    delete<T extends TramitesRealizadosDeleteArgs>(args: SelectSubset<T, TramitesRealizadosDeleteArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TramitesRealizados.
     * @param {TramitesRealizadosUpdateArgs} args - Arguments to update one TramitesRealizados.
     * @example
     * // Update one TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TramitesRealizadosUpdateArgs>(args: SelectSubset<T, TramitesRealizadosUpdateArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TramitesRealizados.
     * @param {TramitesRealizadosDeleteManyArgs} args - Arguments to filter TramitesRealizados to delete.
     * @example
     * // Delete a few TramitesRealizados
     * const { count } = await prisma.tramitesRealizados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TramitesRealizadosDeleteManyArgs>(args?: SelectSubset<T, TramitesRealizadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TramitesRealizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TramitesRealizadosUpdateManyArgs>(args: SelectSubset<T, TramitesRealizadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TramitesRealizados.
     * @param {TramitesRealizadosUpsertArgs} args - Arguments to update or create a TramitesRealizados.
     * @example
     * // Update or create a TramitesRealizados
     * const tramitesRealizados = await prisma.tramitesRealizados.upsert({
     *   create: {
     *     // ... data to create a TramitesRealizados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TramitesRealizados we want to update
     *   }
     * })
     */
    upsert<T extends TramitesRealizadosUpsertArgs>(args: SelectSubset<T, TramitesRealizadosUpsertArgs<ExtArgs>>): Prisma__TramitesRealizadosClient<$Result.GetResult<Prisma.$TramitesRealizadosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TramitesRealizados that matches the filter.
     * @param {TramitesRealizadosFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tramitesRealizados = await prisma.tramitesRealizados.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TramitesRealizadosFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TramitesRealizados.
     * @param {TramitesRealizadosAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tramitesRealizados = await prisma.tramitesRealizados.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TramitesRealizadosAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TramitesRealizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosCountArgs} args - Arguments to filter TramitesRealizados to count.
     * @example
     * // Count the number of TramitesRealizados
     * const count = await prisma.tramitesRealizados.count({
     *   where: {
     *     // ... the filter for the TramitesRealizados we want to count
     *   }
     * })
    **/
    count<T extends TramitesRealizadosCountArgs>(
      args?: Subset<T, TramitesRealizadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TramitesRealizadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TramitesRealizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TramitesRealizadosAggregateArgs>(args: Subset<T, TramitesRealizadosAggregateArgs>): Prisma.PrismaPromise<GetTramitesRealizadosAggregateType<T>>

    /**
     * Group by TramitesRealizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TramitesRealizadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TramitesRealizadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TramitesRealizadosGroupByArgs['orderBy'] }
        : { orderBy?: TramitesRealizadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TramitesRealizadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTramitesRealizadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TramitesRealizados model
   */
  readonly fields: TramitesRealizadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TramitesRealizados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TramitesRealizadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tramite<T extends TramitesRealizados$tramiteArgs<ExtArgs> = {}>(args?: Subset<T, TramitesRealizados$tramiteArgs<ExtArgs>>): Prisma__TramitesClient<$Result.GetResult<Prisma.$TramitesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Usuario<T extends TramitesRealizados$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, TramitesRealizados$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TramitesRealizados model
   */ 
  interface TramitesRealizadosFieldRefs {
    readonly id: FieldRef<"TramitesRealizados", 'String'>
    readonly idTramite: FieldRef<"TramitesRealizados", 'String'>
    readonly idUsuario: FieldRef<"TramitesRealizados", 'String'>
    readonly fechas: FieldRef<"TramitesRealizados", 'DateTime'>
    readonly documentos: FieldRef<"TramitesRealizados", 'String[]'>
    readonly estado: FieldRef<"TramitesRealizados", 'String'>
    readonly adicional: FieldRef<"TramitesRealizados", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TramitesRealizados findUnique
   */
  export type TramitesRealizadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter, which TramitesRealizados to fetch.
     */
    where: TramitesRealizadosWhereUniqueInput
  }

  /**
   * TramitesRealizados findUniqueOrThrow
   */
  export type TramitesRealizadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter, which TramitesRealizados to fetch.
     */
    where: TramitesRealizadosWhereUniqueInput
  }

  /**
   * TramitesRealizados findFirst
   */
  export type TramitesRealizadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter, which TramitesRealizados to fetch.
     */
    where?: TramitesRealizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TramitesRealizados to fetch.
     */
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TramitesRealizados.
     */
    cursor?: TramitesRealizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TramitesRealizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TramitesRealizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TramitesRealizados.
     */
    distinct?: TramitesRealizadosScalarFieldEnum | TramitesRealizadosScalarFieldEnum[]
  }

  /**
   * TramitesRealizados findFirstOrThrow
   */
  export type TramitesRealizadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter, which TramitesRealizados to fetch.
     */
    where?: TramitesRealizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TramitesRealizados to fetch.
     */
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TramitesRealizados.
     */
    cursor?: TramitesRealizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TramitesRealizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TramitesRealizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TramitesRealizados.
     */
    distinct?: TramitesRealizadosScalarFieldEnum | TramitesRealizadosScalarFieldEnum[]
  }

  /**
   * TramitesRealizados findMany
   */
  export type TramitesRealizadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter, which TramitesRealizados to fetch.
     */
    where?: TramitesRealizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TramitesRealizados to fetch.
     */
    orderBy?: TramitesRealizadosOrderByWithRelationInput | TramitesRealizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TramitesRealizados.
     */
    cursor?: TramitesRealizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TramitesRealizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TramitesRealizados.
     */
    skip?: number
    distinct?: TramitesRealizadosScalarFieldEnum | TramitesRealizadosScalarFieldEnum[]
  }

  /**
   * TramitesRealizados create
   */
  export type TramitesRealizadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * The data needed to create a TramitesRealizados.
     */
    data?: XOR<TramitesRealizadosCreateInput, TramitesRealizadosUncheckedCreateInput>
  }

  /**
   * TramitesRealizados createMany
   */
  export type TramitesRealizadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TramitesRealizados.
     */
    data: TramitesRealizadosCreateManyInput | TramitesRealizadosCreateManyInput[]
  }

  /**
   * TramitesRealizados update
   */
  export type TramitesRealizadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * The data needed to update a TramitesRealizados.
     */
    data: XOR<TramitesRealizadosUpdateInput, TramitesRealizadosUncheckedUpdateInput>
    /**
     * Choose, which TramitesRealizados to update.
     */
    where: TramitesRealizadosWhereUniqueInput
  }

  /**
   * TramitesRealizados updateMany
   */
  export type TramitesRealizadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TramitesRealizados.
     */
    data: XOR<TramitesRealizadosUpdateManyMutationInput, TramitesRealizadosUncheckedUpdateManyInput>
    /**
     * Filter which TramitesRealizados to update
     */
    where?: TramitesRealizadosWhereInput
  }

  /**
   * TramitesRealizados upsert
   */
  export type TramitesRealizadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * The filter to search for the TramitesRealizados to update in case it exists.
     */
    where: TramitesRealizadosWhereUniqueInput
    /**
     * In case the TramitesRealizados found by the `where` argument doesn't exist, create a new TramitesRealizados with this data.
     */
    create: XOR<TramitesRealizadosCreateInput, TramitesRealizadosUncheckedCreateInput>
    /**
     * In case the TramitesRealizados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TramitesRealizadosUpdateInput, TramitesRealizadosUncheckedUpdateInput>
  }

  /**
   * TramitesRealizados delete
   */
  export type TramitesRealizadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
    /**
     * Filter which TramitesRealizados to delete.
     */
    where: TramitesRealizadosWhereUniqueInput
  }

  /**
   * TramitesRealizados deleteMany
   */
  export type TramitesRealizadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TramitesRealizados to delete
     */
    where?: TramitesRealizadosWhereInput
  }

  /**
   * TramitesRealizados findRaw
   */
  export type TramitesRealizadosFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TramitesRealizados aggregateRaw
   */
  export type TramitesRealizadosAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TramitesRealizados.tramite
   */
  export type TramitesRealizados$tramiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tramites
     */
    select?: TramitesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesInclude<ExtArgs> | null
    where?: TramitesWhereInput
  }

  /**
   * TramitesRealizados.Usuario
   */
  export type TramitesRealizados$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * TramitesRealizados without action
   */
  export type TramitesRealizadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TramitesRealizados
     */
    select?: TramitesRealizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TramitesRealizadosInclude<ExtArgs> | null
  }


  /**
   * Model ServiciosUtilizados
   */

  export type AggregateServiciosUtilizados = {
    _count: ServiciosUtilizadosCountAggregateOutputType | null
    _min: ServiciosUtilizadosMinAggregateOutputType | null
    _max: ServiciosUtilizadosMaxAggregateOutputType | null
  }

  export type ServiciosUtilizadosMinAggregateOutputType = {
    id: string | null
    idServicio: string | null
    idUsuario: string | null
    fechaRegistro: Date | null
    horarioElegido: Date | null
    estado: string | null
  }

  export type ServiciosUtilizadosMaxAggregateOutputType = {
    id: string | null
    idServicio: string | null
    idUsuario: string | null
    fechaRegistro: Date | null
    horarioElegido: Date | null
    estado: string | null
  }

  export type ServiciosUtilizadosCountAggregateOutputType = {
    id: number
    idServicio: number
    idUsuario: number
    fechaRegistro: number
    horarioElegido: number
    estado: number
    _all: number
  }


  export type ServiciosUtilizadosMinAggregateInputType = {
    id?: true
    idServicio?: true
    idUsuario?: true
    fechaRegistro?: true
    horarioElegido?: true
    estado?: true
  }

  export type ServiciosUtilizadosMaxAggregateInputType = {
    id?: true
    idServicio?: true
    idUsuario?: true
    fechaRegistro?: true
    horarioElegido?: true
    estado?: true
  }

  export type ServiciosUtilizadosCountAggregateInputType = {
    id?: true
    idServicio?: true
    idUsuario?: true
    fechaRegistro?: true
    horarioElegido?: true
    estado?: true
    _all?: true
  }

  export type ServiciosUtilizadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiciosUtilizados to aggregate.
     */
    where?: ServiciosUtilizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiciosUtilizados to fetch.
     */
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiciosUtilizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiciosUtilizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiciosUtilizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiciosUtilizados
    **/
    _count?: true | ServiciosUtilizadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiciosUtilizadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiciosUtilizadosMaxAggregateInputType
  }

  export type GetServiciosUtilizadosAggregateType<T extends ServiciosUtilizadosAggregateArgs> = {
        [P in keyof T & keyof AggregateServiciosUtilizados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiciosUtilizados[P]>
      : GetScalarType<T[P], AggregateServiciosUtilizados[P]>
  }




  export type ServiciosUtilizadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiciosUtilizadosWhereInput
    orderBy?: ServiciosUtilizadosOrderByWithAggregationInput | ServiciosUtilizadosOrderByWithAggregationInput[]
    by: ServiciosUtilizadosScalarFieldEnum[] | ServiciosUtilizadosScalarFieldEnum
    having?: ServiciosUtilizadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiciosUtilizadosCountAggregateInputType | true
    _min?: ServiciosUtilizadosMinAggregateInputType
    _max?: ServiciosUtilizadosMaxAggregateInputType
  }

  export type ServiciosUtilizadosGroupByOutputType = {
    id: string
    idServicio: string | null
    idUsuario: string | null
    fechaRegistro: Date | null
    horarioElegido: Date | null
    estado: string | null
    _count: ServiciosUtilizadosCountAggregateOutputType | null
    _min: ServiciosUtilizadosMinAggregateOutputType | null
    _max: ServiciosUtilizadosMaxAggregateOutputType | null
  }

  type GetServiciosUtilizadosGroupByPayload<T extends ServiciosUtilizadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiciosUtilizadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiciosUtilizadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiciosUtilizadosGroupByOutputType[P]>
            : GetScalarType<T[P], ServiciosUtilizadosGroupByOutputType[P]>
        }
      >
    >


  export type ServiciosUtilizadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idServicio?: boolean
    idUsuario?: boolean
    fechaRegistro?: boolean
    horarioElegido?: boolean
    estado?: boolean
    servicio?: boolean | ServiciosUtilizados$servicioArgs<ExtArgs>
    Usuario?: boolean | ServiciosUtilizados$UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["serviciosUtilizados"]>


  export type ServiciosUtilizadosSelectScalar = {
    id?: boolean
    idServicio?: boolean
    idUsuario?: boolean
    fechaRegistro?: boolean
    horarioElegido?: boolean
    estado?: boolean
  }

  export type ServiciosUtilizadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | ServiciosUtilizados$servicioArgs<ExtArgs>
    Usuario?: boolean | ServiciosUtilizados$UsuarioArgs<ExtArgs>
  }

  export type $ServiciosUtilizadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiciosUtilizados"
    objects: {
      servicio: Prisma.$ServiciosPayload<ExtArgs> | null
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idServicio: string | null
      idUsuario: string | null
      fechaRegistro: Date | null
      horarioElegido: Date | null
      estado: string | null
    }, ExtArgs["result"]["serviciosUtilizados"]>
    composites: {}
  }

  type ServiciosUtilizadosGetPayload<S extends boolean | null | undefined | ServiciosUtilizadosDefaultArgs> = $Result.GetResult<Prisma.$ServiciosUtilizadosPayload, S>

  type ServiciosUtilizadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiciosUtilizadosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiciosUtilizadosCountAggregateInputType | true
    }

  export interface ServiciosUtilizadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiciosUtilizados'], meta: { name: 'ServiciosUtilizados' } }
    /**
     * Find zero or one ServiciosUtilizados that matches the filter.
     * @param {ServiciosUtilizadosFindUniqueArgs} args - Arguments to find a ServiciosUtilizados
     * @example
     * // Get one ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiciosUtilizadosFindUniqueArgs>(args: SelectSubset<T, ServiciosUtilizadosFindUniqueArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiciosUtilizados that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiciosUtilizadosFindUniqueOrThrowArgs} args - Arguments to find a ServiciosUtilizados
     * @example
     * // Get one ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiciosUtilizadosFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiciosUtilizadosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiciosUtilizados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosFindFirstArgs} args - Arguments to find a ServiciosUtilizados
     * @example
     * // Get one ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiciosUtilizadosFindFirstArgs>(args?: SelectSubset<T, ServiciosUtilizadosFindFirstArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiciosUtilizados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosFindFirstOrThrowArgs} args - Arguments to find a ServiciosUtilizados
     * @example
     * // Get one ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiciosUtilizadosFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiciosUtilizadosFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiciosUtilizados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findMany()
     * 
     * // Get first 10 ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviciosUtilizadosWithIdOnly = await prisma.serviciosUtilizados.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiciosUtilizadosFindManyArgs>(args?: SelectSubset<T, ServiciosUtilizadosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiciosUtilizados.
     * @param {ServiciosUtilizadosCreateArgs} args - Arguments to create a ServiciosUtilizados.
     * @example
     * // Create one ServiciosUtilizados
     * const ServiciosUtilizados = await prisma.serviciosUtilizados.create({
     *   data: {
     *     // ... data to create a ServiciosUtilizados
     *   }
     * })
     * 
     */
    create<T extends ServiciosUtilizadosCreateArgs>(args: SelectSubset<T, ServiciosUtilizadosCreateArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiciosUtilizados.
     * @param {ServiciosUtilizadosCreateManyArgs} args - Arguments to create many ServiciosUtilizados.
     * @example
     * // Create many ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiciosUtilizadosCreateManyArgs>(args?: SelectSubset<T, ServiciosUtilizadosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiciosUtilizados.
     * @param {ServiciosUtilizadosDeleteArgs} args - Arguments to delete one ServiciosUtilizados.
     * @example
     * // Delete one ServiciosUtilizados
     * const ServiciosUtilizados = await prisma.serviciosUtilizados.delete({
     *   where: {
     *     // ... filter to delete one ServiciosUtilizados
     *   }
     * })
     * 
     */
    delete<T extends ServiciosUtilizadosDeleteArgs>(args: SelectSubset<T, ServiciosUtilizadosDeleteArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiciosUtilizados.
     * @param {ServiciosUtilizadosUpdateArgs} args - Arguments to update one ServiciosUtilizados.
     * @example
     * // Update one ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiciosUtilizadosUpdateArgs>(args: SelectSubset<T, ServiciosUtilizadosUpdateArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiciosUtilizados.
     * @param {ServiciosUtilizadosDeleteManyArgs} args - Arguments to filter ServiciosUtilizados to delete.
     * @example
     * // Delete a few ServiciosUtilizados
     * const { count } = await prisma.serviciosUtilizados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiciosUtilizadosDeleteManyArgs>(args?: SelectSubset<T, ServiciosUtilizadosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiciosUtilizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiciosUtilizadosUpdateManyArgs>(args: SelectSubset<T, ServiciosUtilizadosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiciosUtilizados.
     * @param {ServiciosUtilizadosUpsertArgs} args - Arguments to update or create a ServiciosUtilizados.
     * @example
     * // Update or create a ServiciosUtilizados
     * const serviciosUtilizados = await prisma.serviciosUtilizados.upsert({
     *   create: {
     *     // ... data to create a ServiciosUtilizados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiciosUtilizados we want to update
     *   }
     * })
     */
    upsert<T extends ServiciosUtilizadosUpsertArgs>(args: SelectSubset<T, ServiciosUtilizadosUpsertArgs<ExtArgs>>): Prisma__ServiciosUtilizadosClient<$Result.GetResult<Prisma.$ServiciosUtilizadosPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ServiciosUtilizados that matches the filter.
     * @param {ServiciosUtilizadosFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviciosUtilizados = await prisma.serviciosUtilizados.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ServiciosUtilizadosFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiciosUtilizados.
     * @param {ServiciosUtilizadosAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviciosUtilizados = await prisma.serviciosUtilizados.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiciosUtilizadosAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiciosUtilizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosCountArgs} args - Arguments to filter ServiciosUtilizados to count.
     * @example
     * // Count the number of ServiciosUtilizados
     * const count = await prisma.serviciosUtilizados.count({
     *   where: {
     *     // ... the filter for the ServiciosUtilizados we want to count
     *   }
     * })
    **/
    count<T extends ServiciosUtilizadosCountArgs>(
      args?: Subset<T, ServiciosUtilizadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiciosUtilizadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiciosUtilizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiciosUtilizadosAggregateArgs>(args: Subset<T, ServiciosUtilizadosAggregateArgs>): Prisma.PrismaPromise<GetServiciosUtilizadosAggregateType<T>>

    /**
     * Group by ServiciosUtilizados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiciosUtilizadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiciosUtilizadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiciosUtilizadosGroupByArgs['orderBy'] }
        : { orderBy?: ServiciosUtilizadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiciosUtilizadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiciosUtilizadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiciosUtilizados model
   */
  readonly fields: ServiciosUtilizadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiciosUtilizados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiciosUtilizadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends ServiciosUtilizados$servicioArgs<ExtArgs> = {}>(args?: Subset<T, ServiciosUtilizados$servicioArgs<ExtArgs>>): Prisma__ServiciosClient<$Result.GetResult<Prisma.$ServiciosPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Usuario<T extends ServiciosUtilizados$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, ServiciosUtilizados$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiciosUtilizados model
   */ 
  interface ServiciosUtilizadosFieldRefs {
    readonly id: FieldRef<"ServiciosUtilizados", 'String'>
    readonly idServicio: FieldRef<"ServiciosUtilizados", 'String'>
    readonly idUsuario: FieldRef<"ServiciosUtilizados", 'String'>
    readonly fechaRegistro: FieldRef<"ServiciosUtilizados", 'DateTime'>
    readonly horarioElegido: FieldRef<"ServiciosUtilizados", 'DateTime'>
    readonly estado: FieldRef<"ServiciosUtilizados", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiciosUtilizados findUnique
   */
  export type ServiciosUtilizadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter, which ServiciosUtilizados to fetch.
     */
    where: ServiciosUtilizadosWhereUniqueInput
  }

  /**
   * ServiciosUtilizados findUniqueOrThrow
   */
  export type ServiciosUtilizadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter, which ServiciosUtilizados to fetch.
     */
    where: ServiciosUtilizadosWhereUniqueInput
  }

  /**
   * ServiciosUtilizados findFirst
   */
  export type ServiciosUtilizadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter, which ServiciosUtilizados to fetch.
     */
    where?: ServiciosUtilizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiciosUtilizados to fetch.
     */
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiciosUtilizados.
     */
    cursor?: ServiciosUtilizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiciosUtilizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiciosUtilizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiciosUtilizados.
     */
    distinct?: ServiciosUtilizadosScalarFieldEnum | ServiciosUtilizadosScalarFieldEnum[]
  }

  /**
   * ServiciosUtilizados findFirstOrThrow
   */
  export type ServiciosUtilizadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter, which ServiciosUtilizados to fetch.
     */
    where?: ServiciosUtilizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiciosUtilizados to fetch.
     */
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiciosUtilizados.
     */
    cursor?: ServiciosUtilizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiciosUtilizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiciosUtilizados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiciosUtilizados.
     */
    distinct?: ServiciosUtilizadosScalarFieldEnum | ServiciosUtilizadosScalarFieldEnum[]
  }

  /**
   * ServiciosUtilizados findMany
   */
  export type ServiciosUtilizadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter, which ServiciosUtilizados to fetch.
     */
    where?: ServiciosUtilizadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiciosUtilizados to fetch.
     */
    orderBy?: ServiciosUtilizadosOrderByWithRelationInput | ServiciosUtilizadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiciosUtilizados.
     */
    cursor?: ServiciosUtilizadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiciosUtilizados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiciosUtilizados.
     */
    skip?: number
    distinct?: ServiciosUtilizadosScalarFieldEnum | ServiciosUtilizadosScalarFieldEnum[]
  }

  /**
   * ServiciosUtilizados create
   */
  export type ServiciosUtilizadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiciosUtilizados.
     */
    data?: XOR<ServiciosUtilizadosCreateInput, ServiciosUtilizadosUncheckedCreateInput>
  }

  /**
   * ServiciosUtilizados createMany
   */
  export type ServiciosUtilizadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiciosUtilizados.
     */
    data: ServiciosUtilizadosCreateManyInput | ServiciosUtilizadosCreateManyInput[]
  }

  /**
   * ServiciosUtilizados update
   */
  export type ServiciosUtilizadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiciosUtilizados.
     */
    data: XOR<ServiciosUtilizadosUpdateInput, ServiciosUtilizadosUncheckedUpdateInput>
    /**
     * Choose, which ServiciosUtilizados to update.
     */
    where: ServiciosUtilizadosWhereUniqueInput
  }

  /**
   * ServiciosUtilizados updateMany
   */
  export type ServiciosUtilizadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiciosUtilizados.
     */
    data: XOR<ServiciosUtilizadosUpdateManyMutationInput, ServiciosUtilizadosUncheckedUpdateManyInput>
    /**
     * Filter which ServiciosUtilizados to update
     */
    where?: ServiciosUtilizadosWhereInput
  }

  /**
   * ServiciosUtilizados upsert
   */
  export type ServiciosUtilizadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiciosUtilizados to update in case it exists.
     */
    where: ServiciosUtilizadosWhereUniqueInput
    /**
     * In case the ServiciosUtilizados found by the `where` argument doesn't exist, create a new ServiciosUtilizados with this data.
     */
    create: XOR<ServiciosUtilizadosCreateInput, ServiciosUtilizadosUncheckedCreateInput>
    /**
     * In case the ServiciosUtilizados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiciosUtilizadosUpdateInput, ServiciosUtilizadosUncheckedUpdateInput>
  }

  /**
   * ServiciosUtilizados delete
   */
  export type ServiciosUtilizadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
    /**
     * Filter which ServiciosUtilizados to delete.
     */
    where: ServiciosUtilizadosWhereUniqueInput
  }

  /**
   * ServiciosUtilizados deleteMany
   */
  export type ServiciosUtilizadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiciosUtilizados to delete
     */
    where?: ServiciosUtilizadosWhereInput
  }

  /**
   * ServiciosUtilizados findRaw
   */
  export type ServiciosUtilizadosFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiciosUtilizados aggregateRaw
   */
  export type ServiciosUtilizadosAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiciosUtilizados.servicio
   */
  export type ServiciosUtilizados$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicios
     */
    select?: ServiciosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosInclude<ExtArgs> | null
    where?: ServiciosWhereInput
  }

  /**
   * ServiciosUtilizados.Usuario
   */
  export type ServiciosUtilizados$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * ServiciosUtilizados without action
   */
  export type ServiciosUtilizadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiciosUtilizados
     */
    select?: ServiciosUtilizadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiciosUtilizadosInclude<ExtArgs> | null
  }


  /**
   * Model confirmacionPago
   */

  export type AggregateConfirmacionPago = {
    _count: ConfirmacionPagoCountAggregateOutputType | null
    _avg: ConfirmacionPagoAvgAggregateOutputType | null
    _sum: ConfirmacionPagoSumAggregateOutputType | null
    _min: ConfirmacionPagoMinAggregateOutputType | null
    _max: ConfirmacionPagoMaxAggregateOutputType | null
  }

  export type ConfirmacionPagoAvgAggregateOutputType = {
    amount: number | null
  }

  export type ConfirmacionPagoSumAggregateOutputType = {
    amount: number | null
  }

  export type ConfirmacionPagoMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    paymentStatus: string | null
    sessionId: string | null
    receiptUrl: string | null
    createdAt: Date | null
  }

  export type ConfirmacionPagoMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    paymentStatus: string | null
    sessionId: string | null
    receiptUrl: string | null
    createdAt: Date | null
  }

  export type ConfirmacionPagoCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    paymentStatus: number
    sessionId: number
    receiptUrl: number
    createdAt: number
    _all: number
  }


  export type ConfirmacionPagoAvgAggregateInputType = {
    amount?: true
  }

  export type ConfirmacionPagoSumAggregateInputType = {
    amount?: true
  }

  export type ConfirmacionPagoMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentStatus?: true
    sessionId?: true
    receiptUrl?: true
    createdAt?: true
  }

  export type ConfirmacionPagoMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentStatus?: true
    sessionId?: true
    receiptUrl?: true
    createdAt?: true
  }

  export type ConfirmacionPagoCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    paymentStatus?: true
    sessionId?: true
    receiptUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ConfirmacionPagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which confirmacionPago to aggregate.
     */
    where?: confirmacionPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmacionPagos to fetch.
     */
    orderBy?: confirmacionPagoOrderByWithRelationInput | confirmacionPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: confirmacionPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmacionPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmacionPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned confirmacionPagos
    **/
    _count?: true | ConfirmacionPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfirmacionPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfirmacionPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfirmacionPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfirmacionPagoMaxAggregateInputType
  }

  export type GetConfirmacionPagoAggregateType<T extends ConfirmacionPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirmacionPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirmacionPago[P]>
      : GetScalarType<T[P], AggregateConfirmacionPago[P]>
  }




  export type confirmacionPagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: confirmacionPagoWhereInput
    orderBy?: confirmacionPagoOrderByWithAggregationInput | confirmacionPagoOrderByWithAggregationInput[]
    by: ConfirmacionPagoScalarFieldEnum[] | ConfirmacionPagoScalarFieldEnum
    having?: confirmacionPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfirmacionPagoCountAggregateInputType | true
    _avg?: ConfirmacionPagoAvgAggregateInputType
    _sum?: ConfirmacionPagoSumAggregateInputType
    _min?: ConfirmacionPagoMinAggregateInputType
    _max?: ConfirmacionPagoMaxAggregateInputType
  }

  export type ConfirmacionPagoGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    paymentStatus: string
    sessionId: string
    receiptUrl: string | null
    createdAt: Date
    _count: ConfirmacionPagoCountAggregateOutputType | null
    _avg: ConfirmacionPagoAvgAggregateOutputType | null
    _sum: ConfirmacionPagoSumAggregateOutputType | null
    _min: ConfirmacionPagoMinAggregateOutputType | null
    _max: ConfirmacionPagoMaxAggregateOutputType | null
  }

  type GetConfirmacionPagoGroupByPayload<T extends confirmacionPagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfirmacionPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfirmacionPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfirmacionPagoGroupByOutputType[P]>
            : GetScalarType<T[P], ConfirmacionPagoGroupByOutputType[P]>
        }
      >
    >


  export type confirmacionPagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentStatus?: boolean
    sessionId?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["confirmacionPago"]>


  export type confirmacionPagoSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    paymentStatus?: boolean
    sessionId?: boolean
    receiptUrl?: boolean
    createdAt?: boolean
  }


  export type $confirmacionPagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "confirmacionPago"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      paymentStatus: string
      sessionId: string
      receiptUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["confirmacionPago"]>
    composites: {}
  }

  type confirmacionPagoGetPayload<S extends boolean | null | undefined | confirmacionPagoDefaultArgs> = $Result.GetResult<Prisma.$confirmacionPagoPayload, S>

  type confirmacionPagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<confirmacionPagoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfirmacionPagoCountAggregateInputType | true
    }

  export interface confirmacionPagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['confirmacionPago'], meta: { name: 'confirmacionPago' } }
    /**
     * Find zero or one ConfirmacionPago that matches the filter.
     * @param {confirmacionPagoFindUniqueArgs} args - Arguments to find a ConfirmacionPago
     * @example
     * // Get one ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends confirmacionPagoFindUniqueArgs>(args: SelectSubset<T, confirmacionPagoFindUniqueArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConfirmacionPago that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {confirmacionPagoFindUniqueOrThrowArgs} args - Arguments to find a ConfirmacionPago
     * @example
     * // Get one ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends confirmacionPagoFindUniqueOrThrowArgs>(args: SelectSubset<T, confirmacionPagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConfirmacionPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoFindFirstArgs} args - Arguments to find a ConfirmacionPago
     * @example
     * // Get one ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends confirmacionPagoFindFirstArgs>(args?: SelectSubset<T, confirmacionPagoFindFirstArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConfirmacionPago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoFindFirstOrThrowArgs} args - Arguments to find a ConfirmacionPago
     * @example
     * // Get one ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends confirmacionPagoFindFirstOrThrowArgs>(args?: SelectSubset<T, confirmacionPagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConfirmacionPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfirmacionPagos
     * const confirmacionPagos = await prisma.confirmacionPago.findMany()
     * 
     * // Get first 10 ConfirmacionPagos
     * const confirmacionPagos = await prisma.confirmacionPago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confirmacionPagoWithIdOnly = await prisma.confirmacionPago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends confirmacionPagoFindManyArgs>(args?: SelectSubset<T, confirmacionPagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConfirmacionPago.
     * @param {confirmacionPagoCreateArgs} args - Arguments to create a ConfirmacionPago.
     * @example
     * // Create one ConfirmacionPago
     * const ConfirmacionPago = await prisma.confirmacionPago.create({
     *   data: {
     *     // ... data to create a ConfirmacionPago
     *   }
     * })
     * 
     */
    create<T extends confirmacionPagoCreateArgs>(args: SelectSubset<T, confirmacionPagoCreateArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConfirmacionPagos.
     * @param {confirmacionPagoCreateManyArgs} args - Arguments to create many ConfirmacionPagos.
     * @example
     * // Create many ConfirmacionPagos
     * const confirmacionPago = await prisma.confirmacionPago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends confirmacionPagoCreateManyArgs>(args?: SelectSubset<T, confirmacionPagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConfirmacionPago.
     * @param {confirmacionPagoDeleteArgs} args - Arguments to delete one ConfirmacionPago.
     * @example
     * // Delete one ConfirmacionPago
     * const ConfirmacionPago = await prisma.confirmacionPago.delete({
     *   where: {
     *     // ... filter to delete one ConfirmacionPago
     *   }
     * })
     * 
     */
    delete<T extends confirmacionPagoDeleteArgs>(args: SelectSubset<T, confirmacionPagoDeleteArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConfirmacionPago.
     * @param {confirmacionPagoUpdateArgs} args - Arguments to update one ConfirmacionPago.
     * @example
     * // Update one ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends confirmacionPagoUpdateArgs>(args: SelectSubset<T, confirmacionPagoUpdateArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConfirmacionPagos.
     * @param {confirmacionPagoDeleteManyArgs} args - Arguments to filter ConfirmacionPagos to delete.
     * @example
     * // Delete a few ConfirmacionPagos
     * const { count } = await prisma.confirmacionPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends confirmacionPagoDeleteManyArgs>(args?: SelectSubset<T, confirmacionPagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfirmacionPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfirmacionPagos
     * const confirmacionPago = await prisma.confirmacionPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends confirmacionPagoUpdateManyArgs>(args: SelectSubset<T, confirmacionPagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConfirmacionPago.
     * @param {confirmacionPagoUpsertArgs} args - Arguments to update or create a ConfirmacionPago.
     * @example
     * // Update or create a ConfirmacionPago
     * const confirmacionPago = await prisma.confirmacionPago.upsert({
     *   create: {
     *     // ... data to create a ConfirmacionPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfirmacionPago we want to update
     *   }
     * })
     */
    upsert<T extends confirmacionPagoUpsertArgs>(args: SelectSubset<T, confirmacionPagoUpsertArgs<ExtArgs>>): Prisma__confirmacionPagoClient<$Result.GetResult<Prisma.$confirmacionPagoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more ConfirmacionPagos that matches the filter.
     * @param {confirmacionPagoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const confirmacionPago = await prisma.confirmacionPago.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: confirmacionPagoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ConfirmacionPago.
     * @param {confirmacionPagoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const confirmacionPago = await prisma.confirmacionPago.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: confirmacionPagoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ConfirmacionPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoCountArgs} args - Arguments to filter ConfirmacionPagos to count.
     * @example
     * // Count the number of ConfirmacionPagos
     * const count = await prisma.confirmacionPago.count({
     *   where: {
     *     // ... the filter for the ConfirmacionPagos we want to count
     *   }
     * })
    **/
    count<T extends confirmacionPagoCountArgs>(
      args?: Subset<T, confirmacionPagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfirmacionPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfirmacionPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfirmacionPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfirmacionPagoAggregateArgs>(args: Subset<T, ConfirmacionPagoAggregateArgs>): Prisma.PrismaPromise<GetConfirmacionPagoAggregateType<T>>

    /**
     * Group by ConfirmacionPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmacionPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends confirmacionPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: confirmacionPagoGroupByArgs['orderBy'] }
        : { orderBy?: confirmacionPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, confirmacionPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmacionPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the confirmacionPago model
   */
  readonly fields: confirmacionPagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for confirmacionPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__confirmacionPagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the confirmacionPago model
   */ 
  interface confirmacionPagoFieldRefs {
    readonly id: FieldRef<"confirmacionPago", 'String'>
    readonly userId: FieldRef<"confirmacionPago", 'String'>
    readonly amount: FieldRef<"confirmacionPago", 'Int'>
    readonly currency: FieldRef<"confirmacionPago", 'String'>
    readonly paymentStatus: FieldRef<"confirmacionPago", 'String'>
    readonly sessionId: FieldRef<"confirmacionPago", 'String'>
    readonly receiptUrl: FieldRef<"confirmacionPago", 'String'>
    readonly createdAt: FieldRef<"confirmacionPago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * confirmacionPago findUnique
   */
  export type confirmacionPagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter, which confirmacionPago to fetch.
     */
    where: confirmacionPagoWhereUniqueInput
  }

  /**
   * confirmacionPago findUniqueOrThrow
   */
  export type confirmacionPagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter, which confirmacionPago to fetch.
     */
    where: confirmacionPagoWhereUniqueInput
  }

  /**
   * confirmacionPago findFirst
   */
  export type confirmacionPagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter, which confirmacionPago to fetch.
     */
    where?: confirmacionPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmacionPagos to fetch.
     */
    orderBy?: confirmacionPagoOrderByWithRelationInput | confirmacionPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confirmacionPagos.
     */
    cursor?: confirmacionPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmacionPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmacionPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confirmacionPagos.
     */
    distinct?: ConfirmacionPagoScalarFieldEnum | ConfirmacionPagoScalarFieldEnum[]
  }

  /**
   * confirmacionPago findFirstOrThrow
   */
  export type confirmacionPagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter, which confirmacionPago to fetch.
     */
    where?: confirmacionPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmacionPagos to fetch.
     */
    orderBy?: confirmacionPagoOrderByWithRelationInput | confirmacionPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confirmacionPagos.
     */
    cursor?: confirmacionPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmacionPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmacionPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confirmacionPagos.
     */
    distinct?: ConfirmacionPagoScalarFieldEnum | ConfirmacionPagoScalarFieldEnum[]
  }

  /**
   * confirmacionPago findMany
   */
  export type confirmacionPagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter, which confirmacionPagos to fetch.
     */
    where?: confirmacionPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmacionPagos to fetch.
     */
    orderBy?: confirmacionPagoOrderByWithRelationInput | confirmacionPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing confirmacionPagos.
     */
    cursor?: confirmacionPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmacionPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmacionPagos.
     */
    skip?: number
    distinct?: ConfirmacionPagoScalarFieldEnum | ConfirmacionPagoScalarFieldEnum[]
  }

  /**
   * confirmacionPago create
   */
  export type confirmacionPagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * The data needed to create a confirmacionPago.
     */
    data: XOR<confirmacionPagoCreateInput, confirmacionPagoUncheckedCreateInput>
  }

  /**
   * confirmacionPago createMany
   */
  export type confirmacionPagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many confirmacionPagos.
     */
    data: confirmacionPagoCreateManyInput | confirmacionPagoCreateManyInput[]
  }

  /**
   * confirmacionPago update
   */
  export type confirmacionPagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * The data needed to update a confirmacionPago.
     */
    data: XOR<confirmacionPagoUpdateInput, confirmacionPagoUncheckedUpdateInput>
    /**
     * Choose, which confirmacionPago to update.
     */
    where: confirmacionPagoWhereUniqueInput
  }

  /**
   * confirmacionPago updateMany
   */
  export type confirmacionPagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update confirmacionPagos.
     */
    data: XOR<confirmacionPagoUpdateManyMutationInput, confirmacionPagoUncheckedUpdateManyInput>
    /**
     * Filter which confirmacionPagos to update
     */
    where?: confirmacionPagoWhereInput
  }

  /**
   * confirmacionPago upsert
   */
  export type confirmacionPagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * The filter to search for the confirmacionPago to update in case it exists.
     */
    where: confirmacionPagoWhereUniqueInput
    /**
     * In case the confirmacionPago found by the `where` argument doesn't exist, create a new confirmacionPago with this data.
     */
    create: XOR<confirmacionPagoCreateInput, confirmacionPagoUncheckedCreateInput>
    /**
     * In case the confirmacionPago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<confirmacionPagoUpdateInput, confirmacionPagoUncheckedUpdateInput>
  }

  /**
   * confirmacionPago delete
   */
  export type confirmacionPagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
    /**
     * Filter which confirmacionPago to delete.
     */
    where: confirmacionPagoWhereUniqueInput
  }

  /**
   * confirmacionPago deleteMany
   */
  export type confirmacionPagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which confirmacionPagos to delete
     */
    where?: confirmacionPagoWhereInput
  }

  /**
   * confirmacionPago findRaw
   */
  export type confirmacionPagoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * confirmacionPago aggregateRaw
   */
  export type confirmacionPagoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * confirmacionPago without action
   */
  export type confirmacionPagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confirmacionPago
     */
    select?: confirmacionPagoSelect<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    notificationTime: number | null
  }

  export type EventSumAggregateOutputType = {
    notificationTime: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    start: Date | null
    end: Date | null
    isAllDay: boolean | null
    notificationTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idUsuario: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    start: Date | null
    end: Date | null
    isAllDay: boolean | null
    notificationTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    idUsuario: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    start: number
    end: number
    isAllDay: number
    notificationTime: number
    createdAt: number
    updatedAt: number
    idUsuario: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    notificationTime?: true
  }

  export type EventSumAggregateInputType = {
    notificationTime?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start?: true
    end?: true
    isAllDay?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
    idUsuario?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start?: true
    end?: true
    isAllDay?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
    idUsuario?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start?: true
    end?: true
    isAllDay?: true
    notificationTime?: true
    createdAt?: true
    updatedAt?: true
    idUsuario?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    start: Date
    end: Date
    isAllDay: boolean
    notificationTime: number | null
    createdAt: Date
    updatedAt: Date
    idUsuario: string | null
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    isAllDay?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idUsuario?: boolean
    Usuario?: boolean | Event$UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    start?: boolean
    end?: boolean
    isAllDay?: boolean
    notificationTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    idUsuario?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | Event$UsuarioArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      start: Date
      end: Date
      isAllDay: boolean
      notificationTime: number | null
      createdAt: Date
      updatedAt: Date
      idUsuario: string | null
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * @param {EventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const event = await prisma.event.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: EventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Event.
     * @param {EventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const event = await prisma.event.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends Event$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Event$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly start: FieldRef<"Event", 'DateTime'>
    readonly end: FieldRef<"Event", 'DateTime'>
    readonly isAllDay: FieldRef<"Event", 'Boolean'>
    readonly notificationTime: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
    readonly idUsuario: FieldRef<"Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event findRaw
   */
  export type EventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Event aggregateRaw
   */
  export type EventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Event.Usuario
   */
  export type Event$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completed: boolean | null
    idUsuario: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    completed: boolean | null
    idUsuario: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    completed: number
    idUsuario: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    idUsuario?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    idUsuario?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    completed?: true
    idUsuario?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    completed: boolean
    idUsuario: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completed?: boolean
    idUsuario?: boolean
    Usuario?: boolean | Task$UsuarioArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>


  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completed?: boolean
    idUsuario?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Usuario?: boolean | Task$UsuarioArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      Usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
      completed: boolean
      idUsuario: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * @param {TaskFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const task = await prisma.task.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TaskFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Task.
     * @param {TaskAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const task = await prisma.task.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TaskAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Usuario<T extends Task$UsuarioArgs<ExtArgs> = {}>(args?: Subset<T, Task$UsuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly category: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly completed: FieldRef<"Task", 'Boolean'>
    readonly idUsuario: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task findRaw
   */
  export type TaskFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task aggregateRaw
   */
  export type TaskAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task.Usuario
   */
  export type Task$UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const MallaScalarFieldEnum: {
    id: 'id',
    cod: 'cod',
    carrera: 'carrera',
    year: 'year'
  };

  export type MallaScalarFieldEnum = (typeof MallaScalarFieldEnum)[keyof typeof MallaScalarFieldEnum]


  export const CursosMallaScalarFieldEnum: {
    id: 'id',
    idMalla: 'idMalla'
  };

  export type CursosMallaScalarFieldEnum = (typeof CursosMallaScalarFieldEnum)[keyof typeof CursosMallaScalarFieldEnum]


  export const CursoScalarFieldEnum: {
    id: 'id',
    cod: 'cod',
    nombre: 'nombre',
    creditos: 'creditos',
    horas: 'horas',
    semestre: 'semestre',
    cursosMallaId: 'cursosMallaId'
  };

  export type CursoScalarFieldEnum = (typeof CursoScalarFieldEnum)[keyof typeof CursoScalarFieldEnum]


  export const CursoMatriculadoScalarFieldEnum: {
    id: 'id',
    averageGrade: 'averageGrade',
    salon: 'salon',
    profesor: 'profesor',
    idCurso: 'idCurso',
    vez: 'vez',
    status: 'status',
    periodoMatriculadoId: 'periodoMatriculadoId',
    diasClase: 'diasClase',
    horaInicio: 'horaInicio'
  };

  export type CursoMatriculadoScalarFieldEnum = (typeof CursoMatriculadoScalarFieldEnum)[keyof typeof CursoMatriculadoScalarFieldEnum]


  export const NotaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    calificacion: 'calificacion',
    peso: 'peso',
    cursoMatriculadoId: 'cursoMatriculadoId'
  };

  export type NotaScalarFieldEnum = (typeof NotaScalarFieldEnum)[keyof typeof NotaScalarFieldEnum]


  export const PagosScalarFieldEnum: {
    id: 'id',
    cod: 'cod',
    descripcion: 'descripcion',
    monto: 'monto',
    fechaVencimiento: 'fechaVencimiento',
    estado: 'estado',
    urlRecibo: 'urlRecibo',
    tipo: 'tipo',
    usuarioId: 'usuarioId',
    periodoMatriculadoId: 'periodoMatriculadoId'
  };

  export type PagosScalarFieldEnum = (typeof PagosScalarFieldEnum)[keyof typeof PagosScalarFieldEnum]


  export const ServiciosScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    tipo: 'tipo',
    fechas: 'fechas'
  };

  export type ServiciosScalarFieldEnum = (typeof ServiciosScalarFieldEnum)[keyof typeof ServiciosScalarFieldEnum]


  export const TramitesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    tipo: 'tipo',
    costo: 'costo',
    requisitos: 'requisitos',
    descripcion: 'descripcion'
  };

  export type TramitesScalarFieldEnum = (typeof TramitesScalarFieldEnum)[keyof typeof TramitesScalarFieldEnum]


  export const PeriodoMatriculadoScalarFieldEnum: {
    id: 'id',
    semestre: 'semestre',
    periodo: 'periodo',
    idUsuario: 'idUsuario'
  };

  export type PeriodoMatriculadoScalarFieldEnum = (typeof PeriodoMatriculadoScalarFieldEnum)[keyof typeof PeriodoMatriculadoScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    email: 'email',
    carrera: 'carrera',
    password: 'password',
    image: 'image',
    emailVerified: 'emailVerified'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    type: 'type',
    access_token: 'access_token',
    refresh_token: 'refresh_token',
    expires_at: 'expires_at',
    scope: 'scope',
    id_token: 'id_token',
    token_type: 'token_type'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const TramitesRealizadosScalarFieldEnum: {
    id: 'id',
    idTramite: 'idTramite',
    idUsuario: 'idUsuario',
    fechas: 'fechas',
    documentos: 'documentos',
    estado: 'estado',
    adicional: 'adicional'
  };

  export type TramitesRealizadosScalarFieldEnum = (typeof TramitesRealizadosScalarFieldEnum)[keyof typeof TramitesRealizadosScalarFieldEnum]


  export const ServiciosUtilizadosScalarFieldEnum: {
    id: 'id',
    idServicio: 'idServicio',
    idUsuario: 'idUsuario',
    fechaRegistro: 'fechaRegistro',
    horarioElegido: 'horarioElegido',
    estado: 'estado'
  };

  export type ServiciosUtilizadosScalarFieldEnum = (typeof ServiciosUtilizadosScalarFieldEnum)[keyof typeof ServiciosUtilizadosScalarFieldEnum]


  export const ConfirmacionPagoScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    paymentStatus: 'paymentStatus',
    sessionId: 'sessionId',
    receiptUrl: 'receiptUrl',
    createdAt: 'createdAt'
  };

  export type ConfirmacionPagoScalarFieldEnum = (typeof ConfirmacionPagoScalarFieldEnum)[keyof typeof ConfirmacionPagoScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    start: 'start',
    end: 'end',
    isAllDay: 'isAllDay',
    notificationTime: 'notificationTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    idUsuario: 'idUsuario'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    completed: 'completed',
    idUsuario: 'idUsuario'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type MallaWhereInput = {
    AND?: MallaWhereInput | MallaWhereInput[]
    OR?: MallaWhereInput[]
    NOT?: MallaWhereInput | MallaWhereInput[]
    id?: StringFilter<"Malla"> | string
    cod?: StringFilter<"Malla"> | string
    carrera?: StringFilter<"Malla"> | string
    year?: IntFilter<"Malla"> | number
    CursosMalla?: CursosMallaListRelationFilter
  }

  export type MallaOrderByWithRelationInput = {
    id?: SortOrder
    cod?: SortOrder
    carrera?: SortOrder
    year?: SortOrder
    CursosMalla?: CursosMallaOrderByRelationAggregateInput
  }

  export type MallaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cod?: string
    AND?: MallaWhereInput | MallaWhereInput[]
    OR?: MallaWhereInput[]
    NOT?: MallaWhereInput | MallaWhereInput[]
    carrera?: StringFilter<"Malla"> | string
    year?: IntFilter<"Malla"> | number
    CursosMalla?: CursosMallaListRelationFilter
  }, "id" | "cod">

  export type MallaOrderByWithAggregationInput = {
    id?: SortOrder
    cod?: SortOrder
    carrera?: SortOrder
    year?: SortOrder
    _count?: MallaCountOrderByAggregateInput
    _avg?: MallaAvgOrderByAggregateInput
    _max?: MallaMaxOrderByAggregateInput
    _min?: MallaMinOrderByAggregateInput
    _sum?: MallaSumOrderByAggregateInput
  }

  export type MallaScalarWhereWithAggregatesInput = {
    AND?: MallaScalarWhereWithAggregatesInput | MallaScalarWhereWithAggregatesInput[]
    OR?: MallaScalarWhereWithAggregatesInput[]
    NOT?: MallaScalarWhereWithAggregatesInput | MallaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Malla"> | string
    cod?: StringWithAggregatesFilter<"Malla"> | string
    carrera?: StringWithAggregatesFilter<"Malla"> | string
    year?: IntWithAggregatesFilter<"Malla"> | number
  }

  export type CursosMallaWhereInput = {
    AND?: CursosMallaWhereInput | CursosMallaWhereInput[]
    OR?: CursosMallaWhereInput[]
    NOT?: CursosMallaWhereInput | CursosMallaWhereInput[]
    id?: StringFilter<"CursosMalla"> | string
    idMalla?: StringFilter<"CursosMalla"> | string
    Malla?: XOR<MallaRelationFilter, MallaWhereInput>
    cursos?: CursoListRelationFilter
  }

  export type CursosMallaOrderByWithRelationInput = {
    id?: SortOrder
    idMalla?: SortOrder
    Malla?: MallaOrderByWithRelationInput
    cursos?: CursoOrderByRelationAggregateInput
  }

  export type CursosMallaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CursosMallaWhereInput | CursosMallaWhereInput[]
    OR?: CursosMallaWhereInput[]
    NOT?: CursosMallaWhereInput | CursosMallaWhereInput[]
    idMalla?: StringFilter<"CursosMalla"> | string
    Malla?: XOR<MallaRelationFilter, MallaWhereInput>
    cursos?: CursoListRelationFilter
  }, "id">

  export type CursosMallaOrderByWithAggregationInput = {
    id?: SortOrder
    idMalla?: SortOrder
    _count?: CursosMallaCountOrderByAggregateInput
    _max?: CursosMallaMaxOrderByAggregateInput
    _min?: CursosMallaMinOrderByAggregateInput
  }

  export type CursosMallaScalarWhereWithAggregatesInput = {
    AND?: CursosMallaScalarWhereWithAggregatesInput | CursosMallaScalarWhereWithAggregatesInput[]
    OR?: CursosMallaScalarWhereWithAggregatesInput[]
    NOT?: CursosMallaScalarWhereWithAggregatesInput | CursosMallaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CursosMalla"> | string
    idMalla?: StringWithAggregatesFilter<"CursosMalla"> | string
  }

  export type CursoWhereInput = {
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    id?: StringFilter<"Curso"> | string
    cod?: StringFilter<"Curso"> | string
    nombre?: StringFilter<"Curso"> | string
    creditos?: IntFilter<"Curso"> | number
    horas?: IntFilter<"Curso"> | number
    semestre?: IntFilter<"Curso"> | number
    cursosMallaId?: StringNullableFilter<"Curso"> | string | null
    CursosMalla?: XOR<CursosMallaNullableRelationFilter, CursosMallaWhereInput> | null
    CursoMatriculado?: CursoMatriculadoListRelationFilter
  }

  export type CursoOrderByWithRelationInput = {
    id?: SortOrder
    cod?: SortOrder
    nombre?: SortOrder
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
    cursosMallaId?: SortOrder
    CursosMalla?: CursosMallaOrderByWithRelationInput
    CursoMatriculado?: CursoMatriculadoOrderByRelationAggregateInput
  }

  export type CursoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cod?: string
    AND?: CursoWhereInput | CursoWhereInput[]
    OR?: CursoWhereInput[]
    NOT?: CursoWhereInput | CursoWhereInput[]
    nombre?: StringFilter<"Curso"> | string
    creditos?: IntFilter<"Curso"> | number
    horas?: IntFilter<"Curso"> | number
    semestre?: IntFilter<"Curso"> | number
    cursosMallaId?: StringNullableFilter<"Curso"> | string | null
    CursosMalla?: XOR<CursosMallaNullableRelationFilter, CursosMallaWhereInput> | null
    CursoMatriculado?: CursoMatriculadoListRelationFilter
  }, "id" | "cod">

  export type CursoOrderByWithAggregationInput = {
    id?: SortOrder
    cod?: SortOrder
    nombre?: SortOrder
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
    cursosMallaId?: SortOrder
    _count?: CursoCountOrderByAggregateInput
    _avg?: CursoAvgOrderByAggregateInput
    _max?: CursoMaxOrderByAggregateInput
    _min?: CursoMinOrderByAggregateInput
    _sum?: CursoSumOrderByAggregateInput
  }

  export type CursoScalarWhereWithAggregatesInput = {
    AND?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    OR?: CursoScalarWhereWithAggregatesInput[]
    NOT?: CursoScalarWhereWithAggregatesInput | CursoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Curso"> | string
    cod?: StringWithAggregatesFilter<"Curso"> | string
    nombre?: StringWithAggregatesFilter<"Curso"> | string
    creditos?: IntWithAggregatesFilter<"Curso"> | number
    horas?: IntWithAggregatesFilter<"Curso"> | number
    semestre?: IntWithAggregatesFilter<"Curso"> | number
    cursosMallaId?: StringNullableWithAggregatesFilter<"Curso"> | string | null
  }

  export type CursoMatriculadoWhereInput = {
    AND?: CursoMatriculadoWhereInput | CursoMatriculadoWhereInput[]
    OR?: CursoMatriculadoWhereInput[]
    NOT?: CursoMatriculadoWhereInput | CursoMatriculadoWhereInput[]
    id?: StringFilter<"CursoMatriculado"> | string
    averageGrade?: FloatFilter<"CursoMatriculado"> | number
    salon?: StringFilter<"CursoMatriculado"> | string
    profesor?: StringFilter<"CursoMatriculado"> | string
    idCurso?: StringFilter<"CursoMatriculado"> | string
    vez?: IntFilter<"CursoMatriculado"> | number
    status?: StringFilter<"CursoMatriculado"> | string
    periodoMatriculadoId?: StringNullableFilter<"CursoMatriculado"> | string | null
    diasClase?: IntNullableListFilter<"CursoMatriculado">
    horaInicio?: DateTimeFilter<"CursoMatriculado"> | Date | string
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    PeriodoMatriculado?: XOR<PeriodoMatriculadoNullableRelationFilter, PeriodoMatriculadoWhereInput> | null
    notas?: NotaListRelationFilter
  }

  export type CursoMatriculadoOrderByWithRelationInput = {
    id?: SortOrder
    averageGrade?: SortOrder
    salon?: SortOrder
    profesor?: SortOrder
    idCurso?: SortOrder
    vez?: SortOrder
    status?: SortOrder
    periodoMatriculadoId?: SortOrder
    diasClase?: SortOrder
    horaInicio?: SortOrder
    curso?: CursoOrderByWithRelationInput
    PeriodoMatriculado?: PeriodoMatriculadoOrderByWithRelationInput
    notas?: NotaOrderByRelationAggregateInput
  }

  export type CursoMatriculadoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CursoMatriculadoWhereInput | CursoMatriculadoWhereInput[]
    OR?: CursoMatriculadoWhereInput[]
    NOT?: CursoMatriculadoWhereInput | CursoMatriculadoWhereInput[]
    averageGrade?: FloatFilter<"CursoMatriculado"> | number
    salon?: StringFilter<"CursoMatriculado"> | string
    profesor?: StringFilter<"CursoMatriculado"> | string
    idCurso?: StringFilter<"CursoMatriculado"> | string
    vez?: IntFilter<"CursoMatriculado"> | number
    status?: StringFilter<"CursoMatriculado"> | string
    periodoMatriculadoId?: StringNullableFilter<"CursoMatriculado"> | string | null
    diasClase?: IntNullableListFilter<"CursoMatriculado">
    horaInicio?: DateTimeFilter<"CursoMatriculado"> | Date | string
    curso?: XOR<CursoRelationFilter, CursoWhereInput>
    PeriodoMatriculado?: XOR<PeriodoMatriculadoNullableRelationFilter, PeriodoMatriculadoWhereInput> | null
    notas?: NotaListRelationFilter
  }, "id">

  export type CursoMatriculadoOrderByWithAggregationInput = {
    id?: SortOrder
    averageGrade?: SortOrder
    salon?: SortOrder
    profesor?: SortOrder
    idCurso?: SortOrder
    vez?: SortOrder
    status?: SortOrder
    periodoMatriculadoId?: SortOrder
    diasClase?: SortOrder
    horaInicio?: SortOrder
    _count?: CursoMatriculadoCountOrderByAggregateInput
    _avg?: CursoMatriculadoAvgOrderByAggregateInput
    _max?: CursoMatriculadoMaxOrderByAggregateInput
    _min?: CursoMatriculadoMinOrderByAggregateInput
    _sum?: CursoMatriculadoSumOrderByAggregateInput
  }

  export type CursoMatriculadoScalarWhereWithAggregatesInput = {
    AND?: CursoMatriculadoScalarWhereWithAggregatesInput | CursoMatriculadoScalarWhereWithAggregatesInput[]
    OR?: CursoMatriculadoScalarWhereWithAggregatesInput[]
    NOT?: CursoMatriculadoScalarWhereWithAggregatesInput | CursoMatriculadoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CursoMatriculado"> | string
    averageGrade?: FloatWithAggregatesFilter<"CursoMatriculado"> | number
    salon?: StringWithAggregatesFilter<"CursoMatriculado"> | string
    profesor?: StringWithAggregatesFilter<"CursoMatriculado"> | string
    idCurso?: StringWithAggregatesFilter<"CursoMatriculado"> | string
    vez?: IntWithAggregatesFilter<"CursoMatriculado"> | number
    status?: StringWithAggregatesFilter<"CursoMatriculado"> | string
    periodoMatriculadoId?: StringNullableWithAggregatesFilter<"CursoMatriculado"> | string | null
    diasClase?: IntNullableListFilter<"CursoMatriculado">
    horaInicio?: DateTimeWithAggregatesFilter<"CursoMatriculado"> | Date | string
  }

  export type NotaWhereInput = {
    AND?: NotaWhereInput | NotaWhereInput[]
    OR?: NotaWhereInput[]
    NOT?: NotaWhereInput | NotaWhereInput[]
    id?: StringFilter<"Nota"> | string
    nombre?: StringFilter<"Nota"> | string
    calificacion?: FloatFilter<"Nota"> | number
    peso?: FloatFilter<"Nota"> | number
    cursoMatriculadoId?: StringFilter<"Nota"> | string
    cursoMatriculado?: XOR<CursoMatriculadoRelationFilter, CursoMatriculadoWhereInput>
  }

  export type NotaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    calificacion?: SortOrder
    peso?: SortOrder
    cursoMatriculadoId?: SortOrder
    cursoMatriculado?: CursoMatriculadoOrderByWithRelationInput
  }

  export type NotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotaWhereInput | NotaWhereInput[]
    OR?: NotaWhereInput[]
    NOT?: NotaWhereInput | NotaWhereInput[]
    nombre?: StringFilter<"Nota"> | string
    calificacion?: FloatFilter<"Nota"> | number
    peso?: FloatFilter<"Nota"> | number
    cursoMatriculadoId?: StringFilter<"Nota"> | string
    cursoMatriculado?: XOR<CursoMatriculadoRelationFilter, CursoMatriculadoWhereInput>
  }, "id">

  export type NotaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    calificacion?: SortOrder
    peso?: SortOrder
    cursoMatriculadoId?: SortOrder
    _count?: NotaCountOrderByAggregateInput
    _avg?: NotaAvgOrderByAggregateInput
    _max?: NotaMaxOrderByAggregateInput
    _min?: NotaMinOrderByAggregateInput
    _sum?: NotaSumOrderByAggregateInput
  }

  export type NotaScalarWhereWithAggregatesInput = {
    AND?: NotaScalarWhereWithAggregatesInput | NotaScalarWhereWithAggregatesInput[]
    OR?: NotaScalarWhereWithAggregatesInput[]
    NOT?: NotaScalarWhereWithAggregatesInput | NotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nota"> | string
    nombre?: StringWithAggregatesFilter<"Nota"> | string
    calificacion?: FloatWithAggregatesFilter<"Nota"> | number
    peso?: FloatWithAggregatesFilter<"Nota"> | number
    cursoMatriculadoId?: StringWithAggregatesFilter<"Nota"> | string
  }

  export type PagosWhereInput = {
    AND?: PagosWhereInput | PagosWhereInput[]
    OR?: PagosWhereInput[]
    NOT?: PagosWhereInput | PagosWhereInput[]
    id?: StringFilter<"Pagos"> | string
    cod?: StringFilter<"Pagos"> | string
    descripcion?: StringFilter<"Pagos"> | string
    monto?: FloatFilter<"Pagos"> | number
    fechaVencimiento?: DateTimeFilter<"Pagos"> | Date | string
    estado?: StringFilter<"Pagos"> | string
    urlRecibo?: StringNullableFilter<"Pagos"> | string | null
    tipo?: StringFilter<"Pagos"> | string
    usuarioId?: StringNullableFilter<"Pagos"> | string | null
    periodoMatriculadoId?: StringNullableFilter<"Pagos"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    PeriodoMatriculado?: XOR<PeriodoMatriculadoNullableRelationFilter, PeriodoMatriculadoWhereInput> | null
  }

  export type PagosOrderByWithRelationInput = {
    id?: SortOrder
    cod?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    urlRecibo?: SortOrder
    tipo?: SortOrder
    usuarioId?: SortOrder
    periodoMatriculadoId?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    PeriodoMatriculado?: PeriodoMatriculadoOrderByWithRelationInput
  }

  export type PagosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cod?: string
    AND?: PagosWhereInput | PagosWhereInput[]
    OR?: PagosWhereInput[]
    NOT?: PagosWhereInput | PagosWhereInput[]
    descripcion?: StringFilter<"Pagos"> | string
    monto?: FloatFilter<"Pagos"> | number
    fechaVencimiento?: DateTimeFilter<"Pagos"> | Date | string
    estado?: StringFilter<"Pagos"> | string
    urlRecibo?: StringNullableFilter<"Pagos"> | string | null
    tipo?: StringFilter<"Pagos"> | string
    usuarioId?: StringNullableFilter<"Pagos"> | string | null
    periodoMatriculadoId?: StringNullableFilter<"Pagos"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    PeriodoMatriculado?: XOR<PeriodoMatriculadoNullableRelationFilter, PeriodoMatriculadoWhereInput> | null
  }, "id" | "cod">

  export type PagosOrderByWithAggregationInput = {
    id?: SortOrder
    cod?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    urlRecibo?: SortOrder
    tipo?: SortOrder
    usuarioId?: SortOrder
    periodoMatriculadoId?: SortOrder
    _count?: PagosCountOrderByAggregateInput
    _avg?: PagosAvgOrderByAggregateInput
    _max?: PagosMaxOrderByAggregateInput
    _min?: PagosMinOrderByAggregateInput
    _sum?: PagosSumOrderByAggregateInput
  }

  export type PagosScalarWhereWithAggregatesInput = {
    AND?: PagosScalarWhereWithAggregatesInput | PagosScalarWhereWithAggregatesInput[]
    OR?: PagosScalarWhereWithAggregatesInput[]
    NOT?: PagosScalarWhereWithAggregatesInput | PagosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pagos"> | string
    cod?: StringWithAggregatesFilter<"Pagos"> | string
    descripcion?: StringWithAggregatesFilter<"Pagos"> | string
    monto?: FloatWithAggregatesFilter<"Pagos"> | number
    fechaVencimiento?: DateTimeWithAggregatesFilter<"Pagos"> | Date | string
    estado?: StringWithAggregatesFilter<"Pagos"> | string
    urlRecibo?: StringNullableWithAggregatesFilter<"Pagos"> | string | null
    tipo?: StringWithAggregatesFilter<"Pagos"> | string
    usuarioId?: StringNullableWithAggregatesFilter<"Pagos"> | string | null
    periodoMatriculadoId?: StringNullableWithAggregatesFilter<"Pagos"> | string | null
  }

  export type ServiciosWhereInput = {
    AND?: ServiciosWhereInput | ServiciosWhereInput[]
    OR?: ServiciosWhereInput[]
    NOT?: ServiciosWhereInput | ServiciosWhereInput[]
    id?: StringFilter<"Servicios"> | string
    nombre?: StringFilter<"Servicios"> | string
    tipo?: StringFilter<"Servicios"> | string
    fechas?: DateTimeNullableListFilter<"Servicios">
    ServiciosUtilizados?: ServiciosUtilizadosListRelationFilter
  }

  export type ServiciosOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    fechas?: SortOrder
    ServiciosUtilizados?: ServiciosUtilizadosOrderByRelationAggregateInput
  }

  export type ServiciosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiciosWhereInput | ServiciosWhereInput[]
    OR?: ServiciosWhereInput[]
    NOT?: ServiciosWhereInput | ServiciosWhereInput[]
    nombre?: StringFilter<"Servicios"> | string
    tipo?: StringFilter<"Servicios"> | string
    fechas?: DateTimeNullableListFilter<"Servicios">
    ServiciosUtilizados?: ServiciosUtilizadosListRelationFilter
  }, "id">

  export type ServiciosOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    fechas?: SortOrder
    _count?: ServiciosCountOrderByAggregateInput
    _max?: ServiciosMaxOrderByAggregateInput
    _min?: ServiciosMinOrderByAggregateInput
  }

  export type ServiciosScalarWhereWithAggregatesInput = {
    AND?: ServiciosScalarWhereWithAggregatesInput | ServiciosScalarWhereWithAggregatesInput[]
    OR?: ServiciosScalarWhereWithAggregatesInput[]
    NOT?: ServiciosScalarWhereWithAggregatesInput | ServiciosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Servicios"> | string
    nombre?: StringWithAggregatesFilter<"Servicios"> | string
    tipo?: StringWithAggregatesFilter<"Servicios"> | string
    fechas?: DateTimeNullableListFilter<"Servicios">
  }

  export type TramitesWhereInput = {
    AND?: TramitesWhereInput | TramitesWhereInput[]
    OR?: TramitesWhereInput[]
    NOT?: TramitesWhereInput | TramitesWhereInput[]
    id?: StringFilter<"Tramites"> | string
    nombre?: StringFilter<"Tramites"> | string
    tipo?: StringFilter<"Tramites"> | string
    costo?: FloatNullableFilter<"Tramites"> | number | null
    requisitos?: StringNullableListFilter<"Tramites">
    descripcion?: StringFilter<"Tramites"> | string
    TramitesRealizados?: TramitesRealizadosListRelationFilter
  }

  export type TramitesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    costo?: SortOrder
    requisitos?: SortOrder
    descripcion?: SortOrder
    TramitesRealizados?: TramitesRealizadosOrderByRelationAggregateInput
  }

  export type TramitesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TramitesWhereInput | TramitesWhereInput[]
    OR?: TramitesWhereInput[]
    NOT?: TramitesWhereInput | TramitesWhereInput[]
    nombre?: StringFilter<"Tramites"> | string
    tipo?: StringFilter<"Tramites"> | string
    costo?: FloatNullableFilter<"Tramites"> | number | null
    requisitos?: StringNullableListFilter<"Tramites">
    descripcion?: StringFilter<"Tramites"> | string
    TramitesRealizados?: TramitesRealizadosListRelationFilter
  }, "id">

  export type TramitesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    costo?: SortOrder
    requisitos?: SortOrder
    descripcion?: SortOrder
    _count?: TramitesCountOrderByAggregateInput
    _avg?: TramitesAvgOrderByAggregateInput
    _max?: TramitesMaxOrderByAggregateInput
    _min?: TramitesMinOrderByAggregateInput
    _sum?: TramitesSumOrderByAggregateInput
  }

  export type TramitesScalarWhereWithAggregatesInput = {
    AND?: TramitesScalarWhereWithAggregatesInput | TramitesScalarWhereWithAggregatesInput[]
    OR?: TramitesScalarWhereWithAggregatesInput[]
    NOT?: TramitesScalarWhereWithAggregatesInput | TramitesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tramites"> | string
    nombre?: StringWithAggregatesFilter<"Tramites"> | string
    tipo?: StringWithAggregatesFilter<"Tramites"> | string
    costo?: FloatNullableWithAggregatesFilter<"Tramites"> | number | null
    requisitos?: StringNullableListFilter<"Tramites">
    descripcion?: StringWithAggregatesFilter<"Tramites"> | string
  }

  export type PeriodoMatriculadoWhereInput = {
    AND?: PeriodoMatriculadoWhereInput | PeriodoMatriculadoWhereInput[]
    OR?: PeriodoMatriculadoWhereInput[]
    NOT?: PeriodoMatriculadoWhereInput | PeriodoMatriculadoWhereInput[]
    id?: StringFilter<"PeriodoMatriculado"> | string
    semestre?: IntFilter<"PeriodoMatriculado"> | number
    periodo?: StringFilter<"PeriodoMatriculado"> | string
    idUsuario?: StringNullableFilter<"PeriodoMatriculado"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    Pagos?: PagosListRelationFilter
    cursosMatriculados?: CursoMatriculadoListRelationFilter
  }

  export type PeriodoMatriculadoOrderByWithRelationInput = {
    id?: SortOrder
    semestre?: SortOrder
    periodo?: SortOrder
    idUsuario?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
    Pagos?: PagosOrderByRelationAggregateInput
    cursosMatriculados?: CursoMatriculadoOrderByRelationAggregateInput
  }

  export type PeriodoMatriculadoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PeriodoMatriculadoWhereInput | PeriodoMatriculadoWhereInput[]
    OR?: PeriodoMatriculadoWhereInput[]
    NOT?: PeriodoMatriculadoWhereInput | PeriodoMatriculadoWhereInput[]
    semestre?: IntFilter<"PeriodoMatriculado"> | number
    periodo?: StringFilter<"PeriodoMatriculado"> | string
    idUsuario?: StringNullableFilter<"PeriodoMatriculado"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    Pagos?: PagosListRelationFilter
    cursosMatriculados?: CursoMatriculadoListRelationFilter
  }, "id">

  export type PeriodoMatriculadoOrderByWithAggregationInput = {
    id?: SortOrder
    semestre?: SortOrder
    periodo?: SortOrder
    idUsuario?: SortOrder
    _count?: PeriodoMatriculadoCountOrderByAggregateInput
    _avg?: PeriodoMatriculadoAvgOrderByAggregateInput
    _max?: PeriodoMatriculadoMaxOrderByAggregateInput
    _min?: PeriodoMatriculadoMinOrderByAggregateInput
    _sum?: PeriodoMatriculadoSumOrderByAggregateInput
  }

  export type PeriodoMatriculadoScalarWhereWithAggregatesInput = {
    AND?: PeriodoMatriculadoScalarWhereWithAggregatesInput | PeriodoMatriculadoScalarWhereWithAggregatesInput[]
    OR?: PeriodoMatriculadoScalarWhereWithAggregatesInput[]
    NOT?: PeriodoMatriculadoScalarWhereWithAggregatesInput | PeriodoMatriculadoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PeriodoMatriculado"> | string
    semestre?: IntWithAggregatesFilter<"PeriodoMatriculado"> | number
    periodo?: StringWithAggregatesFilter<"PeriodoMatriculado"> | string
    idUsuario?: StringNullableWithAggregatesFilter<"PeriodoMatriculado"> | string | null
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    nombre?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    carrera?: StringFilter<"Usuario"> | string
    password?: StringNullableFilter<"Usuario"> | string | null
    image?: StringNullableFilter<"Usuario"> | string | null
    emailVerified?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    TramitesRealizados?: TramitesRealizadosListRelationFilter
    ServiciosUtilizados?: ServiciosUtilizadosListRelationFilter
    Pagos?: PagosListRelationFilter
    PeriodoMatriculado?: PeriodoMatriculadoListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    events?: EventListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    carrera?: SortOrder
    password?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    TramitesRealizados?: TramitesRealizadosOrderByRelationAggregateInput
    ServiciosUtilizados?: ServiciosUtilizadosOrderByRelationAggregateInput
    Pagos?: PagosOrderByRelationAggregateInput
    PeriodoMatriculado?: PeriodoMatriculadoOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    carrera?: StringFilter<"Usuario"> | string
    password?: StringNullableFilter<"Usuario"> | string | null
    image?: StringNullableFilter<"Usuario"> | string | null
    emailVerified?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    TramitesRealizados?: TramitesRealizadosListRelationFilter
    ServiciosUtilizados?: ServiciosUtilizadosListRelationFilter
    Pagos?: PagosListRelationFilter
    PeriodoMatriculado?: PeriodoMatriculadoListRelationFilter
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    events?: EventListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    carrera?: SortOrder
    password?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    carrera?: StringWithAggregatesFilter<"Usuario"> | string
    password?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    image?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    access_token?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    token_type?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    type?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expires_at?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    token_type?: SortOrder
    user?: UsuarioOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    access_token?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    token_type?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    type?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expires_at?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    token_type?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UsuarioOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type TramitesRealizadosWhereInput = {
    AND?: TramitesRealizadosWhereInput | TramitesRealizadosWhereInput[]
    OR?: TramitesRealizadosWhereInput[]
    NOT?: TramitesRealizadosWhereInput | TramitesRealizadosWhereInput[]
    id?: StringFilter<"TramitesRealizados"> | string
    idTramite?: StringNullableFilter<"TramitesRealizados"> | string | null
    idUsuario?: StringNullableFilter<"TramitesRealizados"> | string | null
    fechas?: DateTimeNullableFilter<"TramitesRealizados"> | Date | string | null
    documentos?: StringNullableListFilter<"TramitesRealizados">
    estado?: StringNullableFilter<"TramitesRealizados"> | string | null
    adicional?: StringNullableFilter<"TramitesRealizados"> | string | null
    tramite?: XOR<TramitesNullableRelationFilter, TramitesWhereInput> | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type TramitesRealizadosOrderByWithRelationInput = {
    id?: SortOrder
    idTramite?: SortOrder
    idUsuario?: SortOrder
    fechas?: SortOrder
    documentos?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
    tramite?: TramitesOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type TramitesRealizadosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TramitesRealizadosWhereInput | TramitesRealizadosWhereInput[]
    OR?: TramitesRealizadosWhereInput[]
    NOT?: TramitesRealizadosWhereInput | TramitesRealizadosWhereInput[]
    idTramite?: StringNullableFilter<"TramitesRealizados"> | string | null
    idUsuario?: StringNullableFilter<"TramitesRealizados"> | string | null
    fechas?: DateTimeNullableFilter<"TramitesRealizados"> | Date | string | null
    documentos?: StringNullableListFilter<"TramitesRealizados">
    estado?: StringNullableFilter<"TramitesRealizados"> | string | null
    adicional?: StringNullableFilter<"TramitesRealizados"> | string | null
    tramite?: XOR<TramitesNullableRelationFilter, TramitesWhereInput> | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type TramitesRealizadosOrderByWithAggregationInput = {
    id?: SortOrder
    idTramite?: SortOrder
    idUsuario?: SortOrder
    fechas?: SortOrder
    documentos?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
    _count?: TramitesRealizadosCountOrderByAggregateInput
    _max?: TramitesRealizadosMaxOrderByAggregateInput
    _min?: TramitesRealizadosMinOrderByAggregateInput
  }

  export type TramitesRealizadosScalarWhereWithAggregatesInput = {
    AND?: TramitesRealizadosScalarWhereWithAggregatesInput | TramitesRealizadosScalarWhereWithAggregatesInput[]
    OR?: TramitesRealizadosScalarWhereWithAggregatesInput[]
    NOT?: TramitesRealizadosScalarWhereWithAggregatesInput | TramitesRealizadosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TramitesRealizados"> | string
    idTramite?: StringNullableWithAggregatesFilter<"TramitesRealizados"> | string | null
    idUsuario?: StringNullableWithAggregatesFilter<"TramitesRealizados"> | string | null
    fechas?: DateTimeNullableWithAggregatesFilter<"TramitesRealizados"> | Date | string | null
    documentos?: StringNullableListFilter<"TramitesRealizados">
    estado?: StringNullableWithAggregatesFilter<"TramitesRealizados"> | string | null
    adicional?: StringNullableWithAggregatesFilter<"TramitesRealizados"> | string | null
  }

  export type ServiciosUtilizadosWhereInput = {
    AND?: ServiciosUtilizadosWhereInput | ServiciosUtilizadosWhereInput[]
    OR?: ServiciosUtilizadosWhereInput[]
    NOT?: ServiciosUtilizadosWhereInput | ServiciosUtilizadosWhereInput[]
    id?: StringFilter<"ServiciosUtilizados"> | string
    idServicio?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    idUsuario?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    fechaRegistro?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    horarioElegido?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    estado?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    servicio?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type ServiciosUtilizadosOrderByWithRelationInput = {
    id?: SortOrder
    idServicio?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    horarioElegido?: SortOrder
    estado?: SortOrder
    servicio?: ServiciosOrderByWithRelationInput
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type ServiciosUtilizadosWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiciosUtilizadosWhereInput | ServiciosUtilizadosWhereInput[]
    OR?: ServiciosUtilizadosWhereInput[]
    NOT?: ServiciosUtilizadosWhereInput | ServiciosUtilizadosWhereInput[]
    idServicio?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    idUsuario?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    fechaRegistro?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    horarioElegido?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    estado?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    servicio?: XOR<ServiciosNullableRelationFilter, ServiciosWhereInput> | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type ServiciosUtilizadosOrderByWithAggregationInput = {
    id?: SortOrder
    idServicio?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    horarioElegido?: SortOrder
    estado?: SortOrder
    _count?: ServiciosUtilizadosCountOrderByAggregateInput
    _max?: ServiciosUtilizadosMaxOrderByAggregateInput
    _min?: ServiciosUtilizadosMinOrderByAggregateInput
  }

  export type ServiciosUtilizadosScalarWhereWithAggregatesInput = {
    AND?: ServiciosUtilizadosScalarWhereWithAggregatesInput | ServiciosUtilizadosScalarWhereWithAggregatesInput[]
    OR?: ServiciosUtilizadosScalarWhereWithAggregatesInput[]
    NOT?: ServiciosUtilizadosScalarWhereWithAggregatesInput | ServiciosUtilizadosScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiciosUtilizados"> | string
    idServicio?: StringNullableWithAggregatesFilter<"ServiciosUtilizados"> | string | null
    idUsuario?: StringNullableWithAggregatesFilter<"ServiciosUtilizados"> | string | null
    fechaRegistro?: DateTimeNullableWithAggregatesFilter<"ServiciosUtilizados"> | Date | string | null
    horarioElegido?: DateTimeNullableWithAggregatesFilter<"ServiciosUtilizados"> | Date | string | null
    estado?: StringNullableWithAggregatesFilter<"ServiciosUtilizados"> | string | null
  }

  export type confirmacionPagoWhereInput = {
    AND?: confirmacionPagoWhereInput | confirmacionPagoWhereInput[]
    OR?: confirmacionPagoWhereInput[]
    NOT?: confirmacionPagoWhereInput | confirmacionPagoWhereInput[]
    id?: StringFilter<"confirmacionPago"> | string
    userId?: StringFilter<"confirmacionPago"> | string
    amount?: IntFilter<"confirmacionPago"> | number
    currency?: StringFilter<"confirmacionPago"> | string
    paymentStatus?: StringFilter<"confirmacionPago"> | string
    sessionId?: StringFilter<"confirmacionPago"> | string
    receiptUrl?: StringNullableFilter<"confirmacionPago"> | string | null
    createdAt?: DateTimeFilter<"confirmacionPago"> | Date | string
  }

  export type confirmacionPagoOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    sessionId?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type confirmacionPagoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: confirmacionPagoWhereInput | confirmacionPagoWhereInput[]
    OR?: confirmacionPagoWhereInput[]
    NOT?: confirmacionPagoWhereInput | confirmacionPagoWhereInput[]
    userId?: StringFilter<"confirmacionPago"> | string
    amount?: IntFilter<"confirmacionPago"> | number
    currency?: StringFilter<"confirmacionPago"> | string
    paymentStatus?: StringFilter<"confirmacionPago"> | string
    sessionId?: StringFilter<"confirmacionPago"> | string
    receiptUrl?: StringNullableFilter<"confirmacionPago"> | string | null
    createdAt?: DateTimeFilter<"confirmacionPago"> | Date | string
  }, "id">

  export type confirmacionPagoOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    sessionId?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
    _count?: confirmacionPagoCountOrderByAggregateInput
    _avg?: confirmacionPagoAvgOrderByAggregateInput
    _max?: confirmacionPagoMaxOrderByAggregateInput
    _min?: confirmacionPagoMinOrderByAggregateInput
    _sum?: confirmacionPagoSumOrderByAggregateInput
  }

  export type confirmacionPagoScalarWhereWithAggregatesInput = {
    AND?: confirmacionPagoScalarWhereWithAggregatesInput | confirmacionPagoScalarWhereWithAggregatesInput[]
    OR?: confirmacionPagoScalarWhereWithAggregatesInput[]
    NOT?: confirmacionPagoScalarWhereWithAggregatesInput | confirmacionPagoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"confirmacionPago"> | string
    userId?: StringWithAggregatesFilter<"confirmacionPago"> | string
    amount?: IntWithAggregatesFilter<"confirmacionPago"> | number
    currency?: StringWithAggregatesFilter<"confirmacionPago"> | string
    paymentStatus?: StringWithAggregatesFilter<"confirmacionPago"> | string
    sessionId?: StringWithAggregatesFilter<"confirmacionPago"> | string
    receiptUrl?: StringNullableWithAggregatesFilter<"confirmacionPago"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"confirmacionPago"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    notificationTime?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    idUsuario?: StringNullableFilter<"Event"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    isAllDay?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idUsuario?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    notificationTime?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    idUsuario?: StringNullableFilter<"Event"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    isAllDay?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idUsuario?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    start?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    isAllDay?: BoolWithAggregatesFilter<"Event"> | boolean
    notificationTime?: IntNullableWithAggregatesFilter<"Event"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    idUsuario?: StringNullableWithAggregatesFilter<"Event"> | string | null
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    category?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    completed?: BoolFilter<"Task"> | boolean
    idUsuario?: StringNullableFilter<"Task"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    idUsuario?: SortOrder
    Usuario?: UsuarioOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    category?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    completed?: BoolFilter<"Task"> | boolean
    idUsuario?: StringNullableFilter<"Task"> | string | null
    Usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    idUsuario?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    category?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    completed?: BoolWithAggregatesFilter<"Task"> | boolean
    idUsuario?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type MallaCreateInput = {
    id?: string
    cod: string
    carrera: string
    year: number
    CursosMalla?: CursosMallaCreateNestedManyWithoutMallaInput
  }

  export type MallaUncheckedCreateInput = {
    id?: string
    cod: string
    carrera: string
    year: number
    CursosMalla?: CursosMallaUncheckedCreateNestedManyWithoutMallaInput
  }

  export type MallaUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    CursosMalla?: CursosMallaUpdateManyWithoutMallaNestedInput
  }

  export type MallaUncheckedUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    CursosMalla?: CursosMallaUncheckedUpdateManyWithoutMallaNestedInput
  }

  export type MallaCreateManyInput = {
    id?: string
    cod: string
    carrera: string
    year: number
  }

  export type MallaUpdateManyMutationInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type MallaUncheckedUpdateManyInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type CursosMallaCreateInput = {
    id?: string
    Malla: MallaCreateNestedOneWithoutCursosMallaInput
    cursos?: CursoCreateNestedManyWithoutCursosMallaInput
  }

  export type CursosMallaUncheckedCreateInput = {
    id?: string
    idMalla: string
    cursos?: CursoUncheckedCreateNestedManyWithoutCursosMallaInput
  }

  export type CursosMallaUpdateInput = {
    Malla?: MallaUpdateOneRequiredWithoutCursosMallaNestedInput
    cursos?: CursoUpdateManyWithoutCursosMallaNestedInput
  }

  export type CursosMallaUncheckedUpdateInput = {
    idMalla?: StringFieldUpdateOperationsInput | string
    cursos?: CursoUncheckedUpdateManyWithoutCursosMallaNestedInput
  }

  export type CursosMallaCreateManyInput = {
    id?: string
    idMalla: string
  }

  export type CursosMallaUpdateManyMutationInput = {

  }

  export type CursosMallaUncheckedUpdateManyInput = {
    idMalla?: StringFieldUpdateOperationsInput | string
  }

  export type CursoCreateInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    CursosMalla?: CursosMallaCreateNestedOneWithoutCursosInput
    CursoMatriculado?: CursoMatriculadoCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    cursosMallaId?: string | null
    CursoMatriculado?: CursoMatriculadoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    CursosMalla?: CursosMallaUpdateOneWithoutCursosNestedInput
    CursoMatriculado?: CursoMatriculadoUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    cursosMallaId?: NullableStringFieldUpdateOperationsInput | string | null
    CursoMatriculado?: CursoMatriculadoUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoCreateManyInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    cursosMallaId?: string | null
  }

  export type CursoUpdateManyMutationInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
  }

  export type CursoUncheckedUpdateManyInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    cursosMallaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CursoMatriculadoCreateInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    curso: CursoCreateNestedOneWithoutCursoMatriculadoInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedOneWithoutCursosMatriculadosInput
    notas?: NotaCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoUncheckedCreateInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    periodoMatriculadoId?: string | null
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    notas?: NotaUncheckedCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoUpdateInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: CursoUpdateOneRequiredWithoutCursoMatriculadoNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateOneWithoutCursosMatriculadosNestedInput
    notas?: NotaUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    idCurso?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notas?: NotaUncheckedUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoCreateManyInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    periodoMatriculadoId?: string | null
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
  }

  export type CursoMatriculadoUpdateManyMutationInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CursoMatriculadoUncheckedUpdateManyInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    idCurso?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotaCreateInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
    cursoMatriculado: CursoMatriculadoCreateNestedOneWithoutNotasInput
  }

  export type NotaUncheckedCreateInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
    cursoMatriculadoId: string
  }

  export type NotaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
    cursoMatriculado?: CursoMatriculadoUpdateOneRequiredWithoutNotasNestedInput
  }

  export type NotaUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
    cursoMatriculadoId?: StringFieldUpdateOperationsInput | string
  }

  export type NotaCreateManyInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
    cursoMatriculadoId: string
  }

  export type NotaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
  }

  export type NotaUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
    cursoMatriculadoId?: StringFieldUpdateOperationsInput | string
  }

  export type PagosCreateInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    Usuario?: UsuarioCreateNestedOneWithoutPagosInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedOneWithoutPagosInput
  }

  export type PagosUncheckedCreateInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    usuarioId?: string | null
    periodoMatriculadoId?: string | null
  }

  export type PagosUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneWithoutPagosNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateOneWithoutPagosNestedInput
  }

  export type PagosUncheckedUpdateInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagosCreateManyInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    usuarioId?: string | null
    periodoMatriculadoId?: string | null
  }

  export type PagosUpdateManyMutationInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type PagosUncheckedUpdateManyInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosCreateInput = {
    id?: string
    nombre: string
    tipo: string
    fechas?: ServiciosCreatefechasInput | Date[] | string[]
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutServicioInput
  }

  export type ServiciosUncheckedCreateInput = {
    id?: string
    nombre: string
    tipo: string
    fechas?: ServiciosCreatefechasInput | Date[] | string[]
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServiciosUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutServicioNestedInput
  }

  export type ServiciosUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServiciosCreateManyInput = {
    id?: string
    nombre: string
    tipo: string
    fechas?: ServiciosCreatefechasInput | Date[] | string[]
  }

  export type ServiciosUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
  }

  export type ServiciosUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
  }

  export type TramitesCreateInput = {
    id?: string
    nombre: string
    tipo: string
    costo?: number | null
    requisitos?: TramitesCreaterequisitosInput | string[]
    descripcion: string
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutTramiteInput
  }

  export type TramitesUncheckedCreateInput = {
    id?: string
    nombre: string
    tipo: string
    costo?: number | null
    requisitos?: TramitesCreaterequisitosInput | string[]
    descripcion: string
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutTramiteInput
  }

  export type TramitesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutTramiteNestedInput
  }

  export type TramitesUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutTramiteNestedInput
  }

  export type TramitesCreateManyInput = {
    id?: string
    nombre: string
    tipo: string
    costo?: number | null
    requisitos?: TramitesCreaterequisitosInput | string[]
    descripcion: string
  }

  export type TramitesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TramitesUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodoMatriculadoCreateInput = {
    id?: string
    semestre: number
    periodo: string
    Usuario?: UsuarioCreateNestedOneWithoutPeriodoMatriculadoInput
    Pagos?: PagosCreateNestedManyWithoutPeriodoMatriculadoInput
    cursosMatriculados?: CursoMatriculadoCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoUncheckedCreateInput = {
    id?: string
    semestre: number
    periodo: string
    idUsuario?: string | null
    Pagos?: PagosUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
    cursosMatriculados?: CursoMatriculadoUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoUpdateInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneWithoutPeriodoMatriculadoNestedInput
    Pagos?: PagosUpdateManyWithoutPeriodoMatriculadoNestedInput
    cursosMatriculados?: CursoMatriculadoUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoUncheckedUpdateInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    Pagos?: PagosUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
    cursosMatriculados?: CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoCreateManyInput = {
    id?: string
    semestre: number
    periodo: string
    idUsuario?: string | null
  }

  export type PeriodoMatriculadoUpdateManyMutationInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
  }

  export type PeriodoMatriculadoUncheckedUpdateManyInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuarioCreateInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioUncheckedUpdateManyInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
    user: UsuarioCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
  }

  export type AccountUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UsuarioUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UsuarioCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsuarioUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TramitesRealizadosCreateInput = {
    id?: string
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
    tramite?: TramitesCreateNestedOneWithoutTramitesRealizadosInput
    Usuario?: UsuarioCreateNestedOneWithoutTramitesRealizadosInput
  }

  export type TramitesRealizadosUncheckedCreateInput = {
    id?: string
    idTramite?: string | null
    idUsuario?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type TramitesRealizadosUpdateInput = {
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    tramite?: TramitesUpdateOneWithoutTramitesRealizadosNestedInput
    Usuario?: UsuarioUpdateOneWithoutTramitesRealizadosNestedInput
  }

  export type TramitesRealizadosUncheckedUpdateInput = {
    idTramite?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TramitesRealizadosCreateManyInput = {
    id?: string
    idTramite?: string | null
    idUsuario?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type TramitesRealizadosUpdateManyMutationInput = {
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TramitesRealizadosUncheckedUpdateManyInput = {
    idTramite?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosCreateInput = {
    id?: string
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
    servicio?: ServiciosCreateNestedOneWithoutServiciosUtilizadosInput
    Usuario?: UsuarioCreateNestedOneWithoutServiciosUtilizadosInput
  }

  export type ServiciosUtilizadosUncheckedCreateInput = {
    id?: string
    idServicio?: string | null
    idUsuario?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type ServiciosUtilizadosUpdateInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    servicio?: ServiciosUpdateOneWithoutServiciosUtilizadosNestedInput
    Usuario?: UsuarioUpdateOneWithoutServiciosUtilizadosNestedInput
  }

  export type ServiciosUtilizadosUncheckedUpdateInput = {
    idServicio?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosCreateManyInput = {
    id?: string
    idServicio?: string | null
    idUsuario?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type ServiciosUtilizadosUpdateManyMutationInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosUncheckedUpdateManyInput = {
    idServicio?: NullableStringFieldUpdateOperationsInput | string | null
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type confirmacionPagoCreateInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    paymentStatus: string
    sessionId: string
    receiptUrl?: string | null
    createdAt?: Date | string
  }

  export type confirmacionPagoUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    paymentStatus: string
    sessionId: string
    receiptUrl?: string | null
    createdAt?: Date | string
  }

  export type confirmacionPagoUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type confirmacionPagoUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type confirmacionPagoCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    paymentStatus: string
    sessionId: string
    receiptUrl?: string | null
    createdAt?: Date | string
  }

  export type confirmacionPagoUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type confirmacionPagoUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Usuario?: UsuarioCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idUsuario?: string | null
  }

  export type EventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Usuario?: UsuarioUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    idUsuario?: string | null
  }

  export type EventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
    Usuario?: UsuarioCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
    idUsuario?: string | null
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    Usuario?: UsuarioUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
    idUsuario?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CursosMallaListRelationFilter = {
    every?: CursosMallaWhereInput
    some?: CursosMallaWhereInput
    none?: CursosMallaWhereInput
  }

  export type CursosMallaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MallaCountOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    carrera?: SortOrder
    year?: SortOrder
  }

  export type MallaAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type MallaMaxOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    carrera?: SortOrder
    year?: SortOrder
  }

  export type MallaMinOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    carrera?: SortOrder
    year?: SortOrder
  }

  export type MallaSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MallaRelationFilter = {
    is?: MallaWhereInput
    isNot?: MallaWhereInput
  }

  export type CursoListRelationFilter = {
    every?: CursoWhereInput
    some?: CursoWhereInput
    none?: CursoWhereInput
  }

  export type CursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CursosMallaCountOrderByAggregateInput = {
    id?: SortOrder
    idMalla?: SortOrder
  }

  export type CursosMallaMaxOrderByAggregateInput = {
    id?: SortOrder
    idMalla?: SortOrder
  }

  export type CursosMallaMinOrderByAggregateInput = {
    id?: SortOrder
    idMalla?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type CursosMallaNullableRelationFilter = {
    is?: CursosMallaWhereInput | null
    isNot?: CursosMallaWhereInput | null
  }

  export type CursoMatriculadoListRelationFilter = {
    every?: CursoMatriculadoWhereInput
    some?: CursoMatriculadoWhereInput
    none?: CursoMatriculadoWhereInput
  }

  export type CursoMatriculadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CursoCountOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    nombre?: SortOrder
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
    cursosMallaId?: SortOrder
  }

  export type CursoAvgOrderByAggregateInput = {
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
  }

  export type CursoMaxOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    nombre?: SortOrder
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
    cursosMallaId?: SortOrder
  }

  export type CursoMinOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    nombre?: SortOrder
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
    cursosMallaId?: SortOrder
  }

  export type CursoSumOrderByAggregateInput = {
    creditos?: SortOrder
    horas?: SortOrder
    semestre?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CursoRelationFilter = {
    is?: CursoWhereInput
    isNot?: CursoWhereInput
  }

  export type PeriodoMatriculadoNullableRelationFilter = {
    is?: PeriodoMatriculadoWhereInput | null
    isNot?: PeriodoMatriculadoWhereInput | null
  }

  export type NotaListRelationFilter = {
    every?: NotaWhereInput
    some?: NotaWhereInput
    none?: NotaWhereInput
  }

  export type NotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CursoMatriculadoCountOrderByAggregateInput = {
    id?: SortOrder
    averageGrade?: SortOrder
    salon?: SortOrder
    profesor?: SortOrder
    idCurso?: SortOrder
    vez?: SortOrder
    status?: SortOrder
    periodoMatriculadoId?: SortOrder
    diasClase?: SortOrder
    horaInicio?: SortOrder
  }

  export type CursoMatriculadoAvgOrderByAggregateInput = {
    averageGrade?: SortOrder
    vez?: SortOrder
    diasClase?: SortOrder
  }

  export type CursoMatriculadoMaxOrderByAggregateInput = {
    id?: SortOrder
    averageGrade?: SortOrder
    salon?: SortOrder
    profesor?: SortOrder
    idCurso?: SortOrder
    vez?: SortOrder
    status?: SortOrder
    periodoMatriculadoId?: SortOrder
    horaInicio?: SortOrder
  }

  export type CursoMatriculadoMinOrderByAggregateInput = {
    id?: SortOrder
    averageGrade?: SortOrder
    salon?: SortOrder
    profesor?: SortOrder
    idCurso?: SortOrder
    vez?: SortOrder
    status?: SortOrder
    periodoMatriculadoId?: SortOrder
    horaInicio?: SortOrder
  }

  export type CursoMatriculadoSumOrderByAggregateInput = {
    averageGrade?: SortOrder
    vez?: SortOrder
    diasClase?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CursoMatriculadoRelationFilter = {
    is?: CursoMatriculadoWhereInput
    isNot?: CursoMatriculadoWhereInput
  }

  export type NotaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    calificacion?: SortOrder
    peso?: SortOrder
    cursoMatriculadoId?: SortOrder
  }

  export type NotaAvgOrderByAggregateInput = {
    calificacion?: SortOrder
    peso?: SortOrder
  }

  export type NotaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    calificacion?: SortOrder
    peso?: SortOrder
    cursoMatriculadoId?: SortOrder
  }

  export type NotaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    calificacion?: SortOrder
    peso?: SortOrder
    cursoMatriculadoId?: SortOrder
  }

  export type NotaSumOrderByAggregateInput = {
    calificacion?: SortOrder
    peso?: SortOrder
  }

  export type UsuarioNullableRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type PagosCountOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    urlRecibo?: SortOrder
    tipo?: SortOrder
    usuarioId?: SortOrder
    periodoMatriculadoId?: SortOrder
  }

  export type PagosAvgOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type PagosMaxOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    urlRecibo?: SortOrder
    tipo?: SortOrder
    usuarioId?: SortOrder
    periodoMatriculadoId?: SortOrder
  }

  export type PagosMinOrderByAggregateInput = {
    id?: SortOrder
    cod?: SortOrder
    descripcion?: SortOrder
    monto?: SortOrder
    fechaVencimiento?: SortOrder
    estado?: SortOrder
    urlRecibo?: SortOrder
    tipo?: SortOrder
    usuarioId?: SortOrder
    periodoMatriculadoId?: SortOrder
  }

  export type PagosSumOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ServiciosUtilizadosListRelationFilter = {
    every?: ServiciosUtilizadosWhereInput
    some?: ServiciosUtilizadosWhereInput
    none?: ServiciosUtilizadosWhereInput
  }

  export type ServiciosUtilizadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiciosCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    fechas?: SortOrder
  }

  export type ServiciosMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
  }

  export type ServiciosMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TramitesRealizadosListRelationFilter = {
    every?: TramitesRealizadosWhereInput
    some?: TramitesRealizadosWhereInput
    none?: TramitesRealizadosWhereInput
  }

  export type TramitesRealizadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TramitesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    costo?: SortOrder
    requisitos?: SortOrder
    descripcion?: SortOrder
  }

  export type TramitesAvgOrderByAggregateInput = {
    costo?: SortOrder
  }

  export type TramitesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    costo?: SortOrder
    descripcion?: SortOrder
  }

  export type TramitesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    tipo?: SortOrder
    costo?: SortOrder
    descripcion?: SortOrder
  }

  export type TramitesSumOrderByAggregateInput = {
    costo?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type PagosListRelationFilter = {
    every?: PagosWhereInput
    some?: PagosWhereInput
    none?: PagosWhereInput
  }

  export type PagosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PeriodoMatriculadoCountOrderByAggregateInput = {
    id?: SortOrder
    semestre?: SortOrder
    periodo?: SortOrder
    idUsuario?: SortOrder
  }

  export type PeriodoMatriculadoAvgOrderByAggregateInput = {
    semestre?: SortOrder
  }

  export type PeriodoMatriculadoMaxOrderByAggregateInput = {
    id?: SortOrder
    semestre?: SortOrder
    periodo?: SortOrder
    idUsuario?: SortOrder
  }

  export type PeriodoMatriculadoMinOrderByAggregateInput = {
    id?: SortOrder
    semestre?: SortOrder
    periodo?: SortOrder
    idUsuario?: SortOrder
  }

  export type PeriodoMatriculadoSumOrderByAggregateInput = {
    semestre?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type PeriodoMatriculadoListRelationFilter = {
    every?: PeriodoMatriculadoWhereInput
    some?: PeriodoMatriculadoWhereInput
    none?: PeriodoMatriculadoWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type PeriodoMatriculadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    carrera?: SortOrder
    password?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    carrera?: SortOrder
    password?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    carrera?: SortOrder
    password?: SortOrder
    image?: SortOrder
    emailVerified?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    type?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expires_at?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    token_type?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    type?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expires_at?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    token_type?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    type?: SortOrder
    access_token?: SortOrder
    refresh_token?: SortOrder
    expires_at?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    token_type?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type TramitesNullableRelationFilter = {
    is?: TramitesWhereInput | null
    isNot?: TramitesWhereInput | null
  }

  export type TramitesRealizadosCountOrderByAggregateInput = {
    id?: SortOrder
    idTramite?: SortOrder
    idUsuario?: SortOrder
    fechas?: SortOrder
    documentos?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
  }

  export type TramitesRealizadosMaxOrderByAggregateInput = {
    id?: SortOrder
    idTramite?: SortOrder
    idUsuario?: SortOrder
    fechas?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
  }

  export type TramitesRealizadosMinOrderByAggregateInput = {
    id?: SortOrder
    idTramite?: SortOrder
    idUsuario?: SortOrder
    fechas?: SortOrder
    estado?: SortOrder
    adicional?: SortOrder
  }

  export type ServiciosNullableRelationFilter = {
    is?: ServiciosWhereInput | null
    isNot?: ServiciosWhereInput | null
  }

  export type ServiciosUtilizadosCountOrderByAggregateInput = {
    id?: SortOrder
    idServicio?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    horarioElegido?: SortOrder
    estado?: SortOrder
  }

  export type ServiciosUtilizadosMaxOrderByAggregateInput = {
    id?: SortOrder
    idServicio?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    horarioElegido?: SortOrder
    estado?: SortOrder
  }

  export type ServiciosUtilizadosMinOrderByAggregateInput = {
    id?: SortOrder
    idServicio?: SortOrder
    idUsuario?: SortOrder
    fechaRegistro?: SortOrder
    horarioElegido?: SortOrder
    estado?: SortOrder
  }

  export type confirmacionPagoCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    sessionId?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type confirmacionPagoAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type confirmacionPagoMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    sessionId?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type confirmacionPagoMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentStatus?: SortOrder
    sessionId?: SortOrder
    receiptUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type confirmacionPagoSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    isAllDay?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idUsuario?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    notificationTime?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    isAllDay?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idUsuario?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start?: SortOrder
    end?: SortOrder
    isAllDay?: SortOrder
    notificationTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    idUsuario?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    notificationTime?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    idUsuario?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    idUsuario?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completed?: SortOrder
    idUsuario?: SortOrder
  }

  export type CursosMallaCreateNestedManyWithoutMallaInput = {
    create?: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput> | CursosMallaCreateWithoutMallaInput[] | CursosMallaUncheckedCreateWithoutMallaInput[]
    connectOrCreate?: CursosMallaCreateOrConnectWithoutMallaInput | CursosMallaCreateOrConnectWithoutMallaInput[]
    createMany?: CursosMallaCreateManyMallaInputEnvelope
    connect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
  }

  export type CursosMallaUncheckedCreateNestedManyWithoutMallaInput = {
    create?: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput> | CursosMallaCreateWithoutMallaInput[] | CursosMallaUncheckedCreateWithoutMallaInput[]
    connectOrCreate?: CursosMallaCreateOrConnectWithoutMallaInput | CursosMallaCreateOrConnectWithoutMallaInput[]
    createMany?: CursosMallaCreateManyMallaInputEnvelope
    connect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CursosMallaUpdateManyWithoutMallaNestedInput = {
    create?: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput> | CursosMallaCreateWithoutMallaInput[] | CursosMallaUncheckedCreateWithoutMallaInput[]
    connectOrCreate?: CursosMallaCreateOrConnectWithoutMallaInput | CursosMallaCreateOrConnectWithoutMallaInput[]
    upsert?: CursosMallaUpsertWithWhereUniqueWithoutMallaInput | CursosMallaUpsertWithWhereUniqueWithoutMallaInput[]
    createMany?: CursosMallaCreateManyMallaInputEnvelope
    set?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    disconnect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    delete?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    connect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    update?: CursosMallaUpdateWithWhereUniqueWithoutMallaInput | CursosMallaUpdateWithWhereUniqueWithoutMallaInput[]
    updateMany?: CursosMallaUpdateManyWithWhereWithoutMallaInput | CursosMallaUpdateManyWithWhereWithoutMallaInput[]
    deleteMany?: CursosMallaScalarWhereInput | CursosMallaScalarWhereInput[]
  }

  export type CursosMallaUncheckedUpdateManyWithoutMallaNestedInput = {
    create?: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput> | CursosMallaCreateWithoutMallaInput[] | CursosMallaUncheckedCreateWithoutMallaInput[]
    connectOrCreate?: CursosMallaCreateOrConnectWithoutMallaInput | CursosMallaCreateOrConnectWithoutMallaInput[]
    upsert?: CursosMallaUpsertWithWhereUniqueWithoutMallaInput | CursosMallaUpsertWithWhereUniqueWithoutMallaInput[]
    createMany?: CursosMallaCreateManyMallaInputEnvelope
    set?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    disconnect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    delete?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    connect?: CursosMallaWhereUniqueInput | CursosMallaWhereUniqueInput[]
    update?: CursosMallaUpdateWithWhereUniqueWithoutMallaInput | CursosMallaUpdateWithWhereUniqueWithoutMallaInput[]
    updateMany?: CursosMallaUpdateManyWithWhereWithoutMallaInput | CursosMallaUpdateManyWithWhereWithoutMallaInput[]
    deleteMany?: CursosMallaScalarWhereInput | CursosMallaScalarWhereInput[]
  }

  export type MallaCreateNestedOneWithoutCursosMallaInput = {
    create?: XOR<MallaCreateWithoutCursosMallaInput, MallaUncheckedCreateWithoutCursosMallaInput>
    connectOrCreate?: MallaCreateOrConnectWithoutCursosMallaInput
    connect?: MallaWhereUniqueInput
  }

  export type CursoCreateNestedManyWithoutCursosMallaInput = {
    create?: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput> | CursoCreateWithoutCursosMallaInput[] | CursoUncheckedCreateWithoutCursosMallaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCursosMallaInput | CursoCreateOrConnectWithoutCursosMallaInput[]
    createMany?: CursoCreateManyCursosMallaInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type CursoUncheckedCreateNestedManyWithoutCursosMallaInput = {
    create?: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput> | CursoCreateWithoutCursosMallaInput[] | CursoUncheckedCreateWithoutCursosMallaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCursosMallaInput | CursoCreateOrConnectWithoutCursosMallaInput[]
    createMany?: CursoCreateManyCursosMallaInputEnvelope
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
  }

  export type MallaUpdateOneRequiredWithoutCursosMallaNestedInput = {
    create?: XOR<MallaCreateWithoutCursosMallaInput, MallaUncheckedCreateWithoutCursosMallaInput>
    connectOrCreate?: MallaCreateOrConnectWithoutCursosMallaInput
    upsert?: MallaUpsertWithoutCursosMallaInput
    connect?: MallaWhereUniqueInput
    update?: XOR<XOR<MallaUpdateToOneWithWhereWithoutCursosMallaInput, MallaUpdateWithoutCursosMallaInput>, MallaUncheckedUpdateWithoutCursosMallaInput>
  }

  export type CursoUpdateManyWithoutCursosMallaNestedInput = {
    create?: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput> | CursoCreateWithoutCursosMallaInput[] | CursoUncheckedCreateWithoutCursosMallaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCursosMallaInput | CursoCreateOrConnectWithoutCursosMallaInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutCursosMallaInput | CursoUpsertWithWhereUniqueWithoutCursosMallaInput[]
    createMany?: CursoCreateManyCursosMallaInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutCursosMallaInput | CursoUpdateWithWhereUniqueWithoutCursosMallaInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutCursosMallaInput | CursoUpdateManyWithWhereWithoutCursosMallaInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type CursoUncheckedUpdateManyWithoutCursosMallaNestedInput = {
    create?: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput> | CursoCreateWithoutCursosMallaInput[] | CursoUncheckedCreateWithoutCursosMallaInput[]
    connectOrCreate?: CursoCreateOrConnectWithoutCursosMallaInput | CursoCreateOrConnectWithoutCursosMallaInput[]
    upsert?: CursoUpsertWithWhereUniqueWithoutCursosMallaInput | CursoUpsertWithWhereUniqueWithoutCursosMallaInput[]
    createMany?: CursoCreateManyCursosMallaInputEnvelope
    set?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    disconnect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    delete?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    connect?: CursoWhereUniqueInput | CursoWhereUniqueInput[]
    update?: CursoUpdateWithWhereUniqueWithoutCursosMallaInput | CursoUpdateWithWhereUniqueWithoutCursosMallaInput[]
    updateMany?: CursoUpdateManyWithWhereWithoutCursosMallaInput | CursoUpdateManyWithWhereWithoutCursosMallaInput[]
    deleteMany?: CursoScalarWhereInput | CursoScalarWhereInput[]
  }

  export type CursosMallaCreateNestedOneWithoutCursosInput = {
    create?: XOR<CursosMallaCreateWithoutCursosInput, CursosMallaUncheckedCreateWithoutCursosInput>
    connectOrCreate?: CursosMallaCreateOrConnectWithoutCursosInput
    connect?: CursosMallaWhereUniqueInput
  }

  export type CursoMatriculadoCreateNestedManyWithoutCursoInput = {
    create?: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput> | CursoMatriculadoCreateWithoutCursoInput[] | CursoMatriculadoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutCursoInput | CursoMatriculadoCreateOrConnectWithoutCursoInput[]
    createMany?: CursoMatriculadoCreateManyCursoInputEnvelope
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
  }

  export type CursoMatriculadoUncheckedCreateNestedManyWithoutCursoInput = {
    create?: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput> | CursoMatriculadoCreateWithoutCursoInput[] | CursoMatriculadoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutCursoInput | CursoMatriculadoCreateOrConnectWithoutCursoInput[]
    createMany?: CursoMatriculadoCreateManyCursoInputEnvelope
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
  }

  export type CursosMallaUpdateOneWithoutCursosNestedInput = {
    create?: XOR<CursosMallaCreateWithoutCursosInput, CursosMallaUncheckedCreateWithoutCursosInput>
    connectOrCreate?: CursosMallaCreateOrConnectWithoutCursosInput
    upsert?: CursosMallaUpsertWithoutCursosInput
    disconnect?: boolean
    delete?: CursosMallaWhereInput | boolean
    connect?: CursosMallaWhereUniqueInput
    update?: XOR<XOR<CursosMallaUpdateToOneWithWhereWithoutCursosInput, CursosMallaUpdateWithoutCursosInput>, CursosMallaUncheckedUpdateWithoutCursosInput>
  }

  export type CursoMatriculadoUpdateManyWithoutCursoNestedInput = {
    create?: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput> | CursoMatriculadoCreateWithoutCursoInput[] | CursoMatriculadoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutCursoInput | CursoMatriculadoCreateOrConnectWithoutCursoInput[]
    upsert?: CursoMatriculadoUpsertWithWhereUniqueWithoutCursoInput | CursoMatriculadoUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: CursoMatriculadoCreateManyCursoInputEnvelope
    set?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    disconnect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    delete?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    update?: CursoMatriculadoUpdateWithWhereUniqueWithoutCursoInput | CursoMatriculadoUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: CursoMatriculadoUpdateManyWithWhereWithoutCursoInput | CursoMatriculadoUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type CursoMatriculadoUncheckedUpdateManyWithoutCursoNestedInput = {
    create?: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput> | CursoMatriculadoCreateWithoutCursoInput[] | CursoMatriculadoUncheckedCreateWithoutCursoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutCursoInput | CursoMatriculadoCreateOrConnectWithoutCursoInput[]
    upsert?: CursoMatriculadoUpsertWithWhereUniqueWithoutCursoInput | CursoMatriculadoUpsertWithWhereUniqueWithoutCursoInput[]
    createMany?: CursoMatriculadoCreateManyCursoInputEnvelope
    set?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    disconnect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    delete?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    update?: CursoMatriculadoUpdateWithWhereUniqueWithoutCursoInput | CursoMatriculadoUpdateWithWhereUniqueWithoutCursoInput[]
    updateMany?: CursoMatriculadoUpdateManyWithWhereWithoutCursoInput | CursoMatriculadoUpdateManyWithWhereWithoutCursoInput[]
    deleteMany?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
  }

  export type CursoMatriculadoCreatediasClaseInput = {
    set: number[]
  }

  export type CursoCreateNestedOneWithoutCursoMatriculadoInput = {
    create?: XOR<CursoCreateWithoutCursoMatriculadoInput, CursoUncheckedCreateWithoutCursoMatriculadoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCursoMatriculadoInput
    connect?: CursoWhereUniqueInput
  }

  export type PeriodoMatriculadoCreateNestedOneWithoutCursosMatriculadosInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedCreateWithoutCursosMatriculadosInput>
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutCursosMatriculadosInput
    connect?: PeriodoMatriculadoWhereUniqueInput
  }

  export type NotaCreateNestedManyWithoutCursoMatriculadoInput = {
    create?: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput> | NotaCreateWithoutCursoMatriculadoInput[] | NotaUncheckedCreateWithoutCursoMatriculadoInput[]
    connectOrCreate?: NotaCreateOrConnectWithoutCursoMatriculadoInput | NotaCreateOrConnectWithoutCursoMatriculadoInput[]
    createMany?: NotaCreateManyCursoMatriculadoInputEnvelope
    connect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
  }

  export type NotaUncheckedCreateNestedManyWithoutCursoMatriculadoInput = {
    create?: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput> | NotaCreateWithoutCursoMatriculadoInput[] | NotaUncheckedCreateWithoutCursoMatriculadoInput[]
    connectOrCreate?: NotaCreateOrConnectWithoutCursoMatriculadoInput | NotaCreateOrConnectWithoutCursoMatriculadoInput[]
    createMany?: NotaCreateManyCursoMatriculadoInputEnvelope
    connect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CursoMatriculadoUpdatediasClaseInput = {
    set?: number[]
    push?: number | number[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CursoUpdateOneRequiredWithoutCursoMatriculadoNestedInput = {
    create?: XOR<CursoCreateWithoutCursoMatriculadoInput, CursoUncheckedCreateWithoutCursoMatriculadoInput>
    connectOrCreate?: CursoCreateOrConnectWithoutCursoMatriculadoInput
    upsert?: CursoUpsertWithoutCursoMatriculadoInput
    connect?: CursoWhereUniqueInput
    update?: XOR<XOR<CursoUpdateToOneWithWhereWithoutCursoMatriculadoInput, CursoUpdateWithoutCursoMatriculadoInput>, CursoUncheckedUpdateWithoutCursoMatriculadoInput>
  }

  export type PeriodoMatriculadoUpdateOneWithoutCursosMatriculadosNestedInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedCreateWithoutCursosMatriculadosInput>
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutCursosMatriculadosInput
    upsert?: PeriodoMatriculadoUpsertWithoutCursosMatriculadosInput
    disconnect?: boolean
    delete?: PeriodoMatriculadoWhereInput | boolean
    connect?: PeriodoMatriculadoWhereUniqueInput
    update?: XOR<XOR<PeriodoMatriculadoUpdateToOneWithWhereWithoutCursosMatriculadosInput, PeriodoMatriculadoUpdateWithoutCursosMatriculadosInput>, PeriodoMatriculadoUncheckedUpdateWithoutCursosMatriculadosInput>
  }

  export type NotaUpdateManyWithoutCursoMatriculadoNestedInput = {
    create?: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput> | NotaCreateWithoutCursoMatriculadoInput[] | NotaUncheckedCreateWithoutCursoMatriculadoInput[]
    connectOrCreate?: NotaCreateOrConnectWithoutCursoMatriculadoInput | NotaCreateOrConnectWithoutCursoMatriculadoInput[]
    upsert?: NotaUpsertWithWhereUniqueWithoutCursoMatriculadoInput | NotaUpsertWithWhereUniqueWithoutCursoMatriculadoInput[]
    createMany?: NotaCreateManyCursoMatriculadoInputEnvelope
    set?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    disconnect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    delete?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    connect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    update?: NotaUpdateWithWhereUniqueWithoutCursoMatriculadoInput | NotaUpdateWithWhereUniqueWithoutCursoMatriculadoInput[]
    updateMany?: NotaUpdateManyWithWhereWithoutCursoMatriculadoInput | NotaUpdateManyWithWhereWithoutCursoMatriculadoInput[]
    deleteMany?: NotaScalarWhereInput | NotaScalarWhereInput[]
  }

  export type NotaUncheckedUpdateManyWithoutCursoMatriculadoNestedInput = {
    create?: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput> | NotaCreateWithoutCursoMatriculadoInput[] | NotaUncheckedCreateWithoutCursoMatriculadoInput[]
    connectOrCreate?: NotaCreateOrConnectWithoutCursoMatriculadoInput | NotaCreateOrConnectWithoutCursoMatriculadoInput[]
    upsert?: NotaUpsertWithWhereUniqueWithoutCursoMatriculadoInput | NotaUpsertWithWhereUniqueWithoutCursoMatriculadoInput[]
    createMany?: NotaCreateManyCursoMatriculadoInputEnvelope
    set?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    disconnect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    delete?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    connect?: NotaWhereUniqueInput | NotaWhereUniqueInput[]
    update?: NotaUpdateWithWhereUniqueWithoutCursoMatriculadoInput | NotaUpdateWithWhereUniqueWithoutCursoMatriculadoInput[]
    updateMany?: NotaUpdateManyWithWhereWithoutCursoMatriculadoInput | NotaUpdateManyWithWhereWithoutCursoMatriculadoInput[]
    deleteMany?: NotaScalarWhereInput | NotaScalarWhereInput[]
  }

  export type CursoMatriculadoCreateNestedOneWithoutNotasInput = {
    create?: XOR<CursoMatriculadoCreateWithoutNotasInput, CursoMatriculadoUncheckedCreateWithoutNotasInput>
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutNotasInput
    connect?: CursoMatriculadoWhereUniqueInput
  }

  export type CursoMatriculadoUpdateOneRequiredWithoutNotasNestedInput = {
    create?: XOR<CursoMatriculadoCreateWithoutNotasInput, CursoMatriculadoUncheckedCreateWithoutNotasInput>
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutNotasInput
    upsert?: CursoMatriculadoUpsertWithoutNotasInput
    connect?: CursoMatriculadoWhereUniqueInput
    update?: XOR<XOR<CursoMatriculadoUpdateToOneWithWhereWithoutNotasInput, CursoMatriculadoUpdateWithoutNotasInput>, CursoMatriculadoUncheckedUpdateWithoutNotasInput>
  }

  export type UsuarioCreateNestedOneWithoutPagosInput = {
    create?: XOR<UsuarioCreateWithoutPagosInput, UsuarioUncheckedCreateWithoutPagosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPagosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PeriodoMatriculadoCreateNestedOneWithoutPagosInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutPagosInput, PeriodoMatriculadoUncheckedCreateWithoutPagosInput>
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutPagosInput
    connect?: PeriodoMatriculadoWhereUniqueInput
  }

  export type UsuarioUpdateOneWithoutPagosNestedInput = {
    create?: XOR<UsuarioCreateWithoutPagosInput, UsuarioUncheckedCreateWithoutPagosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPagosInput
    upsert?: UsuarioUpsertWithoutPagosInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPagosInput, UsuarioUpdateWithoutPagosInput>, UsuarioUncheckedUpdateWithoutPagosInput>
  }

  export type PeriodoMatriculadoUpdateOneWithoutPagosNestedInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutPagosInput, PeriodoMatriculadoUncheckedCreateWithoutPagosInput>
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutPagosInput
    upsert?: PeriodoMatriculadoUpsertWithoutPagosInput
    disconnect?: boolean
    delete?: PeriodoMatriculadoWhereInput | boolean
    connect?: PeriodoMatriculadoWhereUniqueInput
    update?: XOR<XOR<PeriodoMatriculadoUpdateToOneWithWhereWithoutPagosInput, PeriodoMatriculadoUpdateWithoutPagosInput>, PeriodoMatriculadoUncheckedUpdateWithoutPagosInput>
  }

  export type ServiciosCreatefechasInput = {
    set: Date[] | string[]
  }

  export type ServiciosUtilizadosCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput> | ServiciosUtilizadosCreateWithoutServicioInput[] | ServiciosUtilizadosUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutServicioInput | ServiciosUtilizadosCreateOrConnectWithoutServicioInput[]
    createMany?: ServiciosUtilizadosCreateManyServicioInputEnvelope
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
  }

  export type ServiciosUtilizadosUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput> | ServiciosUtilizadosCreateWithoutServicioInput[] | ServiciosUtilizadosUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutServicioInput | ServiciosUtilizadosCreateOrConnectWithoutServicioInput[]
    createMany?: ServiciosUtilizadosCreateManyServicioInputEnvelope
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
  }

  export type ServiciosUpdatefechasInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type ServiciosUtilizadosUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput> | ServiciosUtilizadosCreateWithoutServicioInput[] | ServiciosUtilizadosUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutServicioInput | ServiciosUtilizadosCreateOrConnectWithoutServicioInput[]
    upsert?: ServiciosUtilizadosUpsertWithWhereUniqueWithoutServicioInput | ServiciosUtilizadosUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServiciosUtilizadosCreateManyServicioInputEnvelope
    set?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    disconnect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    delete?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    update?: ServiciosUtilizadosUpdateWithWhereUniqueWithoutServicioInput | ServiciosUtilizadosUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServiciosUtilizadosUpdateManyWithWhereWithoutServicioInput | ServiciosUtilizadosUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
  }

  export type ServiciosUtilizadosUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput> | ServiciosUtilizadosCreateWithoutServicioInput[] | ServiciosUtilizadosUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutServicioInput | ServiciosUtilizadosCreateOrConnectWithoutServicioInput[]
    upsert?: ServiciosUtilizadosUpsertWithWhereUniqueWithoutServicioInput | ServiciosUtilizadosUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServiciosUtilizadosCreateManyServicioInputEnvelope
    set?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    disconnect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    delete?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    update?: ServiciosUtilizadosUpdateWithWhereUniqueWithoutServicioInput | ServiciosUtilizadosUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServiciosUtilizadosUpdateManyWithWhereWithoutServicioInput | ServiciosUtilizadosUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
  }

  export type TramitesCreaterequisitosInput = {
    set: string[]
  }

  export type TramitesRealizadosCreateNestedManyWithoutTramiteInput = {
    create?: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput> | TramitesRealizadosCreateWithoutTramiteInput[] | TramitesRealizadosUncheckedCreateWithoutTramiteInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutTramiteInput | TramitesRealizadosCreateOrConnectWithoutTramiteInput[]
    createMany?: TramitesRealizadosCreateManyTramiteInputEnvelope
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
  }

  export type TramitesRealizadosUncheckedCreateNestedManyWithoutTramiteInput = {
    create?: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput> | TramitesRealizadosCreateWithoutTramiteInput[] | TramitesRealizadosUncheckedCreateWithoutTramiteInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutTramiteInput | TramitesRealizadosCreateOrConnectWithoutTramiteInput[]
    createMany?: TramitesRealizadosCreateManyTramiteInputEnvelope
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type TramitesUpdaterequisitosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TramitesRealizadosUpdateManyWithoutTramiteNestedInput = {
    create?: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput> | TramitesRealizadosCreateWithoutTramiteInput[] | TramitesRealizadosUncheckedCreateWithoutTramiteInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutTramiteInput | TramitesRealizadosCreateOrConnectWithoutTramiteInput[]
    upsert?: TramitesRealizadosUpsertWithWhereUniqueWithoutTramiteInput | TramitesRealizadosUpsertWithWhereUniqueWithoutTramiteInput[]
    createMany?: TramitesRealizadosCreateManyTramiteInputEnvelope
    set?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    disconnect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    delete?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    update?: TramitesRealizadosUpdateWithWhereUniqueWithoutTramiteInput | TramitesRealizadosUpdateWithWhereUniqueWithoutTramiteInput[]
    updateMany?: TramitesRealizadosUpdateManyWithWhereWithoutTramiteInput | TramitesRealizadosUpdateManyWithWhereWithoutTramiteInput[]
    deleteMany?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
  }

  export type TramitesRealizadosUncheckedUpdateManyWithoutTramiteNestedInput = {
    create?: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput> | TramitesRealizadosCreateWithoutTramiteInput[] | TramitesRealizadosUncheckedCreateWithoutTramiteInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutTramiteInput | TramitesRealizadosCreateOrConnectWithoutTramiteInput[]
    upsert?: TramitesRealizadosUpsertWithWhereUniqueWithoutTramiteInput | TramitesRealizadosUpsertWithWhereUniqueWithoutTramiteInput[]
    createMany?: TramitesRealizadosCreateManyTramiteInputEnvelope
    set?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    disconnect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    delete?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    update?: TramitesRealizadosUpdateWithWhereUniqueWithoutTramiteInput | TramitesRealizadosUpdateWithWhereUniqueWithoutTramiteInput[]
    updateMany?: TramitesRealizadosUpdateManyWithWhereWithoutTramiteInput | TramitesRealizadosUpdateManyWithWhereWithoutTramiteInput[]
    deleteMany?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPeriodoMatriculadoInput = {
    create?: XOR<UsuarioCreateWithoutPeriodoMatriculadoInput, UsuarioUncheckedCreateWithoutPeriodoMatriculadoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPeriodoMatriculadoInput
    connect?: UsuarioWhereUniqueInput
  }

  export type PagosCreateNestedManyWithoutPeriodoMatriculadoInput = {
    create?: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput> | PagosCreateWithoutPeriodoMatriculadoInput[] | PagosUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutPeriodoMatriculadoInput | PagosCreateOrConnectWithoutPeriodoMatriculadoInput[]
    createMany?: PagosCreateManyPeriodoMatriculadoInputEnvelope
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
  }

  export type CursoMatriculadoCreateNestedManyWithoutPeriodoMatriculadoInput = {
    create?: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput> | CursoMatriculadoCreateWithoutPeriodoMatriculadoInput[] | CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput | CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput[]
    createMany?: CursoMatriculadoCreateManyPeriodoMatriculadoInputEnvelope
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
  }

  export type PagosUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput = {
    create?: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput> | PagosCreateWithoutPeriodoMatriculadoInput[] | PagosUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutPeriodoMatriculadoInput | PagosCreateOrConnectWithoutPeriodoMatriculadoInput[]
    createMany?: PagosCreateManyPeriodoMatriculadoInputEnvelope
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
  }

  export type CursoMatriculadoUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput = {
    create?: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput> | CursoMatriculadoCreateWithoutPeriodoMatriculadoInput[] | CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput | CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput[]
    createMany?: CursoMatriculadoCreateManyPeriodoMatriculadoInputEnvelope
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
  }

  export type UsuarioUpdateOneWithoutPeriodoMatriculadoNestedInput = {
    create?: XOR<UsuarioCreateWithoutPeriodoMatriculadoInput, UsuarioUncheckedCreateWithoutPeriodoMatriculadoInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPeriodoMatriculadoInput
    upsert?: UsuarioUpsertWithoutPeriodoMatriculadoInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPeriodoMatriculadoInput, UsuarioUpdateWithoutPeriodoMatriculadoInput>, UsuarioUncheckedUpdateWithoutPeriodoMatriculadoInput>
  }

  export type PagosUpdateManyWithoutPeriodoMatriculadoNestedInput = {
    create?: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput> | PagosCreateWithoutPeriodoMatriculadoInput[] | PagosUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutPeriodoMatriculadoInput | PagosCreateOrConnectWithoutPeriodoMatriculadoInput[]
    upsert?: PagosUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput | PagosUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    createMany?: PagosCreateManyPeriodoMatriculadoInputEnvelope
    set?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    disconnect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    delete?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    update?: PagosUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput | PagosUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    updateMany?: PagosUpdateManyWithWhereWithoutPeriodoMatriculadoInput | PagosUpdateManyWithWhereWithoutPeriodoMatriculadoInput[]
    deleteMany?: PagosScalarWhereInput | PagosScalarWhereInput[]
  }

  export type CursoMatriculadoUpdateManyWithoutPeriodoMatriculadoNestedInput = {
    create?: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput> | CursoMatriculadoCreateWithoutPeriodoMatriculadoInput[] | CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput | CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput[]
    upsert?: CursoMatriculadoUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput | CursoMatriculadoUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    createMany?: CursoMatriculadoCreateManyPeriodoMatriculadoInputEnvelope
    set?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    disconnect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    delete?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    update?: CursoMatriculadoUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput | CursoMatriculadoUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    updateMany?: CursoMatriculadoUpdateManyWithWhereWithoutPeriodoMatriculadoInput | CursoMatriculadoUpdateManyWithWhereWithoutPeriodoMatriculadoInput[]
    deleteMany?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
  }

  export type PagosUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput = {
    create?: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput> | PagosCreateWithoutPeriodoMatriculadoInput[] | PagosUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutPeriodoMatriculadoInput | PagosCreateOrConnectWithoutPeriodoMatriculadoInput[]
    upsert?: PagosUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput | PagosUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    createMany?: PagosCreateManyPeriodoMatriculadoInputEnvelope
    set?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    disconnect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    delete?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    update?: PagosUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput | PagosUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    updateMany?: PagosUpdateManyWithWhereWithoutPeriodoMatriculadoInput | PagosUpdateManyWithWhereWithoutPeriodoMatriculadoInput[]
    deleteMany?: PagosScalarWhereInput | PagosScalarWhereInput[]
  }

  export type CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput = {
    create?: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput> | CursoMatriculadoCreateWithoutPeriodoMatriculadoInput[] | CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput[]
    connectOrCreate?: CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput | CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput[]
    upsert?: CursoMatriculadoUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput | CursoMatriculadoUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    createMany?: CursoMatriculadoCreateManyPeriodoMatriculadoInputEnvelope
    set?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    disconnect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    delete?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    connect?: CursoMatriculadoWhereUniqueInput | CursoMatriculadoWhereUniqueInput[]
    update?: CursoMatriculadoUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput | CursoMatriculadoUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput[]
    updateMany?: CursoMatriculadoUpdateManyWithWhereWithoutPeriodoMatriculadoInput | CursoMatriculadoUpdateManyWithWhereWithoutPeriodoMatriculadoInput[]
    deleteMany?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
  }

  export type TramitesRealizadosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput> | TramitesRealizadosCreateWithoutUsuarioInput[] | TramitesRealizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutUsuarioInput | TramitesRealizadosCreateOrConnectWithoutUsuarioInput[]
    createMany?: TramitesRealizadosCreateManyUsuarioInputEnvelope
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
  }

  export type ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput> | ServiciosUtilizadosCreateWithoutUsuarioInput[] | ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput | ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput[]
    createMany?: ServiciosUtilizadosCreateManyUsuarioInputEnvelope
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
  }

  export type PagosCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput> | PagosCreateWithoutUsuarioInput[] | PagosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutUsuarioInput | PagosCreateOrConnectWithoutUsuarioInput[]
    createMany?: PagosCreateManyUsuarioInputEnvelope
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
  }

  export type PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput> | PeriodoMatriculadoCreateWithoutUsuarioInput[] | PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput | PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PeriodoMatriculadoCreateManyUsuarioInputEnvelope
    connect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput> | EventCreateWithoutUsuarioInput[] | EventUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUsuarioInput | EventCreateOrConnectWithoutUsuarioInput[]
    createMany?: EventCreateManyUsuarioInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput> | TaskCreateWithoutUsuarioInput[] | TaskUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUsuarioInput | TaskCreateOrConnectWithoutUsuarioInput[]
    createMany?: TaskCreateManyUsuarioInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput> | TramitesRealizadosCreateWithoutUsuarioInput[] | TramitesRealizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutUsuarioInput | TramitesRealizadosCreateOrConnectWithoutUsuarioInput[]
    createMany?: TramitesRealizadosCreateManyUsuarioInputEnvelope
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
  }

  export type ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput> | ServiciosUtilizadosCreateWithoutUsuarioInput[] | ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput | ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput[]
    createMany?: ServiciosUtilizadosCreateManyUsuarioInputEnvelope
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
  }

  export type PagosUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput> | PagosCreateWithoutUsuarioInput[] | PagosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutUsuarioInput | PagosCreateOrConnectWithoutUsuarioInput[]
    createMany?: PagosCreateManyUsuarioInputEnvelope
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
  }

  export type PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput> | PeriodoMatriculadoCreateWithoutUsuarioInput[] | PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput | PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: PeriodoMatriculadoCreateManyUsuarioInputEnvelope
    connect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput> | EventCreateWithoutUsuarioInput[] | EventUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUsuarioInput | EventCreateOrConnectWithoutUsuarioInput[]
    createMany?: EventCreateManyUsuarioInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput> | TaskCreateWithoutUsuarioInput[] | TaskUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUsuarioInput | TaskCreateOrConnectWithoutUsuarioInput[]
    createMany?: TaskCreateManyUsuarioInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type TramitesRealizadosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput> | TramitesRealizadosCreateWithoutUsuarioInput[] | TramitesRealizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutUsuarioInput | TramitesRealizadosCreateOrConnectWithoutUsuarioInput[]
    upsert?: TramitesRealizadosUpsertWithWhereUniqueWithoutUsuarioInput | TramitesRealizadosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TramitesRealizadosCreateManyUsuarioInputEnvelope
    set?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    disconnect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    delete?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    update?: TramitesRealizadosUpdateWithWhereUniqueWithoutUsuarioInput | TramitesRealizadosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TramitesRealizadosUpdateManyWithWhereWithoutUsuarioInput | TramitesRealizadosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
  }

  export type ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput> | ServiciosUtilizadosCreateWithoutUsuarioInput[] | ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput | ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput[]
    upsert?: ServiciosUtilizadosUpsertWithWhereUniqueWithoutUsuarioInput | ServiciosUtilizadosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ServiciosUtilizadosCreateManyUsuarioInputEnvelope
    set?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    disconnect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    delete?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    update?: ServiciosUtilizadosUpdateWithWhereUniqueWithoutUsuarioInput | ServiciosUtilizadosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ServiciosUtilizadosUpdateManyWithWhereWithoutUsuarioInput | ServiciosUtilizadosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
  }

  export type PagosUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput> | PagosCreateWithoutUsuarioInput[] | PagosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutUsuarioInput | PagosCreateOrConnectWithoutUsuarioInput[]
    upsert?: PagosUpsertWithWhereUniqueWithoutUsuarioInput | PagosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PagosCreateManyUsuarioInputEnvelope
    set?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    disconnect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    delete?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    update?: PagosUpdateWithWhereUniqueWithoutUsuarioInput | PagosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PagosUpdateManyWithWhereWithoutUsuarioInput | PagosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PagosScalarWhereInput | PagosScalarWhereInput[]
  }

  export type PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput> | PeriodoMatriculadoCreateWithoutUsuarioInput[] | PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput | PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PeriodoMatriculadoUpsertWithWhereUniqueWithoutUsuarioInput | PeriodoMatriculadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PeriodoMatriculadoCreateManyUsuarioInputEnvelope
    set?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    disconnect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    delete?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    connect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    update?: PeriodoMatriculadoUpdateWithWhereUniqueWithoutUsuarioInput | PeriodoMatriculadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PeriodoMatriculadoUpdateManyWithWhereWithoutUsuarioInput | PeriodoMatriculadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PeriodoMatriculadoScalarWhereInput | PeriodoMatriculadoScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EventUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput> | EventCreateWithoutUsuarioInput[] | EventUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUsuarioInput | EventCreateOrConnectWithoutUsuarioInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUsuarioInput | EventUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EventCreateManyUsuarioInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUsuarioInput | EventUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUsuarioInput | EventUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput> | TaskCreateWithoutUsuarioInput[] | TaskUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUsuarioInput | TaskCreateOrConnectWithoutUsuarioInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUsuarioInput | TaskUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TaskCreateManyUsuarioInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUsuarioInput | TaskUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUsuarioInput | TaskUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput> | TramitesRealizadosCreateWithoutUsuarioInput[] | TramitesRealizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TramitesRealizadosCreateOrConnectWithoutUsuarioInput | TramitesRealizadosCreateOrConnectWithoutUsuarioInput[]
    upsert?: TramitesRealizadosUpsertWithWhereUniqueWithoutUsuarioInput | TramitesRealizadosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TramitesRealizadosCreateManyUsuarioInputEnvelope
    set?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    disconnect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    delete?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    connect?: TramitesRealizadosWhereUniqueInput | TramitesRealizadosWhereUniqueInput[]
    update?: TramitesRealizadosUpdateWithWhereUniqueWithoutUsuarioInput | TramitesRealizadosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TramitesRealizadosUpdateManyWithWhereWithoutUsuarioInput | TramitesRealizadosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
  }

  export type ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput> | ServiciosUtilizadosCreateWithoutUsuarioInput[] | ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput | ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput[]
    upsert?: ServiciosUtilizadosUpsertWithWhereUniqueWithoutUsuarioInput | ServiciosUtilizadosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ServiciosUtilizadosCreateManyUsuarioInputEnvelope
    set?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    disconnect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    delete?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    connect?: ServiciosUtilizadosWhereUniqueInput | ServiciosUtilizadosWhereUniqueInput[]
    update?: ServiciosUtilizadosUpdateWithWhereUniqueWithoutUsuarioInput | ServiciosUtilizadosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ServiciosUtilizadosUpdateManyWithWhereWithoutUsuarioInput | ServiciosUtilizadosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
  }

  export type PagosUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput> | PagosCreateWithoutUsuarioInput[] | PagosUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PagosCreateOrConnectWithoutUsuarioInput | PagosCreateOrConnectWithoutUsuarioInput[]
    upsert?: PagosUpsertWithWhereUniqueWithoutUsuarioInput | PagosUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PagosCreateManyUsuarioInputEnvelope
    set?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    disconnect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    delete?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    connect?: PagosWhereUniqueInput | PagosWhereUniqueInput[]
    update?: PagosUpdateWithWhereUniqueWithoutUsuarioInput | PagosUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PagosUpdateManyWithWhereWithoutUsuarioInput | PagosUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PagosScalarWhereInput | PagosScalarWhereInput[]
  }

  export type PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput> | PeriodoMatriculadoCreateWithoutUsuarioInput[] | PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput | PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: PeriodoMatriculadoUpsertWithWhereUniqueWithoutUsuarioInput | PeriodoMatriculadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PeriodoMatriculadoCreateManyUsuarioInputEnvelope
    set?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    disconnect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    delete?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    connect?: PeriodoMatriculadoWhereUniqueInput | PeriodoMatriculadoWhereUniqueInput[]
    update?: PeriodoMatriculadoUpdateWithWhereUniqueWithoutUsuarioInput | PeriodoMatriculadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PeriodoMatriculadoUpdateManyWithWhereWithoutUsuarioInput | PeriodoMatriculadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PeriodoMatriculadoScalarWhereInput | PeriodoMatriculadoScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput> | EventCreateWithoutUsuarioInput[] | EventUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUsuarioInput | EventCreateOrConnectWithoutUsuarioInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUsuarioInput | EventUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EventCreateManyUsuarioInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUsuarioInput | EventUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUsuarioInput | EventUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput> | TaskCreateWithoutUsuarioInput[] | TaskUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUsuarioInput | TaskCreateOrConnectWithoutUsuarioInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUsuarioInput | TaskUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TaskCreateManyUsuarioInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUsuarioInput | TaskUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUsuarioInput | TaskUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UsuarioCreateWithoutAccountsInput, UsuarioUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAccountsInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UsuarioUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UsuarioCreateWithoutAccountsInput, UsuarioUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAccountsInput
    upsert?: UsuarioUpsertWithoutAccountsInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAccountsInput, UsuarioUpdateWithoutAccountsInput>, UsuarioUncheckedUpdateWithoutAccountsInput>
  }

  export type UsuarioCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UsuarioCreateWithoutSessionsInput, UsuarioUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSessionsInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UsuarioCreateWithoutSessionsInput, UsuarioUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSessionsInput
    upsert?: UsuarioUpsertWithoutSessionsInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutSessionsInput, UsuarioUpdateWithoutSessionsInput>, UsuarioUncheckedUpdateWithoutSessionsInput>
  }

  export type TramitesRealizadosCreatedocumentosInput = {
    set: string[]
  }

  export type TramitesCreateNestedOneWithoutTramitesRealizadosInput = {
    create?: XOR<TramitesCreateWithoutTramitesRealizadosInput, TramitesUncheckedCreateWithoutTramitesRealizadosInput>
    connectOrCreate?: TramitesCreateOrConnectWithoutTramitesRealizadosInput
    connect?: TramitesWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutTramitesRealizadosInput = {
    create?: XOR<UsuarioCreateWithoutTramitesRealizadosInput, UsuarioUncheckedCreateWithoutTramitesRealizadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTramitesRealizadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type TramitesRealizadosUpdatedocumentosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TramitesUpdateOneWithoutTramitesRealizadosNestedInput = {
    create?: XOR<TramitesCreateWithoutTramitesRealizadosInput, TramitesUncheckedCreateWithoutTramitesRealizadosInput>
    connectOrCreate?: TramitesCreateOrConnectWithoutTramitesRealizadosInput
    upsert?: TramitesUpsertWithoutTramitesRealizadosInput
    disconnect?: boolean
    delete?: TramitesWhereInput | boolean
    connect?: TramitesWhereUniqueInput
    update?: XOR<XOR<TramitesUpdateToOneWithWhereWithoutTramitesRealizadosInput, TramitesUpdateWithoutTramitesRealizadosInput>, TramitesUncheckedUpdateWithoutTramitesRealizadosInput>
  }

  export type UsuarioUpdateOneWithoutTramitesRealizadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutTramitesRealizadosInput, UsuarioUncheckedCreateWithoutTramitesRealizadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTramitesRealizadosInput
    upsert?: UsuarioUpsertWithoutTramitesRealizadosInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTramitesRealizadosInput, UsuarioUpdateWithoutTramitesRealizadosInput>, UsuarioUncheckedUpdateWithoutTramitesRealizadosInput>
  }

  export type ServiciosCreateNestedOneWithoutServiciosUtilizadosInput = {
    create?: XOR<ServiciosCreateWithoutServiciosUtilizadosInput, ServiciosUncheckedCreateWithoutServiciosUtilizadosInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutServiciosUtilizadosInput
    connect?: ServiciosWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutServiciosUtilizadosInput = {
    create?: XOR<UsuarioCreateWithoutServiciosUtilizadosInput, UsuarioUncheckedCreateWithoutServiciosUtilizadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutServiciosUtilizadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ServiciosUpdateOneWithoutServiciosUtilizadosNestedInput = {
    create?: XOR<ServiciosCreateWithoutServiciosUtilizadosInput, ServiciosUncheckedCreateWithoutServiciosUtilizadosInput>
    connectOrCreate?: ServiciosCreateOrConnectWithoutServiciosUtilizadosInput
    upsert?: ServiciosUpsertWithoutServiciosUtilizadosInput
    disconnect?: boolean
    delete?: ServiciosWhereInput | boolean
    connect?: ServiciosWhereUniqueInput
    update?: XOR<XOR<ServiciosUpdateToOneWithWhereWithoutServiciosUtilizadosInput, ServiciosUpdateWithoutServiciosUtilizadosInput>, ServiciosUncheckedUpdateWithoutServiciosUtilizadosInput>
  }

  export type UsuarioUpdateOneWithoutServiciosUtilizadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutServiciosUtilizadosInput, UsuarioUncheckedCreateWithoutServiciosUtilizadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutServiciosUtilizadosInput
    upsert?: UsuarioUpsertWithoutServiciosUtilizadosInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutServiciosUtilizadosInput, UsuarioUpdateWithoutServiciosUtilizadosInput>, UsuarioUncheckedUpdateWithoutServiciosUtilizadosInput>
  }

  export type UsuarioCreateNestedOneWithoutEventsInput = {
    create?: XOR<UsuarioCreateWithoutEventsInput, UsuarioUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEventsInput
    connect?: UsuarioWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsuarioUpdateOneWithoutEventsNestedInput = {
    create?: XOR<UsuarioCreateWithoutEventsInput, UsuarioUncheckedCreateWithoutEventsInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEventsInput
    upsert?: UsuarioUpsertWithoutEventsInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEventsInput, UsuarioUpdateWithoutEventsInput>, UsuarioUncheckedUpdateWithoutEventsInput>
  }

  export type UsuarioCreateNestedOneWithoutTasksInput = {
    create?: XOR<UsuarioCreateWithoutTasksInput, UsuarioUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTasksInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UsuarioCreateWithoutTasksInput, UsuarioUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTasksInput
    upsert?: UsuarioUpsertWithoutTasksInput
    disconnect?: boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTasksInput, UsuarioUpdateWithoutTasksInput>, UsuarioUncheckedUpdateWithoutTasksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CursosMallaCreateWithoutMallaInput = {
    id?: string
    cursos?: CursoCreateNestedManyWithoutCursosMallaInput
  }

  export type CursosMallaUncheckedCreateWithoutMallaInput = {
    id?: string
    cursos?: CursoUncheckedCreateNestedManyWithoutCursosMallaInput
  }

  export type CursosMallaCreateOrConnectWithoutMallaInput = {
    where: CursosMallaWhereUniqueInput
    create: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput>
  }

  export type CursosMallaCreateManyMallaInputEnvelope = {
    data: CursosMallaCreateManyMallaInput | CursosMallaCreateManyMallaInput[]
  }

  export type CursosMallaUpsertWithWhereUniqueWithoutMallaInput = {
    where: CursosMallaWhereUniqueInput
    update: XOR<CursosMallaUpdateWithoutMallaInput, CursosMallaUncheckedUpdateWithoutMallaInput>
    create: XOR<CursosMallaCreateWithoutMallaInput, CursosMallaUncheckedCreateWithoutMallaInput>
  }

  export type CursosMallaUpdateWithWhereUniqueWithoutMallaInput = {
    where: CursosMallaWhereUniqueInput
    data: XOR<CursosMallaUpdateWithoutMallaInput, CursosMallaUncheckedUpdateWithoutMallaInput>
  }

  export type CursosMallaUpdateManyWithWhereWithoutMallaInput = {
    where: CursosMallaScalarWhereInput
    data: XOR<CursosMallaUpdateManyMutationInput, CursosMallaUncheckedUpdateManyWithoutMallaInput>
  }

  export type CursosMallaScalarWhereInput = {
    AND?: CursosMallaScalarWhereInput | CursosMallaScalarWhereInput[]
    OR?: CursosMallaScalarWhereInput[]
    NOT?: CursosMallaScalarWhereInput | CursosMallaScalarWhereInput[]
    id?: StringFilter<"CursosMalla"> | string
    idMalla?: StringFilter<"CursosMalla"> | string
  }

  export type MallaCreateWithoutCursosMallaInput = {
    id?: string
    cod: string
    carrera: string
    year: number
  }

  export type MallaUncheckedCreateWithoutCursosMallaInput = {
    id?: string
    cod: string
    carrera: string
    year: number
  }

  export type MallaCreateOrConnectWithoutCursosMallaInput = {
    where: MallaWhereUniqueInput
    create: XOR<MallaCreateWithoutCursosMallaInput, MallaUncheckedCreateWithoutCursosMallaInput>
  }

  export type CursoCreateWithoutCursosMallaInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    CursoMatriculado?: CursoMatriculadoCreateNestedManyWithoutCursoInput
  }

  export type CursoUncheckedCreateWithoutCursosMallaInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    CursoMatriculado?: CursoMatriculadoUncheckedCreateNestedManyWithoutCursoInput
  }

  export type CursoCreateOrConnectWithoutCursosMallaInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput>
  }

  export type CursoCreateManyCursosMallaInputEnvelope = {
    data: CursoCreateManyCursosMallaInput | CursoCreateManyCursosMallaInput[]
  }

  export type MallaUpsertWithoutCursosMallaInput = {
    update: XOR<MallaUpdateWithoutCursosMallaInput, MallaUncheckedUpdateWithoutCursosMallaInput>
    create: XOR<MallaCreateWithoutCursosMallaInput, MallaUncheckedCreateWithoutCursosMallaInput>
    where?: MallaWhereInput
  }

  export type MallaUpdateToOneWithWhereWithoutCursosMallaInput = {
    where?: MallaWhereInput
    data: XOR<MallaUpdateWithoutCursosMallaInput, MallaUncheckedUpdateWithoutCursosMallaInput>
  }

  export type MallaUpdateWithoutCursosMallaInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type MallaUncheckedUpdateWithoutCursosMallaInput = {
    cod?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type CursoUpsertWithWhereUniqueWithoutCursosMallaInput = {
    where: CursoWhereUniqueInput
    update: XOR<CursoUpdateWithoutCursosMallaInput, CursoUncheckedUpdateWithoutCursosMallaInput>
    create: XOR<CursoCreateWithoutCursosMallaInput, CursoUncheckedCreateWithoutCursosMallaInput>
  }

  export type CursoUpdateWithWhereUniqueWithoutCursosMallaInput = {
    where: CursoWhereUniqueInput
    data: XOR<CursoUpdateWithoutCursosMallaInput, CursoUncheckedUpdateWithoutCursosMallaInput>
  }

  export type CursoUpdateManyWithWhereWithoutCursosMallaInput = {
    where: CursoScalarWhereInput
    data: XOR<CursoUpdateManyMutationInput, CursoUncheckedUpdateManyWithoutCursosMallaInput>
  }

  export type CursoScalarWhereInput = {
    AND?: CursoScalarWhereInput | CursoScalarWhereInput[]
    OR?: CursoScalarWhereInput[]
    NOT?: CursoScalarWhereInput | CursoScalarWhereInput[]
    id?: StringFilter<"Curso"> | string
    cod?: StringFilter<"Curso"> | string
    nombre?: StringFilter<"Curso"> | string
    creditos?: IntFilter<"Curso"> | number
    horas?: IntFilter<"Curso"> | number
    semestre?: IntFilter<"Curso"> | number
    cursosMallaId?: StringNullableFilter<"Curso"> | string | null
  }

  export type CursosMallaCreateWithoutCursosInput = {
    id?: string
    Malla: MallaCreateNestedOneWithoutCursosMallaInput
  }

  export type CursosMallaUncheckedCreateWithoutCursosInput = {
    id?: string
    idMalla: string
  }

  export type CursosMallaCreateOrConnectWithoutCursosInput = {
    where: CursosMallaWhereUniqueInput
    create: XOR<CursosMallaCreateWithoutCursosInput, CursosMallaUncheckedCreateWithoutCursosInput>
  }

  export type CursoMatriculadoCreateWithoutCursoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedOneWithoutCursosMatriculadosInput
    notas?: NotaCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoUncheckedCreateWithoutCursoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    periodoMatriculadoId?: string | null
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    notas?: NotaUncheckedCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoCreateOrConnectWithoutCursoInput = {
    where: CursoMatriculadoWhereUniqueInput
    create: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput>
  }

  export type CursoMatriculadoCreateManyCursoInputEnvelope = {
    data: CursoMatriculadoCreateManyCursoInput | CursoMatriculadoCreateManyCursoInput[]
  }

  export type CursosMallaUpsertWithoutCursosInput = {
    update: XOR<CursosMallaUpdateWithoutCursosInput, CursosMallaUncheckedUpdateWithoutCursosInput>
    create: XOR<CursosMallaCreateWithoutCursosInput, CursosMallaUncheckedCreateWithoutCursosInput>
    where?: CursosMallaWhereInput
  }

  export type CursosMallaUpdateToOneWithWhereWithoutCursosInput = {
    where?: CursosMallaWhereInput
    data: XOR<CursosMallaUpdateWithoutCursosInput, CursosMallaUncheckedUpdateWithoutCursosInput>
  }

  export type CursosMallaUpdateWithoutCursosInput = {
    Malla?: MallaUpdateOneRequiredWithoutCursosMallaNestedInput
  }

  export type CursosMallaUncheckedUpdateWithoutCursosInput = {
    idMalla?: StringFieldUpdateOperationsInput | string
  }

  export type CursoMatriculadoUpsertWithWhereUniqueWithoutCursoInput = {
    where: CursoMatriculadoWhereUniqueInput
    update: XOR<CursoMatriculadoUpdateWithoutCursoInput, CursoMatriculadoUncheckedUpdateWithoutCursoInput>
    create: XOR<CursoMatriculadoCreateWithoutCursoInput, CursoMatriculadoUncheckedCreateWithoutCursoInput>
  }

  export type CursoMatriculadoUpdateWithWhereUniqueWithoutCursoInput = {
    where: CursoMatriculadoWhereUniqueInput
    data: XOR<CursoMatriculadoUpdateWithoutCursoInput, CursoMatriculadoUncheckedUpdateWithoutCursoInput>
  }

  export type CursoMatriculadoUpdateManyWithWhereWithoutCursoInput = {
    where: CursoMatriculadoScalarWhereInput
    data: XOR<CursoMatriculadoUpdateManyMutationInput, CursoMatriculadoUncheckedUpdateManyWithoutCursoInput>
  }

  export type CursoMatriculadoScalarWhereInput = {
    AND?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
    OR?: CursoMatriculadoScalarWhereInput[]
    NOT?: CursoMatriculadoScalarWhereInput | CursoMatriculadoScalarWhereInput[]
    id?: StringFilter<"CursoMatriculado"> | string
    averageGrade?: FloatFilter<"CursoMatriculado"> | number
    salon?: StringFilter<"CursoMatriculado"> | string
    profesor?: StringFilter<"CursoMatriculado"> | string
    idCurso?: StringFilter<"CursoMatriculado"> | string
    vez?: IntFilter<"CursoMatriculado"> | number
    status?: StringFilter<"CursoMatriculado"> | string
    periodoMatriculadoId?: StringNullableFilter<"CursoMatriculado"> | string | null
    diasClase?: IntNullableListFilter<"CursoMatriculado">
    horaInicio?: DateTimeFilter<"CursoMatriculado"> | Date | string
  }

  export type CursoCreateWithoutCursoMatriculadoInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    CursosMalla?: CursosMallaCreateNestedOneWithoutCursosInput
  }

  export type CursoUncheckedCreateWithoutCursoMatriculadoInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
    cursosMallaId?: string | null
  }

  export type CursoCreateOrConnectWithoutCursoMatriculadoInput = {
    where: CursoWhereUniqueInput
    create: XOR<CursoCreateWithoutCursoMatriculadoInput, CursoUncheckedCreateWithoutCursoMatriculadoInput>
  }

  export type PeriodoMatriculadoCreateWithoutCursosMatriculadosInput = {
    id?: string
    semestre: number
    periodo: string
    Usuario?: UsuarioCreateNestedOneWithoutPeriodoMatriculadoInput
    Pagos?: PagosCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoUncheckedCreateWithoutCursosMatriculadosInput = {
    id?: string
    semestre: number
    periodo: string
    idUsuario?: string | null
    Pagos?: PagosUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoCreateOrConnectWithoutCursosMatriculadosInput = {
    where: PeriodoMatriculadoWhereUniqueInput
    create: XOR<PeriodoMatriculadoCreateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedCreateWithoutCursosMatriculadosInput>
  }

  export type NotaCreateWithoutCursoMatriculadoInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
  }

  export type NotaUncheckedCreateWithoutCursoMatriculadoInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
  }

  export type NotaCreateOrConnectWithoutCursoMatriculadoInput = {
    where: NotaWhereUniqueInput
    create: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput>
  }

  export type NotaCreateManyCursoMatriculadoInputEnvelope = {
    data: NotaCreateManyCursoMatriculadoInput | NotaCreateManyCursoMatriculadoInput[]
  }

  export type CursoUpsertWithoutCursoMatriculadoInput = {
    update: XOR<CursoUpdateWithoutCursoMatriculadoInput, CursoUncheckedUpdateWithoutCursoMatriculadoInput>
    create: XOR<CursoCreateWithoutCursoMatriculadoInput, CursoUncheckedCreateWithoutCursoMatriculadoInput>
    where?: CursoWhereInput
  }

  export type CursoUpdateToOneWithWhereWithoutCursoMatriculadoInput = {
    where?: CursoWhereInput
    data: XOR<CursoUpdateWithoutCursoMatriculadoInput, CursoUncheckedUpdateWithoutCursoMatriculadoInput>
  }

  export type CursoUpdateWithoutCursoMatriculadoInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    CursosMalla?: CursosMallaUpdateOneWithoutCursosNestedInput
  }

  export type CursoUncheckedUpdateWithoutCursoMatriculadoInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    cursosMallaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeriodoMatriculadoUpsertWithoutCursosMatriculadosInput = {
    update: XOR<PeriodoMatriculadoUpdateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedUpdateWithoutCursosMatriculadosInput>
    create: XOR<PeriodoMatriculadoCreateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedCreateWithoutCursosMatriculadosInput>
    where?: PeriodoMatriculadoWhereInput
  }

  export type PeriodoMatriculadoUpdateToOneWithWhereWithoutCursosMatriculadosInput = {
    where?: PeriodoMatriculadoWhereInput
    data: XOR<PeriodoMatriculadoUpdateWithoutCursosMatriculadosInput, PeriodoMatriculadoUncheckedUpdateWithoutCursosMatriculadosInput>
  }

  export type PeriodoMatriculadoUpdateWithoutCursosMatriculadosInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneWithoutPeriodoMatriculadoNestedInput
    Pagos?: PagosUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoUncheckedUpdateWithoutCursosMatriculadosInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    Pagos?: PagosUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type NotaUpsertWithWhereUniqueWithoutCursoMatriculadoInput = {
    where: NotaWhereUniqueInput
    update: XOR<NotaUpdateWithoutCursoMatriculadoInput, NotaUncheckedUpdateWithoutCursoMatriculadoInput>
    create: XOR<NotaCreateWithoutCursoMatriculadoInput, NotaUncheckedCreateWithoutCursoMatriculadoInput>
  }

  export type NotaUpdateWithWhereUniqueWithoutCursoMatriculadoInput = {
    where: NotaWhereUniqueInput
    data: XOR<NotaUpdateWithoutCursoMatriculadoInput, NotaUncheckedUpdateWithoutCursoMatriculadoInput>
  }

  export type NotaUpdateManyWithWhereWithoutCursoMatriculadoInput = {
    where: NotaScalarWhereInput
    data: XOR<NotaUpdateManyMutationInput, NotaUncheckedUpdateManyWithoutCursoMatriculadoInput>
  }

  export type NotaScalarWhereInput = {
    AND?: NotaScalarWhereInput | NotaScalarWhereInput[]
    OR?: NotaScalarWhereInput[]
    NOT?: NotaScalarWhereInput | NotaScalarWhereInput[]
    id?: StringFilter<"Nota"> | string
    nombre?: StringFilter<"Nota"> | string
    calificacion?: FloatFilter<"Nota"> | number
    peso?: FloatFilter<"Nota"> | number
    cursoMatriculadoId?: StringFilter<"Nota"> | string
  }

  export type CursoMatriculadoCreateWithoutNotasInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    curso: CursoCreateNestedOneWithoutCursoMatriculadoInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedOneWithoutCursosMatriculadosInput
  }

  export type CursoMatriculadoUncheckedCreateWithoutNotasInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    periodoMatriculadoId?: string | null
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
  }

  export type CursoMatriculadoCreateOrConnectWithoutNotasInput = {
    where: CursoMatriculadoWhereUniqueInput
    create: XOR<CursoMatriculadoCreateWithoutNotasInput, CursoMatriculadoUncheckedCreateWithoutNotasInput>
  }

  export type CursoMatriculadoUpsertWithoutNotasInput = {
    update: XOR<CursoMatriculadoUpdateWithoutNotasInput, CursoMatriculadoUncheckedUpdateWithoutNotasInput>
    create: XOR<CursoMatriculadoCreateWithoutNotasInput, CursoMatriculadoUncheckedCreateWithoutNotasInput>
    where?: CursoMatriculadoWhereInput
  }

  export type CursoMatriculadoUpdateToOneWithWhereWithoutNotasInput = {
    where?: CursoMatriculadoWhereInput
    data: XOR<CursoMatriculadoUpdateWithoutNotasInput, CursoMatriculadoUncheckedUpdateWithoutNotasInput>
  }

  export type CursoMatriculadoUpdateWithoutNotasInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: CursoUpdateOneRequiredWithoutCursoMatriculadoNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateOneWithoutCursosMatriculadosNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateWithoutNotasInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    idCurso?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateWithoutPagosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPagosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPagosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPagosInput, UsuarioUncheckedCreateWithoutPagosInput>
  }

  export type PeriodoMatriculadoCreateWithoutPagosInput = {
    id?: string
    semestre: number
    periodo: string
    Usuario?: UsuarioCreateNestedOneWithoutPeriodoMatriculadoInput
    cursosMatriculados?: CursoMatriculadoCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoUncheckedCreateWithoutPagosInput = {
    id?: string
    semestre: number
    periodo: string
    idUsuario?: string | null
    cursosMatriculados?: CursoMatriculadoUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoCreateOrConnectWithoutPagosInput = {
    where: PeriodoMatriculadoWhereUniqueInput
    create: XOR<PeriodoMatriculadoCreateWithoutPagosInput, PeriodoMatriculadoUncheckedCreateWithoutPagosInput>
  }

  export type UsuarioUpsertWithoutPagosInput = {
    update: XOR<UsuarioUpdateWithoutPagosInput, UsuarioUncheckedUpdateWithoutPagosInput>
    create: XOR<UsuarioCreateWithoutPagosInput, UsuarioUncheckedCreateWithoutPagosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPagosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPagosInput, UsuarioUncheckedUpdateWithoutPagosInput>
  }

  export type UsuarioUpdateWithoutPagosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPagosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PeriodoMatriculadoUpsertWithoutPagosInput = {
    update: XOR<PeriodoMatriculadoUpdateWithoutPagosInput, PeriodoMatriculadoUncheckedUpdateWithoutPagosInput>
    create: XOR<PeriodoMatriculadoCreateWithoutPagosInput, PeriodoMatriculadoUncheckedCreateWithoutPagosInput>
    where?: PeriodoMatriculadoWhereInput
  }

  export type PeriodoMatriculadoUpdateToOneWithWhereWithoutPagosInput = {
    where?: PeriodoMatriculadoWhereInput
    data: XOR<PeriodoMatriculadoUpdateWithoutPagosInput, PeriodoMatriculadoUncheckedUpdateWithoutPagosInput>
  }

  export type PeriodoMatriculadoUpdateWithoutPagosInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneWithoutPeriodoMatriculadoNestedInput
    cursosMatriculados?: CursoMatriculadoUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoUncheckedUpdateWithoutPagosInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    cursosMatriculados?: CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type ServiciosUtilizadosCreateWithoutServicioInput = {
    id?: string
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
    Usuario?: UsuarioCreateNestedOneWithoutServiciosUtilizadosInput
  }

  export type ServiciosUtilizadosUncheckedCreateWithoutServicioInput = {
    id?: string
    idUsuario?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type ServiciosUtilizadosCreateOrConnectWithoutServicioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    create: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput>
  }

  export type ServiciosUtilizadosCreateManyServicioInputEnvelope = {
    data: ServiciosUtilizadosCreateManyServicioInput | ServiciosUtilizadosCreateManyServicioInput[]
  }

  export type ServiciosUtilizadosUpsertWithWhereUniqueWithoutServicioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    update: XOR<ServiciosUtilizadosUpdateWithoutServicioInput, ServiciosUtilizadosUncheckedUpdateWithoutServicioInput>
    create: XOR<ServiciosUtilizadosCreateWithoutServicioInput, ServiciosUtilizadosUncheckedCreateWithoutServicioInput>
  }

  export type ServiciosUtilizadosUpdateWithWhereUniqueWithoutServicioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    data: XOR<ServiciosUtilizadosUpdateWithoutServicioInput, ServiciosUtilizadosUncheckedUpdateWithoutServicioInput>
  }

  export type ServiciosUtilizadosUpdateManyWithWhereWithoutServicioInput = {
    where: ServiciosUtilizadosScalarWhereInput
    data: XOR<ServiciosUtilizadosUpdateManyMutationInput, ServiciosUtilizadosUncheckedUpdateManyWithoutServicioInput>
  }

  export type ServiciosUtilizadosScalarWhereInput = {
    AND?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
    OR?: ServiciosUtilizadosScalarWhereInput[]
    NOT?: ServiciosUtilizadosScalarWhereInput | ServiciosUtilizadosScalarWhereInput[]
    id?: StringFilter<"ServiciosUtilizados"> | string
    idServicio?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    idUsuario?: StringNullableFilter<"ServiciosUtilizados"> | string | null
    fechaRegistro?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    horarioElegido?: DateTimeNullableFilter<"ServiciosUtilizados"> | Date | string | null
    estado?: StringNullableFilter<"ServiciosUtilizados"> | string | null
  }

  export type TramitesRealizadosCreateWithoutTramiteInput = {
    id?: string
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
    Usuario?: UsuarioCreateNestedOneWithoutTramitesRealizadosInput
  }

  export type TramitesRealizadosUncheckedCreateWithoutTramiteInput = {
    id?: string
    idUsuario?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type TramitesRealizadosCreateOrConnectWithoutTramiteInput = {
    where: TramitesRealizadosWhereUniqueInput
    create: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput>
  }

  export type TramitesRealizadosCreateManyTramiteInputEnvelope = {
    data: TramitesRealizadosCreateManyTramiteInput | TramitesRealizadosCreateManyTramiteInput[]
  }

  export type TramitesRealizadosUpsertWithWhereUniqueWithoutTramiteInput = {
    where: TramitesRealizadosWhereUniqueInput
    update: XOR<TramitesRealizadosUpdateWithoutTramiteInput, TramitesRealizadosUncheckedUpdateWithoutTramiteInput>
    create: XOR<TramitesRealizadosCreateWithoutTramiteInput, TramitesRealizadosUncheckedCreateWithoutTramiteInput>
  }

  export type TramitesRealizadosUpdateWithWhereUniqueWithoutTramiteInput = {
    where: TramitesRealizadosWhereUniqueInput
    data: XOR<TramitesRealizadosUpdateWithoutTramiteInput, TramitesRealizadosUncheckedUpdateWithoutTramiteInput>
  }

  export type TramitesRealizadosUpdateManyWithWhereWithoutTramiteInput = {
    where: TramitesRealizadosScalarWhereInput
    data: XOR<TramitesRealizadosUpdateManyMutationInput, TramitesRealizadosUncheckedUpdateManyWithoutTramiteInput>
  }

  export type TramitesRealizadosScalarWhereInput = {
    AND?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
    OR?: TramitesRealizadosScalarWhereInput[]
    NOT?: TramitesRealizadosScalarWhereInput | TramitesRealizadosScalarWhereInput[]
    id?: StringFilter<"TramitesRealizados"> | string
    idTramite?: StringNullableFilter<"TramitesRealizados"> | string | null
    idUsuario?: StringNullableFilter<"TramitesRealizados"> | string | null
    fechas?: DateTimeNullableFilter<"TramitesRealizados"> | Date | string | null
    documentos?: StringNullableListFilter<"TramitesRealizados">
    estado?: StringNullableFilter<"TramitesRealizados"> | string | null
    adicional?: StringNullableFilter<"TramitesRealizados"> | string | null
  }

  export type UsuarioCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPeriodoMatriculadoInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPeriodoMatriculadoInput, UsuarioUncheckedCreateWithoutPeriodoMatriculadoInput>
  }

  export type PagosCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    Usuario?: UsuarioCreateNestedOneWithoutPagosInput
  }

  export type PagosUncheckedCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    usuarioId?: string | null
  }

  export type PagosCreateOrConnectWithoutPeriodoMatriculadoInput = {
    where: PagosWhereUniqueInput
    create: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput>
  }

  export type PagosCreateManyPeriodoMatriculadoInputEnvelope = {
    data: PagosCreateManyPeriodoMatriculadoInput | PagosCreateManyPeriodoMatriculadoInput[]
  }

  export type CursoMatriculadoCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    curso: CursoCreateNestedOneWithoutCursoMatriculadoInput
    notas?: NotaCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
    notas?: NotaUncheckedCreateNestedManyWithoutCursoMatriculadoInput
  }

  export type CursoMatriculadoCreateOrConnectWithoutPeriodoMatriculadoInput = {
    where: CursoMatriculadoWhereUniqueInput
    create: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput>
  }

  export type CursoMatriculadoCreateManyPeriodoMatriculadoInputEnvelope = {
    data: CursoMatriculadoCreateManyPeriodoMatriculadoInput | CursoMatriculadoCreateManyPeriodoMatriculadoInput[]
  }

  export type UsuarioUpsertWithoutPeriodoMatriculadoInput = {
    update: XOR<UsuarioUpdateWithoutPeriodoMatriculadoInput, UsuarioUncheckedUpdateWithoutPeriodoMatriculadoInput>
    create: XOR<UsuarioCreateWithoutPeriodoMatriculadoInput, UsuarioUncheckedCreateWithoutPeriodoMatriculadoInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPeriodoMatriculadoInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPeriodoMatriculadoInput, UsuarioUncheckedUpdateWithoutPeriodoMatriculadoInput>
  }

  export type UsuarioUpdateWithoutPeriodoMatriculadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPeriodoMatriculadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type PagosUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput = {
    where: PagosWhereUniqueInput
    update: XOR<PagosUpdateWithoutPeriodoMatriculadoInput, PagosUncheckedUpdateWithoutPeriodoMatriculadoInput>
    create: XOR<PagosCreateWithoutPeriodoMatriculadoInput, PagosUncheckedCreateWithoutPeriodoMatriculadoInput>
  }

  export type PagosUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput = {
    where: PagosWhereUniqueInput
    data: XOR<PagosUpdateWithoutPeriodoMatriculadoInput, PagosUncheckedUpdateWithoutPeriodoMatriculadoInput>
  }

  export type PagosUpdateManyWithWhereWithoutPeriodoMatriculadoInput = {
    where: PagosScalarWhereInput
    data: XOR<PagosUpdateManyMutationInput, PagosUncheckedUpdateManyWithoutPeriodoMatriculadoInput>
  }

  export type PagosScalarWhereInput = {
    AND?: PagosScalarWhereInput | PagosScalarWhereInput[]
    OR?: PagosScalarWhereInput[]
    NOT?: PagosScalarWhereInput | PagosScalarWhereInput[]
    id?: StringFilter<"Pagos"> | string
    cod?: StringFilter<"Pagos"> | string
    descripcion?: StringFilter<"Pagos"> | string
    monto?: FloatFilter<"Pagos"> | number
    fechaVencimiento?: DateTimeFilter<"Pagos"> | Date | string
    estado?: StringFilter<"Pagos"> | string
    urlRecibo?: StringNullableFilter<"Pagos"> | string | null
    tipo?: StringFilter<"Pagos"> | string
    usuarioId?: StringNullableFilter<"Pagos"> | string | null
    periodoMatriculadoId?: StringNullableFilter<"Pagos"> | string | null
  }

  export type CursoMatriculadoUpsertWithWhereUniqueWithoutPeriodoMatriculadoInput = {
    where: CursoMatriculadoWhereUniqueInput
    update: XOR<CursoMatriculadoUpdateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedUpdateWithoutPeriodoMatriculadoInput>
    create: XOR<CursoMatriculadoCreateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedCreateWithoutPeriodoMatriculadoInput>
  }

  export type CursoMatriculadoUpdateWithWhereUniqueWithoutPeriodoMatriculadoInput = {
    where: CursoMatriculadoWhereUniqueInput
    data: XOR<CursoMatriculadoUpdateWithoutPeriodoMatriculadoInput, CursoMatriculadoUncheckedUpdateWithoutPeriodoMatriculadoInput>
  }

  export type CursoMatriculadoUpdateManyWithWhereWithoutPeriodoMatriculadoInput = {
    where: CursoMatriculadoScalarWhereInput
    data: XOR<CursoMatriculadoUpdateManyMutationInput, CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoInput>
  }

  export type TramitesRealizadosCreateWithoutUsuarioInput = {
    id?: string
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
    tramite?: TramitesCreateNestedOneWithoutTramitesRealizadosInput
  }

  export type TramitesRealizadosUncheckedCreateWithoutUsuarioInput = {
    id?: string
    idTramite?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type TramitesRealizadosCreateOrConnectWithoutUsuarioInput = {
    where: TramitesRealizadosWhereUniqueInput
    create: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput>
  }

  export type TramitesRealizadosCreateManyUsuarioInputEnvelope = {
    data: TramitesRealizadosCreateManyUsuarioInput | TramitesRealizadosCreateManyUsuarioInput[]
  }

  export type ServiciosUtilizadosCreateWithoutUsuarioInput = {
    id?: string
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
    servicio?: ServiciosCreateNestedOneWithoutServiciosUtilizadosInput
  }

  export type ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput = {
    id?: string
    idServicio?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type ServiciosUtilizadosCreateOrConnectWithoutUsuarioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    create: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput>
  }

  export type ServiciosUtilizadosCreateManyUsuarioInputEnvelope = {
    data: ServiciosUtilizadosCreateManyUsuarioInput | ServiciosUtilizadosCreateManyUsuarioInput[]
  }

  export type PagosCreateWithoutUsuarioInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedOneWithoutPagosInput
  }

  export type PagosUncheckedCreateWithoutUsuarioInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    periodoMatriculadoId?: string | null
  }

  export type PagosCreateOrConnectWithoutUsuarioInput = {
    where: PagosWhereUniqueInput
    create: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput>
  }

  export type PagosCreateManyUsuarioInputEnvelope = {
    data: PagosCreateManyUsuarioInput | PagosCreateManyUsuarioInput[]
  }

  export type PeriodoMatriculadoCreateWithoutUsuarioInput = {
    id?: string
    semestre: number
    periodo: string
    Pagos?: PagosCreateNestedManyWithoutPeriodoMatriculadoInput
    cursosMatriculados?: CursoMatriculadoCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput = {
    id?: string
    semestre: number
    periodo: string
    Pagos?: PagosUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
    cursosMatriculados?: CursoMatriculadoUncheckedCreateNestedManyWithoutPeriodoMatriculadoInput
  }

  export type PeriodoMatriculadoCreateOrConnectWithoutUsuarioInput = {
    where: PeriodoMatriculadoWhereUniqueInput
    create: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput>
  }

  export type PeriodoMatriculadoCreateManyUsuarioInputEnvelope = {
    data: PeriodoMatriculadoCreateManyUsuarioInput | PeriodoMatriculadoCreateManyUsuarioInput[]
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type EventCreateWithoutUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUncheckedCreateWithoutUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutUsuarioInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput>
  }

  export type EventCreateManyUsuarioInputEnvelope = {
    data: EventCreateManyUsuarioInput | EventCreateManyUsuarioInput[]
  }

  export type TaskCreateWithoutUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
  }

  export type TaskUncheckedCreateWithoutUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
  }

  export type TaskCreateOrConnectWithoutUsuarioInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput>
  }

  export type TaskCreateManyUsuarioInputEnvelope = {
    data: TaskCreateManyUsuarioInput | TaskCreateManyUsuarioInput[]
  }

  export type TramitesRealizadosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TramitesRealizadosWhereUniqueInput
    update: XOR<TramitesRealizadosUpdateWithoutUsuarioInput, TramitesRealizadosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TramitesRealizadosCreateWithoutUsuarioInput, TramitesRealizadosUncheckedCreateWithoutUsuarioInput>
  }

  export type TramitesRealizadosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TramitesRealizadosWhereUniqueInput
    data: XOR<TramitesRealizadosUpdateWithoutUsuarioInput, TramitesRealizadosUncheckedUpdateWithoutUsuarioInput>
  }

  export type TramitesRealizadosUpdateManyWithWhereWithoutUsuarioInput = {
    where: TramitesRealizadosScalarWhereInput
    data: XOR<TramitesRealizadosUpdateManyMutationInput, TramitesRealizadosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ServiciosUtilizadosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    update: XOR<ServiciosUtilizadosUpdateWithoutUsuarioInput, ServiciosUtilizadosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ServiciosUtilizadosCreateWithoutUsuarioInput, ServiciosUtilizadosUncheckedCreateWithoutUsuarioInput>
  }

  export type ServiciosUtilizadosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ServiciosUtilizadosWhereUniqueInput
    data: XOR<ServiciosUtilizadosUpdateWithoutUsuarioInput, ServiciosUtilizadosUncheckedUpdateWithoutUsuarioInput>
  }

  export type ServiciosUtilizadosUpdateManyWithWhereWithoutUsuarioInput = {
    where: ServiciosUtilizadosScalarWhereInput
    data: XOR<ServiciosUtilizadosUpdateManyMutationInput, ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PagosUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PagosWhereUniqueInput
    update: XOR<PagosUpdateWithoutUsuarioInput, PagosUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PagosCreateWithoutUsuarioInput, PagosUncheckedCreateWithoutUsuarioInput>
  }

  export type PagosUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PagosWhereUniqueInput
    data: XOR<PagosUpdateWithoutUsuarioInput, PagosUncheckedUpdateWithoutUsuarioInput>
  }

  export type PagosUpdateManyWithWhereWithoutUsuarioInput = {
    where: PagosScalarWhereInput
    data: XOR<PagosUpdateManyMutationInput, PagosUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PeriodoMatriculadoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PeriodoMatriculadoWhereUniqueInput
    update: XOR<PeriodoMatriculadoUpdateWithoutUsuarioInput, PeriodoMatriculadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PeriodoMatriculadoCreateWithoutUsuarioInput, PeriodoMatriculadoUncheckedCreateWithoutUsuarioInput>
  }

  export type PeriodoMatriculadoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PeriodoMatriculadoWhereUniqueInput
    data: XOR<PeriodoMatriculadoUpdateWithoutUsuarioInput, PeriodoMatriculadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type PeriodoMatriculadoUpdateManyWithWhereWithoutUsuarioInput = {
    where: PeriodoMatriculadoScalarWhereInput
    data: XOR<PeriodoMatriculadoUpdateManyMutationInput, PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PeriodoMatriculadoScalarWhereInput = {
    AND?: PeriodoMatriculadoScalarWhereInput | PeriodoMatriculadoScalarWhereInput[]
    OR?: PeriodoMatriculadoScalarWhereInput[]
    NOT?: PeriodoMatriculadoScalarWhereInput | PeriodoMatriculadoScalarWhereInput[]
    id?: StringFilter<"PeriodoMatriculado"> | string
    semestre?: IntFilter<"PeriodoMatriculado"> | number
    periodo?: StringFilter<"PeriodoMatriculado"> | string
    idUsuario?: StringNullableFilter<"PeriodoMatriculado"> | string | null
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    access_token?: StringNullableFilter<"Account"> | string | null
    refresh_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    token_type?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUsuarioInput, EventUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EventCreateWithoutUsuarioInput, EventUncheckedCreateWithoutUsuarioInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUsuarioInput, EventUncheckedUpdateWithoutUsuarioInput>
  }

  export type EventUpdateManyWithWhereWithoutUsuarioInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    notificationTime?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    idUsuario?: StringNullableFilter<"Event"> | string | null
  }

  export type TaskUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUsuarioInput, TaskUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TaskCreateWithoutUsuarioInput, TaskUncheckedCreateWithoutUsuarioInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUsuarioInput, TaskUncheckedUpdateWithoutUsuarioInput>
  }

  export type TaskUpdateManyWithWhereWithoutUsuarioInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    category?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    completed?: BoolFilter<"Task"> | boolean
    idUsuario?: StringNullableFilter<"Task"> | string | null
  }

  export type UsuarioCreateWithoutAccountsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAccountsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAccountsInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAccountsInput, UsuarioUncheckedCreateWithoutAccountsInput>
  }

  export type UsuarioUpsertWithoutAccountsInput = {
    update: XOR<UsuarioUpdateWithoutAccountsInput, UsuarioUncheckedUpdateWithoutAccountsInput>
    create: XOR<UsuarioCreateWithoutAccountsInput, UsuarioUncheckedCreateWithoutAccountsInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAccountsInput, UsuarioUncheckedUpdateWithoutAccountsInput>
  }

  export type UsuarioUpdateWithoutAccountsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAccountsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutSessionsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutSessionsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutSessionsInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSessionsInput, UsuarioUncheckedCreateWithoutSessionsInput>
  }

  export type UsuarioUpsertWithoutSessionsInput = {
    update: XOR<UsuarioUpdateWithoutSessionsInput, UsuarioUncheckedUpdateWithoutSessionsInput>
    create: XOR<UsuarioCreateWithoutSessionsInput, UsuarioUncheckedCreateWithoutSessionsInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutSessionsInput, UsuarioUncheckedUpdateWithoutSessionsInput>
  }

  export type UsuarioUpdateWithoutSessionsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSessionsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type TramitesCreateWithoutTramitesRealizadosInput = {
    id?: string
    nombre: string
    tipo: string
    costo?: number | null
    requisitos?: TramitesCreaterequisitosInput | string[]
    descripcion: string
  }

  export type TramitesUncheckedCreateWithoutTramitesRealizadosInput = {
    id?: string
    nombre: string
    tipo: string
    costo?: number | null
    requisitos?: TramitesCreaterequisitosInput | string[]
    descripcion: string
  }

  export type TramitesCreateOrConnectWithoutTramitesRealizadosInput = {
    where: TramitesWhereUniqueInput
    create: XOR<TramitesCreateWithoutTramitesRealizadosInput, TramitesUncheckedCreateWithoutTramitesRealizadosInput>
  }

  export type UsuarioCreateWithoutTramitesRealizadosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTramitesRealizadosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTramitesRealizadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTramitesRealizadosInput, UsuarioUncheckedCreateWithoutTramitesRealizadosInput>
  }

  export type TramitesUpsertWithoutTramitesRealizadosInput = {
    update: XOR<TramitesUpdateWithoutTramitesRealizadosInput, TramitesUncheckedUpdateWithoutTramitesRealizadosInput>
    create: XOR<TramitesCreateWithoutTramitesRealizadosInput, TramitesUncheckedCreateWithoutTramitesRealizadosInput>
    where?: TramitesWhereInput
  }

  export type TramitesUpdateToOneWithWhereWithoutTramitesRealizadosInput = {
    where?: TramitesWhereInput
    data: XOR<TramitesUpdateWithoutTramitesRealizadosInput, TramitesUncheckedUpdateWithoutTramitesRealizadosInput>
  }

  export type TramitesUpdateWithoutTramitesRealizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type TramitesUncheckedUpdateWithoutTramitesRealizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    costo?: NullableFloatFieldUpdateOperationsInput | number | null
    requisitos?: TramitesUpdaterequisitosInput | string[]
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type UsuarioUpsertWithoutTramitesRealizadosInput = {
    update: XOR<UsuarioUpdateWithoutTramitesRealizadosInput, UsuarioUncheckedUpdateWithoutTramitesRealizadosInput>
    create: XOR<UsuarioCreateWithoutTramitesRealizadosInput, UsuarioUncheckedCreateWithoutTramitesRealizadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTramitesRealizadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTramitesRealizadosInput, UsuarioUncheckedUpdateWithoutTramitesRealizadosInput>
  }

  export type UsuarioUpdateWithoutTramitesRealizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTramitesRealizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ServiciosCreateWithoutServiciosUtilizadosInput = {
    id?: string
    nombre: string
    tipo: string
    fechas?: ServiciosCreatefechasInput | Date[] | string[]
  }

  export type ServiciosUncheckedCreateWithoutServiciosUtilizadosInput = {
    id?: string
    nombre: string
    tipo: string
    fechas?: ServiciosCreatefechasInput | Date[] | string[]
  }

  export type ServiciosCreateOrConnectWithoutServiciosUtilizadosInput = {
    where: ServiciosWhereUniqueInput
    create: XOR<ServiciosCreateWithoutServiciosUtilizadosInput, ServiciosUncheckedCreateWithoutServiciosUtilizadosInput>
  }

  export type UsuarioCreateWithoutServiciosUtilizadosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutServiciosUtilizadosInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutServiciosUtilizadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutServiciosUtilizadosInput, UsuarioUncheckedCreateWithoutServiciosUtilizadosInput>
  }

  export type ServiciosUpsertWithoutServiciosUtilizadosInput = {
    update: XOR<ServiciosUpdateWithoutServiciosUtilizadosInput, ServiciosUncheckedUpdateWithoutServiciosUtilizadosInput>
    create: XOR<ServiciosCreateWithoutServiciosUtilizadosInput, ServiciosUncheckedCreateWithoutServiciosUtilizadosInput>
    where?: ServiciosWhereInput
  }

  export type ServiciosUpdateToOneWithWhereWithoutServiciosUtilizadosInput = {
    where?: ServiciosWhereInput
    data: XOR<ServiciosUpdateWithoutServiciosUtilizadosInput, ServiciosUncheckedUpdateWithoutServiciosUtilizadosInput>
  }

  export type ServiciosUpdateWithoutServiciosUtilizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
  }

  export type ServiciosUncheckedUpdateWithoutServiciosUtilizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    fechas?: ServiciosUpdatefechasInput | Date[] | string[]
  }

  export type UsuarioUpsertWithoutServiciosUtilizadosInput = {
    update: XOR<UsuarioUpdateWithoutServiciosUtilizadosInput, UsuarioUncheckedUpdateWithoutServiciosUtilizadosInput>
    create: XOR<UsuarioCreateWithoutServiciosUtilizadosInput, UsuarioUncheckedCreateWithoutServiciosUtilizadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutServiciosUtilizadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutServiciosUtilizadosInput, UsuarioUncheckedUpdateWithoutServiciosUtilizadosInput>
  }

  export type UsuarioUpdateWithoutServiciosUtilizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutServiciosUtilizadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutEventsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEventsInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEventsInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEventsInput, UsuarioUncheckedCreateWithoutEventsInput>
  }

  export type UsuarioUpsertWithoutEventsInput = {
    update: XOR<UsuarioUpdateWithoutEventsInput, UsuarioUncheckedUpdateWithoutEventsInput>
    create: XOR<UsuarioCreateWithoutEventsInput, UsuarioUncheckedCreateWithoutEventsInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEventsInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEventsInput, UsuarioUncheckedUpdateWithoutEventsInput>
  }

  export type UsuarioUpdateWithoutEventsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEventsInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutTasksInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoCreateNestedManyWithoutUsuarioInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    events?: EventCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTasksInput = {
    id?: string
    nombre: string
    email: string
    carrera: string
    password?: string | null
    image?: string | null
    emailVerified?: Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedCreateNestedManyWithoutUsuarioInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedCreateNestedManyWithoutUsuarioInput
    Pagos?: PagosUncheckedCreateNestedManyWithoutUsuarioInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedCreateNestedManyWithoutUsuarioInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    events?: EventUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTasksInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTasksInput, UsuarioUncheckedCreateWithoutTasksInput>
  }

  export type UsuarioUpsertWithoutTasksInput = {
    update: XOR<UsuarioUpdateWithoutTasksInput, UsuarioUncheckedUpdateWithoutTasksInput>
    create: XOR<UsuarioCreateWithoutTasksInput, UsuarioUncheckedCreateWithoutTasksInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTasksInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTasksInput, UsuarioUncheckedUpdateWithoutTasksInput>
  }

  export type UsuarioUpdateWithoutTasksInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    events?: EventUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTasksInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    carrera?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    TramitesRealizados?: TramitesRealizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    ServiciosUtilizados?: ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioNestedInput
    Pagos?: PagosUncheckedUpdateManyWithoutUsuarioNestedInput
    PeriodoMatriculado?: PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    events?: EventUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CursosMallaCreateManyMallaInput = {
    id?: string
  }

  export type CursosMallaUpdateWithoutMallaInput = {
    cursos?: CursoUpdateManyWithoutCursosMallaNestedInput
  }

  export type CursosMallaUncheckedUpdateWithoutMallaInput = {
    cursos?: CursoUncheckedUpdateManyWithoutCursosMallaNestedInput
  }

  export type CursosMallaUncheckedUpdateManyWithoutMallaInput = {

  }

  export type CursoCreateManyCursosMallaInput = {
    id?: string
    cod: string
    nombre: string
    creditos: number
    horas: number
    semestre: number
  }

  export type CursoUpdateWithoutCursosMallaInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    CursoMatriculado?: CursoMatriculadoUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateWithoutCursosMallaInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
    CursoMatriculado?: CursoMatriculadoUncheckedUpdateManyWithoutCursoNestedInput
  }

  export type CursoUncheckedUpdateManyWithoutCursosMallaInput = {
    cod?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    creditos?: IntFieldUpdateOperationsInput | number
    horas?: IntFieldUpdateOperationsInput | number
    semestre?: IntFieldUpdateOperationsInput | number
  }

  export type CursoMatriculadoCreateManyCursoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    vez: number
    status: string
    periodoMatriculadoId?: string | null
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
  }

  export type CursoMatriculadoUpdateWithoutCursoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    PeriodoMatriculado?: PeriodoMatriculadoUpdateOneWithoutCursosMatriculadosNestedInput
    notas?: NotaUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateWithoutCursoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notas?: NotaUncheckedUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateManyWithoutCursoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotaCreateManyCursoMatriculadoInput = {
    id?: string
    nombre: string
    calificacion: number
    peso: number
  }

  export type NotaUpdateWithoutCursoMatriculadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
  }

  export type NotaUncheckedUpdateWithoutCursoMatriculadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
  }

  export type NotaUncheckedUpdateManyWithoutCursoMatriculadoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    calificacion?: FloatFieldUpdateOperationsInput | number
    peso?: FloatFieldUpdateOperationsInput | number
  }

  export type ServiciosUtilizadosCreateManyServicioInput = {
    id?: string
    idUsuario?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type ServiciosUtilizadosUpdateWithoutServicioInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    Usuario?: UsuarioUpdateOneWithoutServiciosUtilizadosNestedInput
  }

  export type ServiciosUtilizadosUncheckedUpdateWithoutServicioInput = {
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosUncheckedUpdateManyWithoutServicioInput = {
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TramitesRealizadosCreateManyTramiteInput = {
    id?: string
    idUsuario?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type TramitesRealizadosUpdateWithoutTramiteInput = {
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    Usuario?: UsuarioUpdateOneWithoutTramitesRealizadosNestedInput
  }

  export type TramitesRealizadosUncheckedUpdateWithoutTramiteInput = {
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TramitesRealizadosUncheckedUpdateManyWithoutTramiteInput = {
    idUsuario?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagosCreateManyPeriodoMatriculadoInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    usuarioId?: string | null
  }

  export type CursoMatriculadoCreateManyPeriodoMatriculadoInput = {
    id?: string
    averageGrade: number
    salon: string
    profesor: string
    idCurso: string
    vez: number
    status: string
    diasClase?: CursoMatriculadoCreatediasClaseInput | number[]
    horaInicio: Date | string
  }

  export type PagosUpdateWithoutPeriodoMatriculadoInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    Usuario?: UsuarioUpdateOneWithoutPagosNestedInput
  }

  export type PagosUncheckedUpdateWithoutPeriodoMatriculadoInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagosUncheckedUpdateManyWithoutPeriodoMatriculadoInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CursoMatriculadoUpdateWithoutPeriodoMatriculadoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    curso?: CursoUpdateOneRequiredWithoutCursoMatriculadoNestedInput
    notas?: NotaUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateWithoutPeriodoMatriculadoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    idCurso?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    notas?: NotaUncheckedUpdateManyWithoutCursoMatriculadoNestedInput
  }

  export type CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoInput = {
    averageGrade?: FloatFieldUpdateOperationsInput | number
    salon?: StringFieldUpdateOperationsInput | string
    profesor?: StringFieldUpdateOperationsInput | string
    idCurso?: StringFieldUpdateOperationsInput | string
    vez?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    diasClase?: CursoMatriculadoUpdatediasClaseInput | number[]
    horaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TramitesRealizadosCreateManyUsuarioInput = {
    id?: string
    idTramite?: string | null
    fechas?: Date | string | null
    documentos?: TramitesRealizadosCreatedocumentosInput | string[]
    estado?: string | null
    adicional?: string | null
  }

  export type ServiciosUtilizadosCreateManyUsuarioInput = {
    id?: string
    idServicio?: string | null
    fechaRegistro?: Date | string | null
    horarioElegido?: Date | string | null
    estado?: string | null
  }

  export type PagosCreateManyUsuarioInput = {
    id?: string
    cod: string
    descripcion: string
    monto: number
    fechaVencimiento: Date | string
    estado: string
    urlRecibo?: string | null
    tipo: string
    periodoMatriculadoId?: string | null
  }

  export type PeriodoMatriculadoCreateManyUsuarioInput = {
    id?: string
    semestre: number
    periodo: string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    provider: string
    providerAccountId: string
    type: string
    access_token?: string | null
    refresh_token?: string | null
    expires_at?: number | null
    scope?: string | null
    id_token?: string | null
    token_type?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type EventCreateManyUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    start: Date | string
    end: Date | string
    isAllDay?: boolean
    notificationTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyUsuarioInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completed?: boolean
  }

  export type TramitesRealizadosUpdateWithoutUsuarioInput = {
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
    tramite?: TramitesUpdateOneWithoutTramitesRealizadosNestedInput
  }

  export type TramitesRealizadosUncheckedUpdateWithoutUsuarioInput = {
    idTramite?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TramitesRealizadosUncheckedUpdateManyWithoutUsuarioInput = {
    idTramite?: NullableStringFieldUpdateOperationsInput | string | null
    fechas?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: TramitesRealizadosUpdatedocumentosInput | string[]
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    adicional?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosUpdateWithoutUsuarioInput = {
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    servicio?: ServiciosUpdateOneWithoutServiciosUtilizadosNestedInput
  }

  export type ServiciosUtilizadosUncheckedUpdateWithoutUsuarioInput = {
    idServicio?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiciosUtilizadosUncheckedUpdateManyWithoutUsuarioInput = {
    idServicio?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioElegido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagosUpdateWithoutUsuarioInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    PeriodoMatriculado?: PeriodoMatriculadoUpdateOneWithoutPagosNestedInput
  }

  export type PagosUncheckedUpdateWithoutUsuarioInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PagosUncheckedUpdateManyWithoutUsuarioInput = {
    cod?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    fechaVencimiento?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    urlRecibo?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    periodoMatriculadoId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeriodoMatriculadoUpdateWithoutUsuarioInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    Pagos?: PagosUpdateManyWithoutPeriodoMatriculadoNestedInput
    cursosMatriculados?: CursoMatriculadoUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoUncheckedUpdateWithoutUsuarioInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
    Pagos?: PagosUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
    cursosMatriculados?: CursoMatriculadoUncheckedUpdateManyWithoutPeriodoMatriculadoNestedInput
  }

  export type PeriodoMatriculadoUncheckedUpdateManyWithoutUsuarioInput = {
    semestre?: IntFieldUpdateOperationsInput | number
    periodo?: StringFieldUpdateOperationsInput | string
  }

  export type AccountUpdateWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    notificationTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateManyWithoutUsuarioInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completed?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use MallaCountOutputTypeDefaultArgs instead
     */
    export type MallaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MallaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursosMallaCountOutputTypeDefaultArgs instead
     */
    export type CursosMallaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursosMallaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoCountOutputTypeDefaultArgs instead
     */
    export type CursoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoMatriculadoCountOutputTypeDefaultArgs instead
     */
    export type CursoMatriculadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosCountOutputTypeDefaultArgs instead
     */
    export type ServiciosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TramitesCountOutputTypeDefaultArgs instead
     */
    export type TramitesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TramitesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeriodoMatriculadoCountOutputTypeDefaultArgs instead
     */
    export type PeriodoMatriculadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PeriodoMatriculadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MallaDefaultArgs instead
     */
    export type MallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MallaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursosMallaDefaultArgs instead
     */
    export type CursosMallaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursosMallaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoDefaultArgs instead
     */
    export type CursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CursoMatriculadoDefaultArgs instead
     */
    export type CursoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CursoMatriculadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotaDefaultArgs instead
     */
    export type NotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagosDefaultArgs instead
     */
    export type PagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosDefaultArgs instead
     */
    export type ServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TramitesDefaultArgs instead
     */
    export type TramitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TramitesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeriodoMatriculadoDefaultArgs instead
     */
    export type PeriodoMatriculadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PeriodoMatriculadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TramitesRealizadosDefaultArgs instead
     */
    export type TramitesRealizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TramitesRealizadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiciosUtilizadosDefaultArgs instead
     */
    export type ServiciosUtilizadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiciosUtilizadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use confirmacionPagoDefaultArgs instead
     */
    export type confirmacionPagoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = confirmacionPagoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}